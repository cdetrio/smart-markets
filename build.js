"format register";

System.register("npm:process@0.10.1/browser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/escapeTextForBrowser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ESCAPE_LOOKUP = {
    "&": "&amp;",
    ">": "&gt;",
    "<": "&lt;",
    "\"": "&quot;",
    "'": "&#x27;"
  };
  var ESCAPE_REGEX = /[&><"']/g;
  function escaper(match) {
    return ESCAPE_LOOKUP[match];
  }
  function escapeTextForBrowser(text) {
    return ('' + text).replace(ESCAPE_REGEX, escaper);
  }
  module.exports = escapeTextForBrowser;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/memoizeStringOnly", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function memoizeStringOnly(callback) {
    var cache = {};
    return function(string) {
      if (cache.hasOwnProperty(string)) {
        return cache[string];
      } else {
        return cache[string] = callback.call(this, string);
      }
    };
  }
  module.exports = memoizeStringOnly;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/emptyFunction", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function makeEmptyFunction(arg) {
    return function() {
      return arg;
    };
  }
  function emptyFunction() {}
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function() {
    return this;
  };
  emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
  };
  module.exports = emptyFunction;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/keyMirror", ["./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("./invariant");
    var keyMirror = function(obj) {
      var ret = {};
      var key;
      ("production" !== process.env.NODE_ENV ? invariant(obj instanceof Object && !Array.isArray(obj), 'keyMirror(...): Argument must be an object.') : invariant(obj instanceof Object && !Array.isArray(obj)));
      for (key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }
        ret[key] = key;
      }
      return ret;
    };
    module.exports = keyMirror;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/PooledClass", ["./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("./invariant");
    var oneArgumentPooler = function(copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function(a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function(a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4, a5);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4, a5);
      }
    };
    var standardReleaser = function(instance) {
      var Klass = this;
      ("production" !== process.env.NODE_ENV ? invariant(instance instanceof Klass, 'Trying to release an instance into a pool of a different type.') : invariant(instance instanceof Klass));
      if (instance.destructor) {
        instance.destructor();
      }
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function(CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fiveArgumentPooler: fiveArgumentPooler
    };
    module.exports = PooledClass;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/Object.assign", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function assign(target, sources) {
    if (target == null) {
      throw new TypeError('Object.assign target cannot be null or undefined');
    }
    var to = Object(target);
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
      var nextSource = arguments[nextIndex];
      if (nextSource == null) {
        continue;
      }
      var from = Object(nextSource);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
    }
    return to;
  }
  ;
  module.exports = assign;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactCurrentOwner", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactCurrentOwner = {current: null};
  module.exports = ReactCurrentOwner;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactRootIndexInjection = {injectCreateReactRootIndex: function(_createReactRootIndex) {
      ReactRootIndex.createReactRootIndex = _createReactRootIndex;
    }};
  var ReactRootIndex = {
    createReactRootIndex: null,
    injection: ReactRootIndexInjection
  };
  module.exports = ReactRootIndex;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/emptyObject", ["process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyObject = {};
    if ("production" !== process.env.NODE_ENV) {
      Object.freeze(emptyObject);
    }
    module.exports = emptyObject;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CallbackQueue", ["./PooledClass", "./Object.assign", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var PooledClass = require("./PooledClass");
    var assign = require("./Object.assign");
    var invariant = require("./invariant");
    function CallbackQueue() {
      this._callbacks = null;
      this._contexts = null;
    }
    assign(CallbackQueue.prototype, {
      enqueue: function(callback, context) {
        this._callbacks = this._callbacks || [];
        this._contexts = this._contexts || [];
        this._callbacks.push(callback);
        this._contexts.push(context);
      },
      notifyAll: function() {
        var callbacks = this._callbacks;
        var contexts = this._contexts;
        if (callbacks) {
          ("production" !== process.env.NODE_ENV ? invariant(callbacks.length === contexts.length, "Mismatched list of contexts in callback queue") : invariant(callbacks.length === contexts.length));
          this._callbacks = null;
          this._contexts = null;
          for (var i = 0,
              l = callbacks.length; i < l; i++) {
            callbacks[i].call(contexts[i]);
          }
          callbacks.length = 0;
          contexts.length = 0;
        }
      },
      reset: function() {
        this._callbacks = null;
        this._contexts = null;
      },
      destructor: function() {
        this.reset();
      }
    });
    PooledClass.addPoolingTo(CallbackQueue);
    module.exports = CallbackQueue;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPerf", ["process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactPerf = {
      enableMeasure: false,
      storedMeasure: _noMeasure,
      measure: function(objName, fnName, func) {
        if ("production" !== process.env.NODE_ENV) {
          var measuredFunc = null;
          var wrapper = function() {
            if (ReactPerf.enableMeasure) {
              if (!measuredFunc) {
                measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
              }
              return measuredFunc.apply(this, arguments);
            }
            return func.apply(this, arguments);
          };
          wrapper.displayName = objName + '_' + fnName;
          return wrapper;
        }
        return func;
      },
      injection: {injectMeasure: function(measure) {
          ReactPerf.storedMeasure = measure;
        }}
    };
    function _noMeasure(objName, fnName, func) {
      return func;
    }
    module.exports = ReactPerf;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/Transaction", ["./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("./invariant");
    var Mixin = {
      reinitializeTransaction: function() {
        this.transactionWrappers = this.getTransactionWrappers();
        if (!this.wrapperInitData) {
          this.wrapperInitData = [];
        } else {
          this.wrapperInitData.length = 0;
        }
        this._isInTransaction = false;
      },
      _isInTransaction: false,
      getTransactionWrappers: null,
      isInTransaction: function() {
        return !!this._isInTransaction;
      },
      perform: function(method, scope, a, b, c, d, e, f) {
        ("production" !== process.env.NODE_ENV ? invariant(!this.isInTransaction(), 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(!this.isInTransaction()));
        var errorThrown;
        var ret;
        try {
          this._isInTransaction = true;
          errorThrown = true;
          this.initializeAll(0);
          ret = method.call(scope, a, b, c, d, e, f);
          errorThrown = false;
        } finally {
          try {
            if (errorThrown) {
              try {
                this.closeAll(0);
              } catch (err) {}
            } else {
              this.closeAll(0);
            }
          } finally {
            this._isInTransaction = false;
          }
        }
        return ret;
      },
      initializeAll: function(startIndex) {
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          try {
            this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
            this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
          } finally {
            if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
              try {
                this.initializeAll(i + 1);
              } catch (err) {}
            }
          }
        }
      },
      closeAll: function(startIndex) {
        ("production" !== process.env.NODE_ENV ? invariant(this.isInTransaction(), 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(this.isInTransaction()));
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          var initData = this.wrapperInitData[i];
          var errorThrown;
          try {
            errorThrown = true;
            if (initData !== Transaction.OBSERVED_ERROR) {
              wrapper.close && wrapper.close.call(this, initData);
            }
            errorThrown = false;
          } finally {
            if (errorThrown) {
              try {
                this.closeAll(i + 1);
              } catch (e) {}
            }
          }
        }
        this.wrapperInitData.length = 0;
      }
    };
    var Transaction = {
      Mixin: Mixin,
      OBSERVED_ERROR: {}
    };
    module.exports = Transaction;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTypeLocations", ["./keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyMirror = require("./keyMirror");
  var ReactPropTypeLocations = keyMirror({
    prop: null,
    context: null,
    childContext: null
  });
  module.exports = ReactPropTypeLocations;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/monitorCodeUse", ["./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("./invariant");
    function monitorCodeUse(eventName, data) {
      ("production" !== process.env.NODE_ENV ? invariant(eventName && !/[^a-z0-9_]/.test(eventName), 'You must provide an eventName using only the characters [a-z0-9_]') : invariant(eventName && !/[^a-z0-9_]/.test(eventName)));
    }
    module.exports = monitorCodeUse;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactEmptyComponent", ["./ReactElement", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var invariant = require("./invariant");
    var component;
    var nullComponentIdsRegistry = {};
    var ReactEmptyComponentInjection = {injectEmptyComponent: function(emptyComponent) {
        component = ReactElement.createFactory(emptyComponent);
      }};
    function getEmptyComponent() {
      ("production" !== process.env.NODE_ENV ? invariant(component, 'Trying to return null from a render, but no null placeholder component ' + 'was injected.') : invariant(component));
      return component();
    }
    function registerNullComponentID(id) {
      nullComponentIdsRegistry[id] = true;
    }
    function deregisterNullComponentID(id) {
      delete nullComponentIdsRegistry[id];
    }
    function isNullComponentID(id) {
      return nullComponentIdsRegistry[id];
    }
    var ReactEmptyComponent = {
      deregisterNullComponentID: deregisterNullComponentID,
      getEmptyComponent: getEmptyComponent,
      injection: ReactEmptyComponentInjection,
      isNullComponentID: isNullComponentID,
      registerNullComponentID: registerNullComponentID
    };
    module.exports = ReactEmptyComponent;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactErrorUtils", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactErrorUtils = {guard: function(func, name) {
      return func;
    }};
  module.exports = ReactErrorUtils;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactLegacyElement", ["./ReactCurrentOwner", "./invariant", "./monitorCodeUse", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var invariant = require("./invariant");
    var monitorCodeUse = require("./monitorCodeUse");
    var warning = require("./warning");
    var legacyFactoryLogs = {};
    function warnForLegacyFactoryCall() {
      if (!ReactLegacyElementFactory._isLegacyCallWarningEnabled) {
        return;
      }
      var owner = ReactCurrentOwner.current;
      var name = owner && owner.constructor ? owner.constructor.displayName : '';
      if (!name) {
        name = 'Something';
      }
      if (legacyFactoryLogs.hasOwnProperty(name)) {
        return;
      }
      legacyFactoryLogs[name] = true;
      ("production" !== process.env.NODE_ENV ? warning(false, name + ' is calling a React component directly. ' + 'Use a factory or JSX instead. See: http://fb.me/react-legacyfactory') : null);
      monitorCodeUse('react_legacy_factory_call', {
        version: 3,
        name: name
      });
    }
    function warnForPlainFunctionType(type) {
      var isReactClass = type.prototype && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
      if (isReactClass) {
        ("production" !== process.env.NODE_ENV ? warning(false, 'Did not expect to get a React class here. Use `Component` instead ' + 'of `Component.type` or `this.constructor`.') : null);
      } else {
        if (!type._reactWarnedForThisType) {
          try {
            type._reactWarnedForThisType = true;
          } catch (x) {}
          monitorCodeUse('react_non_component_in_jsx', {
            version: 3,
            name: type.name
          });
        }
        ("production" !== process.env.NODE_ENV ? warning(false, 'This JSX uses a plain function. Only React components are ' + 'valid in React\'s JSX transform.') : null);
      }
    }
    function warnForNonLegacyFactory(type) {
      ("production" !== process.env.NODE_ENV ? warning(false, 'Do not pass React.DOM.' + type.type + ' to JSX or createFactory. ' + 'Use the string "' + type.type + '" instead.') : null);
    }
    function proxyStaticMethods(target, source) {
      if (typeof source !== 'function') {
        return;
      }
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          var value = source[key];
          if (typeof value === 'function') {
            var bound = value.bind(source);
            for (var k in value) {
              if (value.hasOwnProperty(k)) {
                bound[k] = value[k];
              }
            }
            target[key] = bound;
          } else {
            target[key] = value;
          }
        }
      }
    }
    var LEGACY_MARKER = {};
    var NON_LEGACY_MARKER = {};
    var ReactLegacyElementFactory = {};
    ReactLegacyElementFactory.wrapCreateFactory = function(createFactory) {
      var legacyCreateFactory = function(type) {
        if (typeof type !== 'function') {
          return createFactory(type);
        }
        if (type.isReactNonLegacyFactory) {
          if ("production" !== process.env.NODE_ENV) {
            warnForNonLegacyFactory(type);
          }
          return createFactory(type.type);
        }
        if (type.isReactLegacyFactory) {
          return createFactory(type.type);
        }
        if ("production" !== process.env.NODE_ENV) {
          warnForPlainFunctionType(type);
        }
        return type;
      };
      return legacyCreateFactory;
    };
    ReactLegacyElementFactory.wrapCreateElement = function(createElement) {
      var legacyCreateElement = function(type, props, children) {
        if (typeof type !== 'function') {
          return createElement.apply(this, arguments);
        }
        var args;
        if (type.isReactNonLegacyFactory) {
          if ("production" !== process.env.NODE_ENV) {
            warnForNonLegacyFactory(type);
          }
          args = Array.prototype.slice.call(arguments, 0);
          args[0] = type.type;
          return createElement.apply(this, args);
        }
        if (type.isReactLegacyFactory) {
          if (type._isMockFunction) {
            type.type._mockedReactClassConstructor = type;
          }
          args = Array.prototype.slice.call(arguments, 0);
          args[0] = type.type;
          return createElement.apply(this, args);
        }
        if ("production" !== process.env.NODE_ENV) {
          warnForPlainFunctionType(type);
        }
        return type.apply(null, Array.prototype.slice.call(arguments, 1));
      };
      return legacyCreateElement;
    };
    ReactLegacyElementFactory.wrapFactory = function(factory) {
      ("production" !== process.env.NODE_ENV ? invariant(typeof factory === 'function', 'This is suppose to accept a element factory') : invariant(typeof factory === 'function'));
      var legacyElementFactory = function(config, children) {
        if ("production" !== process.env.NODE_ENV) {
          warnForLegacyFactoryCall();
        }
        return factory.apply(this, arguments);
      };
      proxyStaticMethods(legacyElementFactory, factory.type);
      legacyElementFactory.isReactLegacyFactory = LEGACY_MARKER;
      legacyElementFactory.type = factory.type;
      return legacyElementFactory;
    };
    ReactLegacyElementFactory.markNonLegacyFactory = function(factory) {
      factory.isReactNonLegacyFactory = NON_LEGACY_MARKER;
      return factory;
    };
    ReactLegacyElementFactory.isValidFactory = function(factory) {
      return typeof factory === 'function' && factory.isReactLegacyFactory === LEGACY_MARKER;
    };
    ReactLegacyElementFactory.isValidClass = function(factory) {
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(false, 'isValidClass is deprecated and will be removed in a future release. ' + 'Use a more specific validator instead.') : null);
      }
      return ReactLegacyElementFactory.isValidFactory(factory);
    };
    ReactLegacyElementFactory._isLegacyCallWarningEnabled = true;
    module.exports = ReactLegacyElementFactory;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/joinClasses", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function joinClasses(className) {
    if (!className) {
      className = '';
    }
    var nextClass;
    var argLength = arguments.length;
    if (argLength > 1) {
      for (var ii = 1; ii < argLength; ii++) {
        nextClass = arguments[ii];
        if (nextClass) {
          className = (className ? className + ' ' : '') + nextClass;
        }
      }
    }
    return className;
  }
  module.exports = joinClasses;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTypeLocationNames", ["process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactPropTypeLocationNames = {};
    if ("production" !== process.env.NODE_ENV) {
      ReactPropTypeLocationNames = {
        prop: 'prop',
        context: 'context',
        childContext: 'child context'
      };
    }
    module.exports = ReactPropTypeLocationNames;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactNativeComponent", ["./Object.assign", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var assign = require("./Object.assign");
    var invariant = require("./invariant");
    var genericComponentClass = null;
    var tagToComponentClass = {};
    var ReactNativeComponentInjection = {
      injectGenericComponentClass: function(componentClass) {
        genericComponentClass = componentClass;
      },
      injectComponentClasses: function(componentClasses) {
        assign(tagToComponentClass, componentClasses);
      }
    };
    function createInstanceForTag(tag, props, parentType) {
      var componentClass = tagToComponentClass[tag];
      if (componentClass == null) {
        ("production" !== process.env.NODE_ENV ? invariant(genericComponentClass, 'There is no registered component for the tag %s', tag) : invariant(genericComponentClass));
        return new genericComponentClass(tag, props);
      }
      if (parentType === tag) {
        ("production" !== process.env.NODE_ENV ? invariant(genericComponentClass, 'There is no registered component for the tag %s', tag) : invariant(genericComponentClass));
        return new genericComponentClass(tag, props);
      }
      return new componentClass.type(props);
    }
    var ReactNativeComponent = {
      createInstanceForTag: createInstanceForTag,
      injection: ReactNativeComponentInjection
    };
    module.exports = ReactNativeComponent;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/keyOf", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var keyOf = function(oneKeyObj) {
    var key;
    for (key in oneKeyObj) {
      if (!oneKeyObj.hasOwnProperty(key)) {
        continue;
      }
      return key;
    }
    return null;
  };
  module.exports = keyOf;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/mapObject", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function mapObject(object, callback, context) {
    if (!object) {
      return null;
    }
    var result = {};
    for (var name in object) {
      if (hasOwnProperty.call(object, name)) {
        result[name] = callback.call(context, object[name], name, object);
      }
    }
    return result;
  }
  module.exports = mapObject;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/shouldUpdateReactComponent", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function shouldUpdateReactComponent(prevElement, nextElement) {
    if (prevElement && nextElement && prevElement.type === nextElement.type && prevElement.key === nextElement.key && prevElement._owner === nextElement._owner) {
      return true;
    }
    return false;
  }
  module.exports = shouldUpdateReactComponent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOM", ["./ReactElement", "./ReactElementValidator", "./ReactLegacyElement", "./mapObject", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var ReactElementValidator = require("./ReactElementValidator");
    var ReactLegacyElement = require("./ReactLegacyElement");
    var mapObject = require("./mapObject");
    function createDOMFactory(tag) {
      if ("production" !== process.env.NODE_ENV) {
        return ReactLegacyElement.markNonLegacyFactory(ReactElementValidator.createFactory(tag));
      }
      return ReactLegacyElement.markNonLegacyFactory(ReactElement.createFactory(tag));
    }
    var ReactDOM = mapObject({
      a: 'a',
      abbr: 'abbr',
      address: 'address',
      area: 'area',
      article: 'article',
      aside: 'aside',
      audio: 'audio',
      b: 'b',
      base: 'base',
      bdi: 'bdi',
      bdo: 'bdo',
      big: 'big',
      blockquote: 'blockquote',
      body: 'body',
      br: 'br',
      button: 'button',
      canvas: 'canvas',
      caption: 'caption',
      cite: 'cite',
      code: 'code',
      col: 'col',
      colgroup: 'colgroup',
      data: 'data',
      datalist: 'datalist',
      dd: 'dd',
      del: 'del',
      details: 'details',
      dfn: 'dfn',
      dialog: 'dialog',
      div: 'div',
      dl: 'dl',
      dt: 'dt',
      em: 'em',
      embed: 'embed',
      fieldset: 'fieldset',
      figcaption: 'figcaption',
      figure: 'figure',
      footer: 'footer',
      form: 'form',
      h1: 'h1',
      h2: 'h2',
      h3: 'h3',
      h4: 'h4',
      h5: 'h5',
      h6: 'h6',
      head: 'head',
      header: 'header',
      hr: 'hr',
      html: 'html',
      i: 'i',
      iframe: 'iframe',
      img: 'img',
      input: 'input',
      ins: 'ins',
      kbd: 'kbd',
      keygen: 'keygen',
      label: 'label',
      legend: 'legend',
      li: 'li',
      link: 'link',
      main: 'main',
      map: 'map',
      mark: 'mark',
      menu: 'menu',
      menuitem: 'menuitem',
      meta: 'meta',
      meter: 'meter',
      nav: 'nav',
      noscript: 'noscript',
      object: 'object',
      ol: 'ol',
      optgroup: 'optgroup',
      option: 'option',
      output: 'output',
      p: 'p',
      param: 'param',
      picture: 'picture',
      pre: 'pre',
      progress: 'progress',
      q: 'q',
      rp: 'rp',
      rt: 'rt',
      ruby: 'ruby',
      s: 's',
      samp: 'samp',
      script: 'script',
      section: 'section',
      select: 'select',
      small: 'small',
      source: 'source',
      span: 'span',
      strong: 'strong',
      style: 'style',
      sub: 'sub',
      summary: 'summary',
      sup: 'sup',
      table: 'table',
      tbody: 'tbody',
      td: 'td',
      textarea: 'textarea',
      tfoot: 'tfoot',
      th: 'th',
      thead: 'thead',
      time: 'time',
      title: 'title',
      tr: 'tr',
      track: 'track',
      u: 'u',
      ul: 'ul',
      'var': 'var',
      video: 'video',
      wbr: 'wbr',
      circle: 'circle',
      defs: 'defs',
      ellipse: 'ellipse',
      g: 'g',
      line: 'line',
      linearGradient: 'linearGradient',
      mask: 'mask',
      path: 'path',
      pattern: 'pattern',
      polygon: 'polygon',
      polyline: 'polyline',
      radialGradient: 'radialGradient',
      rect: 'rect',
      stop: 'stop',
      svg: 'svg',
      text: 'text',
      tspan: 'tspan'
    }, createDOMFactory);
    module.exports = ReactDOM;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CSSProperty", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var isUnitlessNumber = {
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexShrink: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    strokeOpacity: true
  };
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
  Object.keys(isUnitlessNumber).forEach(function(prop) {
    prefixes.forEach(function(prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });
  var shorthandPropertyExpansions = {
    background: {
      backgroundImage: true,
      backgroundPosition: true,
      backgroundRepeat: true,
      backgroundColor: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    }
  };
  var CSSProperty = {
    isUnitlessNumber: isUnitlessNumber,
    shorthandPropertyExpansions: shorthandPropertyExpansions
  };
  module.exports = CSSProperty;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ExecutionEnvironment", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  var ExecutionEnvironment = {
    canUseDOM: canUseDOM,
    canUseWorkers: typeof Worker !== 'undefined',
    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
  };
  module.exports = ExecutionEnvironment;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/camelize", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var _hyphenPattern = /-(.)/g;
  function camelize(string) {
    return string.replace(_hyphenPattern, function(_, character) {
      return character.toUpperCase();
    });
  }
  module.exports = camelize;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/dangerousStyleValue", ["./CSSProperty"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var CSSProperty = require("./CSSProperty");
  var isUnitlessNumber = CSSProperty.isUnitlessNumber;
  function dangerousStyleValue(name, value) {
    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }
    var isNonNumeric = isNaN(value);
    if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
      return '' + value;
    }
    if (typeof value === 'string') {
      value = value.trim();
    }
    return value + 'px';
  }
  module.exports = dangerousStyleValue;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/hyphenate", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var _uppercasePattern = /([A-Z])/g;
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }
  module.exports = hyphenate;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPluginRegistry", ["./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("./invariant");
    var EventPluginOrder = null;
    var namesToPlugins = {};
    function recomputePluginOrdering() {
      if (!EventPluginOrder) {
        return;
      }
      for (var pluginName in namesToPlugins) {
        var PluginModule = namesToPlugins[pluginName];
        var pluginIndex = EventPluginOrder.indexOf(pluginName);
        ("production" !== process.env.NODE_ENV ? invariant(pluginIndex > -1, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(pluginIndex > -1));
        if (EventPluginRegistry.plugins[pluginIndex]) {
          continue;
        }
        ("production" !== process.env.NODE_ENV ? invariant(PluginModule.extractEvents, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(PluginModule.extractEvents));
        EventPluginRegistry.plugins[pluginIndex] = PluginModule;
        var publishedEvents = PluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          ("production" !== process.env.NODE_ENV ? invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName), 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName)));
        }
      }
    }
    function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
      ("production" !== process.env.NODE_ENV ? invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName), 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)));
      EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
        return true;
      }
      return false;
    }
    function publishRegistrationName(registrationName, PluginModule, eventName) {
      ("production" !== process.env.NODE_ENV ? invariant(!EventPluginRegistry.registrationNameModules[registrationName], 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]));
      EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
      EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
    }
    var EventPluginRegistry = {
      plugins: [],
      eventNameDispatchConfigs: {},
      registrationNameModules: {},
      registrationNameDependencies: {},
      injectEventPluginOrder: function(InjectedEventPluginOrder) {
        ("production" !== process.env.NODE_ENV ? invariant(!EventPluginOrder, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(!EventPluginOrder));
        EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
        recomputePluginOrdering();
      },
      injectEventPluginsByName: function(injectedNamesToPlugins) {
        var isOrderingDirty = false;
        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }
          var PluginModule = injectedNamesToPlugins[pluginName];
          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
            ("production" !== process.env.NODE_ENV ? invariant(!namesToPlugins[pluginName], 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(!namesToPlugins[pluginName]));
            namesToPlugins[pluginName] = PluginModule;
            isOrderingDirty = true;
          }
        }
        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      },
      getPluginModuleForEvent: function(event) {
        var dispatchConfig = event.dispatchConfig;
        if (dispatchConfig.registrationName) {
          return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
        }
        for (var phase in dispatchConfig.phasedRegistrationNames) {
          if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
            continue;
          }
          var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
          if (PluginModule) {
            return PluginModule;
          }
        }
        return null;
      },
      _resetEventPlugins: function() {
        EventPluginOrder = null;
        for (var pluginName in namesToPlugins) {
          if (namesToPlugins.hasOwnProperty(pluginName)) {
            delete namesToPlugins[pluginName];
          }
        }
        EventPluginRegistry.plugins.length = 0;
        var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
        for (var eventName in eventNameDispatchConfigs) {
          if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
            delete eventNameDispatchConfigs[eventName];
          }
        }
        var registrationNameModules = EventPluginRegistry.registrationNameModules;
        for (var registrationName in registrationNameModules) {
          if (registrationNameModules.hasOwnProperty(registrationName)) {
            delete registrationNameModules[registrationName];
          }
        }
      }
    };
    module.exports = EventPluginRegistry;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/accumulateInto", ["./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("./invariant");
    function accumulateInto(current, next) {
      ("production" !== process.env.NODE_ENV ? invariant(next != null, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(next != null));
      if (current == null) {
        return next;
      }
      var currentIsArray = Array.isArray(current);
      var nextIsArray = Array.isArray(next);
      if (currentIsArray && nextIsArray) {
        current.push.apply(current, next);
        return current;
      }
      if (currentIsArray) {
        current.push(next);
        return current;
      }
      if (nextIsArray) {
        return [current].concat(next);
      }
      return [current, next];
    }
    module.exports = accumulateInto;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/forEachAccumulated", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var forEachAccumulated = function(arr, cb, scope) {
    if (Array.isArray(arr)) {
      arr.forEach(cb, scope);
    } else if (arr) {
      cb.call(scope, arr);
    }
  };
  module.exports = forEachAccumulated;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactEventEmitterMixin", ["./EventPluginHub"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventPluginHub = require("./EventPluginHub");
  function runEventQueueInBatch(events) {
    EventPluginHub.enqueueEvents(events);
    EventPluginHub.processEventQueue();
  }
  var ReactEventEmitterMixin = {handleTopLevel: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
      runEventQueueInBatch(events);
    }};
  module.exports = ReactEventEmitterMixin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getUnboundedScrollPosition", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getUnboundedScrollPosition(scrollable) {
    if (scrollable === window) {
      return {
        x: window.pageXOffset || document.documentElement.scrollLeft,
        y: window.pageYOffset || document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }
  module.exports = getUnboundedScrollPosition;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isEventSupported", ["./ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature('', '') !== true;
  }
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
      return false;
    }
    var eventName = 'on' + eventNameSuffix;
    var isSupported = eventName in document;
    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }
    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }
    return isSupported;
  }
  module.exports = isEventSupported;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isNode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function isNode(object) {
    return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }
  module.exports = isNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/deprecated", ["./Object.assign", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var assign = require("./Object.assign");
    var warning = require("./warning");
    function deprecated(namespace, oldName, newName, ctx, fn) {
      var warned = false;
      if ("production" !== process.env.NODE_ENV) {
        var newFn = function() {
          ("production" !== process.env.NODE_ENV ? warning(warned, (namespace + "." + oldName + " will be deprecated in a future version. ") + ("Use " + namespace + "." + newName + " instead.")) : null);
          warned = true;
          return fn.apply(ctx, arguments);
        };
        newFn.displayName = (namespace + "_" + oldName);
        return assign(newFn, fn);
      }
      return fn;
    }
    module.exports = deprecated;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getReactRootElementInContainer", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOC_NODE_TYPE = 9;
  function getReactRootElementInContainer(container) {
    if (!container) {
      return null;
    }
    if (container.nodeType === DOC_NODE_TYPE) {
      return container.documentElement;
    } else {
      return container.firstChild;
    }
  }
  module.exports = getReactRootElementInContainer;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMultiChildUpdateTypes", ["./keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyMirror = require("./keyMirror");
  var ReactMultiChildUpdateTypes = keyMirror({
    INSERT_MARKUP: null,
    MOVE_EXISTING: null,
    REMOVE_NODE: null,
    TEXT_CONTENT: null
  });
  module.exports = ReactMultiChildUpdateTypes;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactTextComponent", ["./DOMPropertyOperations", "./ReactComponent", "./ReactElement", "./Object.assign", "./escapeTextForBrowser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMPropertyOperations = require("./DOMPropertyOperations");
  var ReactComponent = require("./ReactComponent");
  var ReactElement = require("./ReactElement");
  var assign = require("./Object.assign");
  var escapeTextForBrowser = require("./escapeTextForBrowser");
  var ReactTextComponent = function(props) {};
  assign(ReactTextComponent.prototype, ReactComponent.Mixin, {
    mountComponent: function(rootID, transaction, mountDepth) {
      ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
      var escapedText = escapeTextForBrowser(this.props);
      if (transaction.renderToStaticMarkup) {
        return escapedText;
      }
      return ('<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>');
    },
    receiveComponent: function(nextComponent, transaction) {
      var nextProps = nextComponent.props;
      if (nextProps !== this.props) {
        this.props = nextProps;
        ReactComponent.BackendIDOperations.updateTextContentByID(this._rootNodeID, nextProps);
      }
    }
  });
  var ReactTextComponentFactory = function(text) {
    return new ReactElement(ReactTextComponent, null, null, null, null, text);
  };
  ReactTextComponentFactory.type = ReactTextComponent;
  module.exports = ReactTextComponentFactory;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPropagators", ["./EventConstants", "./EventPluginHub", "./accumulateInto", "./forEachAccumulated", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPluginHub = require("./EventPluginHub");
    var accumulateInto = require("./accumulateInto");
    var forEachAccumulated = require("./forEachAccumulated");
    var PropagationPhases = EventConstants.PropagationPhases;
    var getListener = EventPluginHub.getListener;
    function listenerAtPhase(id, event, propagationPhase) {
      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(id, registrationName);
    }
    function accumulateDirectionalDispatches(domID, upwards, event) {
      if ("production" !== process.env.NODE_ENV) {
        if (!domID) {
          throw new Error('Dispatching id must not be null');
        }
      }
      var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
      var listener = listenerAtPhase(domID, event, phase);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
      }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateDispatches(id, ignoredDirection, event) {
      if (event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(id, registrationName);
        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
        }
      }
    }
    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event.dispatchMarker, null, event);
      }
    }
    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }
    function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
      EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
    }
    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
    var EventPropagators = {
      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
      accumulateDirectDispatches: accumulateDirectDispatches,
      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
    };
    module.exports = EventPropagators;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventTarget", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getEventTarget(nativeEvent) {
    var target = nativeEvent.target || nativeEvent.srcElement || window;
    return target.nodeType === 3 ? target.parentNode : target;
  }
  module.exports = getEventTarget;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isTextInputElement", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var supportedInputTypes = {
    'color': true,
    'date': true,
    'datetime': true,
    'datetime-local': true,
    'email': true,
    'month': true,
    'number': true,
    'password': true,
    'range': true,
    'search': true,
    'tel': true,
    'text': true,
    'time': true,
    'url': true,
    'week': true
  };
  function isTextInputElement(elem) {
    return elem && ((elem.nodeName === 'INPUT' && supportedInputTypes[elem.type]) || elem.nodeName === 'TEXTAREA');
  }
  module.exports = isTextInputElement;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ClientReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var nextReactRootIndex = 0;
  var ClientReactRootIndex = {createReactRootIndex: function() {
      return nextReactRootIndex++;
    }};
  module.exports = ClientReactRootIndex;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getNodeForCharacterOffset", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getLeafNode(node) {
    while (node && node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }
  function getSiblingNode(node) {
    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    }
  }
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;
    while (node) {
      if (node.nodeType == 3) {
        nodeEnd = nodeStart + node.textContent.length;
        if (nodeStart <= offset && nodeEnd >= offset) {
          return {
            node: node,
            offset: offset - nodeStart
          };
        }
        nodeStart = nodeEnd;
      }
      node = getLeafNode(getSiblingNode(node));
    }
  }
  module.exports = getNodeForCharacterOffset;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getTextContentAccessor", ["./ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  var contentKey = null;
  function getTextContentAccessor() {
    if (!contentKey && ExecutionEnvironment.canUseDOM) {
      contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
    }
    return contentKey;
  }
  module.exports = getTextContentAccessor;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/focusNode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function focusNode(node) {
    try {
      node.focus();
    } catch (e) {}
  }
  module.exports = focusNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getActiveElement", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function getActiveElement() {
    try {
      return document.activeElement || document.body;
    } catch (e) {
      return document.body;
    }
  }
  module.exports = getActiveElement;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticCompositionEvent", ["./SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("./SyntheticEvent");
  var CompositionEventInterface = {data: null};
  function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
  module.exports = SyntheticCompositionEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/DefaultEventPluginOrder", ["./keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyOf = require("./keyOf");
  var DefaultEventPluginOrder = [keyOf({ResponderEventPlugin: null}), keyOf({SimpleEventPlugin: null}), keyOf({TapEventPlugin: null}), keyOf({EnterLeaveEventPlugin: null}), keyOf({ChangeEventPlugin: null}), keyOf({SelectEventPlugin: null}), keyOf({CompositionEventPlugin: null}), keyOf({BeforeInputEventPlugin: null}), keyOf({AnalyticsEventPlugin: null}), keyOf({MobileSafariClickEventPlugin: null})];
  module.exports = DefaultEventPluginOrder;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticUIEvent", ["./SyntheticEvent", "./getEventTarget"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("./SyntheticEvent");
  var getEventTarget = require("./getEventTarget");
  var UIEventInterface = {
    view: function(event) {
      if (event.view) {
        return event.view;
      }
      var target = getEventTarget(event);
      if (target != null && target.window === target) {
        return target;
      }
      var doc = target.ownerDocument;
      if (doc) {
        return doc.defaultView || doc.parentWindow;
      } else {
        return window;
      }
    },
    detail: function(event) {
      return event.detail || 0;
    }
  };
  function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
  module.exports = SyntheticUIEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventModifierState", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var modifierKeyToProp = {
    'Alt': 'altKey',
    'Control': 'ctrlKey',
    'Meta': 'metaKey',
    'Shift': 'shiftKey'
  };
  function modifierStateGetter(keyArg) {
    var syntheticEvent = this;
    var nativeEvent = syntheticEvent.nativeEvent;
    if (nativeEvent.getModifierState) {
      return nativeEvent.getModifierState(keyArg);
    }
    var keyProp = modifierKeyToProp[keyArg];
    return keyProp ? !!nativeEvent[keyProp] : false;
  }
  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }
  module.exports = getEventModifierState;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/HTMLDOMPropertyConfig", ["./DOMProperty", "./ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("./DOMProperty");
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
  var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
  var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
  var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
  var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
  var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
  var hasSVG;
  if (ExecutionEnvironment.canUseDOM) {
    var implementation = document.implementation;
    hasSVG = (implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1'));
  }
  var HTMLDOMPropertyConfig = {
    isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
    Properties: {
      accept: null,
      acceptCharset: null,
      accessKey: null,
      action: null,
      allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      allowTransparency: MUST_USE_ATTRIBUTE,
      alt: null,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: null,
      autoPlay: HAS_BOOLEAN_VALUE,
      cellPadding: null,
      cellSpacing: null,
      charSet: MUST_USE_ATTRIBUTE,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      classID: MUST_USE_ATTRIBUTE,
      className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
      cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: null,
      content: null,
      contentEditable: null,
      contextMenu: MUST_USE_ATTRIBUTE,
      controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      coords: null,
      crossOrigin: null,
      data: null,
      dateTime: MUST_USE_ATTRIBUTE,
      defer: HAS_BOOLEAN_VALUE,
      dir: null,
      disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: null,
      encType: null,
      form: MUST_USE_ATTRIBUTE,
      formAction: MUST_USE_ATTRIBUTE,
      formEncType: MUST_USE_ATTRIBUTE,
      formMethod: MUST_USE_ATTRIBUTE,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: MUST_USE_ATTRIBUTE,
      frameBorder: MUST_USE_ATTRIBUTE,
      height: MUST_USE_ATTRIBUTE,
      hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      href: null,
      hrefLang: null,
      htmlFor: null,
      httpEquiv: null,
      icon: null,
      id: MUST_USE_PROPERTY,
      label: null,
      lang: null,
      list: MUST_USE_ATTRIBUTE,
      loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      manifest: MUST_USE_ATTRIBUTE,
      marginHeight: null,
      marginWidth: null,
      max: null,
      maxLength: MUST_USE_ATTRIBUTE,
      media: MUST_USE_ATTRIBUTE,
      mediaGroup: null,
      method: null,
      min: null,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: null,
      noValidate: HAS_BOOLEAN_VALUE,
      open: null,
      pattern: null,
      placeholder: null,
      poster: null,
      preload: null,
      radioGroup: null,
      readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      rel: null,
      required: HAS_BOOLEAN_VALUE,
      role: MUST_USE_ATTRIBUTE,
      rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: null,
      sandbox: null,
      scope: null,
      scrolling: null,
      seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: null,
      size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      sizes: MUST_USE_ATTRIBUTE,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: null,
      src: null,
      srcDoc: MUST_USE_PROPERTY,
      srcSet: MUST_USE_ATTRIBUTE,
      start: HAS_NUMERIC_VALUE,
      step: null,
      style: null,
      tabIndex: null,
      target: null,
      title: null,
      type: null,
      useMap: null,
      value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
      width: MUST_USE_ATTRIBUTE,
      wmode: MUST_USE_ATTRIBUTE,
      autoCapitalize: null,
      autoCorrect: null,
      itemProp: MUST_USE_ATTRIBUTE,
      itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      itemType: MUST_USE_ATTRIBUTE,
      property: null
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
    },
    DOMPropertyNames: {
      autoCapitalize: 'autocapitalize',
      autoComplete: 'autocomplete',
      autoCorrect: 'autocorrect',
      autoFocus: 'autofocus',
      autoPlay: 'autoplay',
      encType: 'enctype',
      hrefLang: 'hreflang',
      radioGroup: 'radiogroup',
      spellCheck: 'spellcheck',
      srcDoc: 'srcdoc',
      srcSet: 'srcset'
    }
  };
  module.exports = HTMLDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/MobileSafariClickEventPlugin", ["./EventConstants", "./emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("./EventConstants");
  var emptyFunction = require("./emptyFunction");
  var topLevelTypes = EventConstants.topLevelTypes;
  var MobileSafariClickEventPlugin = {
    eventTypes: null,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      if (topLevelType === topLevelTypes.topTouchStart) {
        var target = nativeEvent.target;
        if (target && !target.onclick) {
          target.onclick = emptyFunction;
        }
      }
    }
  };
  module.exports = MobileSafariClickEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/toArray", ["./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var invariant = require("./invariant");
    function toArray(obj) {
      var length = obj.length;
      ("production" !== process.env.NODE_ENV ? invariant(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function'), 'toArray: Array-like object expected') : invariant(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')));
      ("production" !== process.env.NODE_ENV ? invariant(typeof length === 'number', 'toArray: Object needs a length property') : invariant(typeof length === 'number'));
      ("production" !== process.env.NODE_ENV ? invariant(length === 0 || (length - 1) in obj, 'toArray: Object should have keys for indices') : invariant(length === 0 || (length - 1) in obj));
      if (obj.hasOwnProperty) {
        try {
          return Array.prototype.slice.call(obj);
        } catch (e) {}
      }
      var ret = Array(length);
      for (var ii = 0; ii < length; ii++) {
        ret[ii] = obj[ii];
      }
      return ret;
    }
    module.exports = toArray;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getMarkupWrap", ["./ExecutionEnvironment", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var invariant = require("./invariant");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var shouldWrap = {
      'circle': true,
      'defs': true,
      'ellipse': true,
      'g': true,
      'line': true,
      'linearGradient': true,
      'path': true,
      'polygon': true,
      'polyline': true,
      'radialGradient': true,
      'rect': true,
      'stop': true,
      'text': true
    };
    var selectWrap = [1, '<select multiple="true">', '</select>'];
    var tableWrap = [1, '<table>', '</table>'];
    var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
    var svgWrap = [1, '<svg>', '</svg>'];
    var markupWrap = {
      '*': [1, '?<div>', '</div>'],
      'area': [1, '<map>', '</map>'],
      'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      'legend': [1, '<fieldset>', '</fieldset>'],
      'param': [1, '<object>', '</object>'],
      'tr': [2, '<table><tbody>', '</tbody></table>'],
      'optgroup': selectWrap,
      'option': selectWrap,
      'caption': tableWrap,
      'colgroup': tableWrap,
      'tbody': tableWrap,
      'tfoot': tableWrap,
      'thead': tableWrap,
      'td': trWrap,
      'th': trWrap,
      'circle': svgWrap,
      'defs': svgWrap,
      'ellipse': svgWrap,
      'g': svgWrap,
      'line': svgWrap,
      'linearGradient': svgWrap,
      'path': svgWrap,
      'polygon': svgWrap,
      'polyline': svgWrap,
      'radialGradient': svgWrap,
      'rect': svgWrap,
      'stop': svgWrap,
      'text': svgWrap
    };
    function getMarkupWrap(nodeName) {
      ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'Markup wrapping node not initialized') : invariant(!!dummyNode));
      if (!markupWrap.hasOwnProperty(nodeName)) {
        nodeName = '*';
      }
      if (!shouldWrap.hasOwnProperty(nodeName)) {
        if (nodeName === '*') {
          dummyNode.innerHTML = '<link />';
        } else {
          dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
        }
        shouldWrap[nodeName] = !dummyNode.firstChild;
      }
      return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
    }
    module.exports = getMarkupWrap;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/setInnerHTML", ["./ExecutionEnvironment", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var WHITESPACE_TEST = /^[ \r\n\t\f]/;
    var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
    var setInnerHTML = function(node, html) {
      node.innerHTML = html;
    };
    if (ExecutionEnvironment.canUseDOM) {
      var testElement = document.createElement('div');
      testElement.innerHTML = ' ';
      if (testElement.innerHTML === '') {
        setInnerHTML = function(node, html) {
          if (node.parentNode) {
            node.parentNode.replaceChild(node, node);
          }
          if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
            node.innerHTML = '\uFEFF' + html;
            var textNode = node.firstChild;
            if (textNode.data.length === 1) {
              node.removeChild(textNode);
            } else {
              textNode.deleteData(0, 1);
            }
          } else {
            node.innerHTML = html;
          }
        };
      }
    }
    module.exports = setInnerHTML;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/adler32", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var MOD = 65521;
  function adler32(data) {
    var a = 1;
    var b = 0;
    for (var i = 0; i < data.length; i++) {
      a = (a + data.charCodeAt(i)) % MOD;
      b = (b + a) % MOD;
    }
    return a | (b << 16);
  }
  module.exports = adler32;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPutListenerQueue", ["./PooledClass", "./ReactBrowserEventEmitter", "./Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var PooledClass = require("./PooledClass");
  var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
  var assign = require("./Object.assign");
  function ReactPutListenerQueue() {
    this.listenersToPut = [];
  }
  assign(ReactPutListenerQueue.prototype, {
    enqueuePutListener: function(rootNodeID, propKey, propValue) {
      this.listenersToPut.push({
        rootNodeID: rootNodeID,
        propKey: propKey,
        propValue: propValue
      });
    },
    putListeners: function() {
      for (var i = 0; i < this.listenersToPut.length; i++) {
        var listenerToPut = this.listenersToPut[i];
        ReactBrowserEventEmitter.putListener(listenerToPut.rootNodeID, listenerToPut.propKey, listenerToPut.propValue);
      }
    },
    reset: function() {
      this.listenersToPut.length = 0;
    },
    destructor: function() {
      this.reset();
    }
  });
  PooledClass.addPoolingTo(ReactPutListenerQueue);
  module.exports = ReactPutListenerQueue;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultBatchingStrategy", ["./ReactUpdates", "./Transaction", "./Object.assign", "./emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactUpdates = require("./ReactUpdates");
  var Transaction = require("./Transaction");
  var assign = require("./Object.assign");
  var emptyFunction = require("./emptyFunction");
  var RESET_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: function() {
      ReactDefaultBatchingStrategy.isBatchingUpdates = false;
    }
  };
  var FLUSH_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
  };
  var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
  function ReactDefaultBatchingStrategyTransaction() {
    this.reinitializeTransaction();
  }
  assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    }});
  var transaction = new ReactDefaultBatchingStrategyTransaction();
  var ReactDefaultBatchingStrategy = {
    isBatchingUpdates: false,
    batchedUpdates: function(callback, a, b) {
      var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
      ReactDefaultBatchingStrategy.isBatchingUpdates = true;
      if (alreadyBatchingUpdates) {
        callback(a, b);
      } else {
        transaction.perform(callback, null, a, b);
      }
    }
  };
  module.exports = ReactDefaultBatchingStrategy;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/AutoFocusMixin", ["./focusNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var focusNode = require("./focusNode");
  var AutoFocusMixin = {componentDidMount: function() {
      if (this.props.autoFocus) {
        focusNode(this.getDOMNode());
      }
    }};
  module.exports = AutoFocusMixin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/LocalEventTrapMixin", ["./ReactBrowserEventEmitter", "./accumulateInto", "./forEachAccumulated", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
    var accumulateInto = require("./accumulateInto");
    var forEachAccumulated = require("./forEachAccumulated");
    var invariant = require("./invariant");
    function remove(event) {
      event.remove();
    }
    var LocalEventTrapMixin = {
      trapBubbledEvent: function(topLevelType, handlerBaseName) {
        ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'Must be mounted to trap events') : invariant(this.isMounted()));
        var listener = ReactBrowserEventEmitter.trapBubbledEvent(topLevelType, handlerBaseName, this.getDOMNode());
        this._localEventListeners = accumulateInto(this._localEventListeners, listener);
      },
      componentWillUnmount: function() {
        if (this._localEventListeners) {
          forEachAccumulated(this._localEventListeners, remove);
        }
      }
    };
    module.exports = LocalEventTrapMixin;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMImg", ["./EventConstants", "./LocalEventTrapMixin", "./ReactBrowserComponentMixin", "./ReactCompositeComponent", "./ReactElement", "./ReactDOM"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("./EventConstants");
  var LocalEventTrapMixin = require("./LocalEventTrapMixin");
  var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("./ReactCompositeComponent");
  var ReactElement = require("./ReactElement");
  var ReactDOM = require("./ReactDOM");
  var img = ReactElement.createFactory(ReactDOM.img.type);
  var ReactDOMImg = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMImg',
    tagName: 'IMG',
    mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
    render: function() {
      return img(this.props);
    },
    componentDidMount: function() {
      this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
      this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');
    }
  });
  module.exports = ReactDOMImg;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTypes", ["./ReactElement", "./ReactPropTypeLocationNames", "./deprecated", "./emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactElement = require("./ReactElement");
  var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
  var deprecated = require("./deprecated");
  var emptyFunction = require("./emptyFunction");
  var ANONYMOUS = '<<anonymous>>';
  var elementTypeChecker = createElementTypeChecker();
  var nodeTypeChecker = createNodeChecker();
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: elementTypeChecker,
    instanceOf: createInstanceTypeChecker,
    node: nodeTypeChecker,
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    component: deprecated('React.PropTypes', 'component', 'element', this, elementTypeChecker),
    renderable: deprecated('React.PropTypes', 'renderable', 'node', this, nodeTypeChecker)
  };
  function createChainableTypeChecker(validate) {
    function checkType(isRequired, props, propName, componentName, location) {
      componentName = componentName || ANONYMOUS;
      if (props[propName] == null) {
        var locationName = ReactPropTypeLocationNames[location];
        if (isRequired) {
          return new Error(("Required " + locationName + " `" + propName + "` was not specified in ") + ("`" + componentName + "`."));
        }
      } else {
        return validate(props, propName, componentName, location);
      }
    }
    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }
  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        var locationName = ReactPropTypeLocationNames[location];
        var preciseType = getPreciseType(propValue);
        return new Error(("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` ") + ("supplied to `" + componentName + "`, expected `" + expectedType + "`."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturns());
  }
  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var locationName = ReactPropTypeLocationNames[location];
        var propType = getPropType(propValue);
        return new Error(("Invalid " + locationName + " `" + propName + "` of type ") + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createElementTypeChecker() {
    function validate(props, propName, componentName, location) {
      if (!ReactElement.isValidElement(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected a ReactElement."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location) {
      if (!(props[propName] instanceof expectedClass)) {
        var locationName = ReactPropTypeLocationNames[location];
        var expectedClassName = expectedClass.name || ANONYMOUS;
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected instance of `" + expectedClassName + "`."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createEnumTypeChecker(expectedValues) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (propValue === expectedValues[i]) {
          return;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      var valuesString = JSON.stringify(expectedValues);
      return new Error(("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` ") + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
    }
    return createChainableTypeChecker(validate);
  }
  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` of type ") + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location);
          if (error instanceof Error) {
            return error;
          }
        }
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createUnionTypeChecker(arrayOfTypeCheckers) {
    function validate(props, propName, componentName, location) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location) == null) {
          return;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`."));
    }
    return createChainableTypeChecker(validate);
  }
  function createNodeChecker() {
    function validate(props, propName, componentName, location) {
      if (!isNode(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected a ReactNode."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` ") + ("supplied to `" + componentName + "`, expected `object`."));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location);
        if (error) {
          return error;
        }
      }
    }
    return createChainableTypeChecker(validate, 'expected `object`');
  }
  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (ReactElement.isValidElement(propValue)) {
          return true;
        }
        for (var k in propValue) {
          if (!isNode(propValue[k])) {
            return false;
          }
        }
        return true;
      default:
        return false;
    }
  }
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      return 'object';
    }
    return propType;
  }
  function getPreciseType(propValue) {
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }
  module.exports = ReactPropTypes;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMOption", ["./ReactBrowserComponentMixin", "./ReactCompositeComponent", "./ReactElement", "./ReactDOM", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var ReactDOM = require("./ReactDOM");
    var warning = require("./warning");
    var option = ReactElement.createFactory(ReactDOM.option.type);
    var ReactDOMOption = ReactCompositeComponent.createClass({
      displayName: 'ReactDOMOption',
      mixins: [ReactBrowserComponentMixin],
      componentWillMount: function() {
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(this.props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : null);
        }
      },
      render: function() {
        return option(this.props, this.props.children);
      }
    });
    module.exports = ReactDOMOption;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMSelect", ["./AutoFocusMixin", "./LinkedValueUtils", "./ReactBrowserComponentMixin", "./ReactCompositeComponent", "./ReactElement", "./ReactDOM", "./ReactUpdates", "./Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var AutoFocusMixin = require("./AutoFocusMixin");
  var LinkedValueUtils = require("./LinkedValueUtils");
  var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("./ReactCompositeComponent");
  var ReactElement = require("./ReactElement");
  var ReactDOM = require("./ReactDOM");
  var ReactUpdates = require("./ReactUpdates");
  var assign = require("./Object.assign");
  var select = ReactElement.createFactory(ReactDOM.select.type);
  function updateWithPendingValueIfMounted() {
    if (this.isMounted()) {
      this.setState({value: this._pendingValue});
      this._pendingValue = 0;
    }
  }
  function selectValueType(props, propName, componentName) {
    if (props[propName] == null) {
      return;
    }
    if (props.multiple) {
      if (!Array.isArray(props[propName])) {
        return new Error(("The `" + propName + "` prop supplied to <select> must be an array if ") + ("`multiple` is true."));
      }
    } else {
      if (Array.isArray(props[propName])) {
        return new Error(("The `" + propName + "` prop supplied to <select> must be a scalar ") + ("value if `multiple` is false."));
      }
    }
  }
  function updateOptions(component, propValue) {
    var multiple = component.props.multiple;
    var value = propValue != null ? propValue : component.state.value;
    var options = component.getDOMNode().options;
    var selectedValue,
        i,
        l;
    if (multiple) {
      selectedValue = {};
      for (i = 0, l = value.length; i < l; ++i) {
        selectedValue['' + value[i]] = true;
      }
    } else {
      selectedValue = '' + value;
    }
    for (i = 0, l = options.length; i < l; i++) {
      var selected = multiple ? selectedValue.hasOwnProperty(options[i].value) : options[i].value === selectedValue;
      if (selected !== options[i].selected) {
        options[i].selected = selected;
      }
    }
  }
  var ReactDOMSelect = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMSelect',
    mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
    propTypes: {
      defaultValue: selectValueType,
      value: selectValueType
    },
    getInitialState: function() {
      return {value: this.props.defaultValue || (this.props.multiple ? [] : '')};
    },
    componentWillMount: function() {
      this._pendingValue = null;
    },
    componentWillReceiveProps: function(nextProps) {
      if (!this.props.multiple && nextProps.multiple) {
        this.setState({value: [this.state.value]});
      } else if (this.props.multiple && !nextProps.multiple) {
        this.setState({value: this.state.value[0]});
      }
    },
    render: function() {
      var props = assign({}, this.props);
      props.onChange = this._handleChange;
      props.value = null;
      return select(props, this.props.children);
    },
    componentDidMount: function() {
      updateOptions(this, LinkedValueUtils.getValue(this));
    },
    componentDidUpdate: function(prevProps) {
      var value = LinkedValueUtils.getValue(this);
      var prevMultiple = !!prevProps.multiple;
      var multiple = !!this.props.multiple;
      if (value != null || prevMultiple !== multiple) {
        updateOptions(this, value);
      }
    },
    _handleChange: function(event) {
      var returnValue;
      var onChange = LinkedValueUtils.getOnChange(this);
      if (onChange) {
        returnValue = onChange.call(this, event);
      }
      var selectedValue;
      if (this.props.multiple) {
        selectedValue = [];
        var options = event.target.options;
        for (var i = 0,
            l = options.length; i < l; i++) {
          if (options[i].selected) {
            selectedValue.push(options[i].value);
          }
        }
      } else {
        selectedValue = event.target.value;
      }
      this._pendingValue = selectedValue;
      ReactUpdates.asap(updateWithPendingValueIfMounted, this);
      return returnValue;
    }
  });
  module.exports = ReactDOMSelect;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMTextarea", ["./AutoFocusMixin", "./DOMPropertyOperations", "./LinkedValueUtils", "./ReactBrowserComponentMixin", "./ReactCompositeComponent", "./ReactElement", "./ReactDOM", "./ReactUpdates", "./Object.assign", "./invariant", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var AutoFocusMixin = require("./AutoFocusMixin");
    var DOMPropertyOperations = require("./DOMPropertyOperations");
    var LinkedValueUtils = require("./LinkedValueUtils");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var ReactDOM = require("./ReactDOM");
    var ReactUpdates = require("./ReactUpdates");
    var assign = require("./Object.assign");
    var invariant = require("./invariant");
    var warning = require("./warning");
    var textarea = ReactElement.createFactory(ReactDOM.textarea.type);
    function forceUpdateIfMounted() {
      if (this.isMounted()) {
        this.forceUpdate();
      }
    }
    var ReactDOMTextarea = ReactCompositeComponent.createClass({
      displayName: 'ReactDOMTextarea',
      mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
      getInitialState: function() {
        var defaultValue = this.props.defaultValue;
        var children = this.props.children;
        if (children != null) {
          if ("production" !== process.env.NODE_ENV) {
            ("production" !== process.env.NODE_ENV ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : null);
          }
          ("production" !== process.env.NODE_ENV ? invariant(defaultValue == null, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(defaultValue == null));
          if (Array.isArray(children)) {
            ("production" !== process.env.NODE_ENV ? invariant(children.length <= 1, '<textarea> can only have at most one child.') : invariant(children.length <= 1));
            children = children[0];
          }
          defaultValue = '' + children;
        }
        if (defaultValue == null) {
          defaultValue = '';
        }
        var value = LinkedValueUtils.getValue(this);
        return {initialValue: '' + (value != null ? value : defaultValue)};
      },
      render: function() {
        var props = assign({}, this.props);
        ("production" !== process.env.NODE_ENV ? invariant(props.dangerouslySetInnerHTML == null, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(props.dangerouslySetInnerHTML == null));
        props.defaultValue = null;
        props.value = null;
        props.onChange = this._handleChange;
        return textarea(props, this.state.initialValue);
      },
      componentDidUpdate: function(prevProps, prevState, prevContext) {
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
          var rootNode = this.getDOMNode();
          DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
        }
      },
      _handleChange: function(event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
          returnValue = onChange.call(this, event);
        }
        ReactUpdates.asap(forceUpdateIfMounted, this);
        return returnValue;
      }
    });
    module.exports = ReactDOMTextarea;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventListener", ["./emptyFunction", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var emptyFunction = require("./emptyFunction");
    var EventListener = {
      listen: function(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, false);
          return {remove: function() {
              target.removeEventListener(eventType, callback, false);
            }};
        } else if (target.attachEvent) {
          target.attachEvent('on' + eventType, callback);
          return {remove: function() {
              target.detachEvent('on' + eventType, callback);
            }};
        }
      },
      capture: function(target, eventType, callback) {
        if (!target.addEventListener) {
          if ("production" !== process.env.NODE_ENV) {
            console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
          }
          return {remove: emptyFunction};
        } else {
          target.addEventListener(eventType, callback, true);
          return {remove: function() {
              target.removeEventListener(eventType, callback, true);
            }};
        }
      },
      registerDefault: function() {}
    };
    module.exports = EventListener;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactInjection", ["./DOMProperty", "./EventPluginHub", "./ReactComponent", "./ReactCompositeComponent", "./ReactEmptyComponent", "./ReactBrowserEventEmitter", "./ReactNativeComponent", "./ReactPerf", "./ReactRootIndex", "./ReactUpdates"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("./DOMProperty");
  var EventPluginHub = require("./EventPluginHub");
  var ReactComponent = require("./ReactComponent");
  var ReactCompositeComponent = require("./ReactCompositeComponent");
  var ReactEmptyComponent = require("./ReactEmptyComponent");
  var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
  var ReactNativeComponent = require("./ReactNativeComponent");
  var ReactPerf = require("./ReactPerf");
  var ReactRootIndex = require("./ReactRootIndex");
  var ReactUpdates = require("./ReactUpdates");
  var ReactInjection = {
    Component: ReactComponent.injection,
    CompositeComponent: ReactCompositeComponent.injection,
    DOMProperty: DOMProperty.injection,
    EmptyComponent: ReactEmptyComponent.injection,
    EventPluginHub: EventPluginHub.injection,
    EventEmitter: ReactBrowserEventEmitter.injection,
    NativeComponent: ReactNativeComponent.injection,
    Perf: ReactPerf.injection,
    RootIndex: ReactRootIndex.injection,
    Updates: ReactUpdates.injection
  };
  module.exports = ReactInjection;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/shallowEqual", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function shallowEqual(objA, objB) {
    if (objA === objB) {
      return true;
    }
    var key;
    for (key in objA) {
      if (objA.hasOwnProperty(key) && (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
        return false;
      }
    }
    for (key in objB) {
      if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
        return false;
      }
    }
    return true;
  }
  module.exports = shallowEqual;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ServerReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
  var ServerReactRootIndex = {createReactRootIndex: function() {
      return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
    }};
  module.exports = ServerReactRootIndex;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticClipboardEvent", ["./SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("./SyntheticEvent");
  var ClipboardEventInterface = {clipboardData: function(event) {
      return ('clipboardData' in event ? event.clipboardData : window.clipboardData);
    }};
  function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
  module.exports = SyntheticClipboardEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticFocusEvent", ["./SyntheticUIEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("./SyntheticUIEvent");
  var FocusEventInterface = {relatedTarget: null};
  function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
  module.exports = SyntheticFocusEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventCharCode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getEventCharCode(nativeEvent) {
    var charCode;
    var keyCode = nativeEvent.keyCode;
    if ('charCode' in nativeEvent) {
      charCode = nativeEvent.charCode;
      if (charCode === 0 && keyCode === 13) {
        charCode = 13;
      }
    } else {
      charCode = keyCode;
    }
    if (charCode >= 32 || charCode === 13) {
      return charCode;
    }
    return 0;
  }
  module.exports = getEventCharCode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventKey", ["./getEventCharCode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var getEventCharCode = require("./getEventCharCode");
  var normalizeKey = {
    'Esc': 'Escape',
    'Spacebar': ' ',
    'Left': 'ArrowLeft',
    'Up': 'ArrowUp',
    'Right': 'ArrowRight',
    'Down': 'ArrowDown',
    'Del': 'Delete',
    'Win': 'OS',
    'Menu': 'ContextMenu',
    'Apps': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'MozPrintableKey': 'Unidentified'
  };
  var translateToKey = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta'
  };
  function getEventKey(nativeEvent) {
    if (nativeEvent.key) {
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if (key !== 'Unidentified') {
        return key;
      }
    }
    if (nativeEvent.type === 'keypress') {
      var charCode = getEventCharCode(nativeEvent);
      return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
    }
    if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
      return translateToKey[nativeEvent.keyCode] || 'Unidentified';
    }
    return '';
  }
  module.exports = getEventKey;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticDragEvent", ["./SyntheticMouseEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticMouseEvent = require("./SyntheticMouseEvent");
  var DragEventInterface = {dataTransfer: null};
  function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
  module.exports = SyntheticDragEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticTouchEvent", ["./SyntheticUIEvent", "./getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("./SyntheticUIEvent");
  var getEventModifierState = require("./getEventModifierState");
  var TouchEventInterface = {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  };
  function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
  module.exports = SyntheticTouchEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticWheelEvent", ["./SyntheticMouseEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticMouseEvent = require("./SyntheticMouseEvent");
  var WheelEventInterface = {
    deltaX: function(event) {
      return ('deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0);
    },
    deltaY: function(event) {
      return ('deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0);
    },
    deltaZ: null,
    deltaMode: null
  };
  function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
  module.exports = SyntheticWheelEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SVGDOMPropertyConfig", ["./DOMProperty"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("./DOMProperty");
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var SVGDOMPropertyConfig = {
    Properties: {
      cx: MUST_USE_ATTRIBUTE,
      cy: MUST_USE_ATTRIBUTE,
      d: MUST_USE_ATTRIBUTE,
      dx: MUST_USE_ATTRIBUTE,
      dy: MUST_USE_ATTRIBUTE,
      fill: MUST_USE_ATTRIBUTE,
      fillOpacity: MUST_USE_ATTRIBUTE,
      fontFamily: MUST_USE_ATTRIBUTE,
      fontSize: MUST_USE_ATTRIBUTE,
      fx: MUST_USE_ATTRIBUTE,
      fy: MUST_USE_ATTRIBUTE,
      gradientTransform: MUST_USE_ATTRIBUTE,
      gradientUnits: MUST_USE_ATTRIBUTE,
      markerEnd: MUST_USE_ATTRIBUTE,
      markerMid: MUST_USE_ATTRIBUTE,
      markerStart: MUST_USE_ATTRIBUTE,
      offset: MUST_USE_ATTRIBUTE,
      opacity: MUST_USE_ATTRIBUTE,
      patternContentUnits: MUST_USE_ATTRIBUTE,
      patternUnits: MUST_USE_ATTRIBUTE,
      points: MUST_USE_ATTRIBUTE,
      preserveAspectRatio: MUST_USE_ATTRIBUTE,
      r: MUST_USE_ATTRIBUTE,
      rx: MUST_USE_ATTRIBUTE,
      ry: MUST_USE_ATTRIBUTE,
      spreadMethod: MUST_USE_ATTRIBUTE,
      stopColor: MUST_USE_ATTRIBUTE,
      stopOpacity: MUST_USE_ATTRIBUTE,
      stroke: MUST_USE_ATTRIBUTE,
      strokeDasharray: MUST_USE_ATTRIBUTE,
      strokeLinecap: MUST_USE_ATTRIBUTE,
      strokeOpacity: MUST_USE_ATTRIBUTE,
      strokeWidth: MUST_USE_ATTRIBUTE,
      textAnchor: MUST_USE_ATTRIBUTE,
      transform: MUST_USE_ATTRIBUTE,
      version: MUST_USE_ATTRIBUTE,
      viewBox: MUST_USE_ATTRIBUTE,
      x1: MUST_USE_ATTRIBUTE,
      x2: MUST_USE_ATTRIBUTE,
      x: MUST_USE_ATTRIBUTE,
      y1: MUST_USE_ATTRIBUTE,
      y2: MUST_USE_ATTRIBUTE,
      y: MUST_USE_ATTRIBUTE
    },
    DOMAttributeNames: {
      fillOpacity: 'fill-opacity',
      fontFamily: 'font-family',
      fontSize: 'font-size',
      gradientTransform: 'gradientTransform',
      gradientUnits: 'gradientUnits',
      markerEnd: 'marker-end',
      markerMid: 'marker-mid',
      markerStart: 'marker-start',
      patternContentUnits: 'patternContentUnits',
      patternUnits: 'patternUnits',
      preserveAspectRatio: 'preserveAspectRatio',
      spreadMethod: 'spreadMethod',
      stopColor: 'stop-color',
      stopOpacity: 'stop-opacity',
      strokeDasharray: 'stroke-dasharray',
      strokeLinecap: 'stroke-linecap',
      strokeOpacity: 'stroke-opacity',
      strokeWidth: 'stroke-width',
      textAnchor: 'text-anchor',
      viewBox: 'viewBox'
    }
  };
  module.exports = SVGDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/createFullPageComponent", ["./ReactCompositeComponent", "./ReactElement", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var invariant = require("./invariant");
    function createFullPageComponent(tag) {
      var elementFactory = ReactElement.createFactory(tag);
      var FullPageComponent = ReactCompositeComponent.createClass({
        displayName: 'ReactFullPageComponent' + tag,
        componentWillUnmount: function() {
          ("production" !== process.env.NODE_ENV ? invariant(false, '%s tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, <head>, ' + 'and <body>) reliably and efficiently. To fix this, have a single ' + 'top-level component that never unmounts render these elements.', this.constructor.displayName) : invariant(false));
        },
        render: function() {
          return elementFactory(this.props);
        }
      });
      return FullPageComponent;
    }
    module.exports = createFullPageComponent;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultPerfAnalysis", ["./Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var assign = require("./Object.assign");
  var DONT_CARE_THRESHOLD = 1.2;
  var DOM_OPERATION_TYPES = {
    'mountImageIntoNode': 'set innerHTML',
    INSERT_MARKUP: 'set innerHTML',
    MOVE_EXISTING: 'move',
    REMOVE_NODE: 'remove',
    TEXT_CONTENT: 'set textContent',
    'updatePropertyByID': 'update attribute',
    'deletePropertyByID': 'delete attribute',
    'updateStylesByID': 'update styles',
    'updateInnerHTMLByID': 'set innerHTML',
    'dangerouslyReplaceNodeWithMarkupByID': 'replace'
  };
  function getTotalTime(measurements) {
    var totalTime = 0;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      totalTime += measurement.totalTime;
    }
    return totalTime;
  }
  function getDOMSummary(measurements) {
    var items = [];
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var id;
      for (id in measurement.writes) {
        measurement.writes[id].forEach(function(write) {
          items.push({
            id: id,
            type: DOM_OPERATION_TYPES[write.type] || write.type,
            args: write.args
          });
        });
      }
    }
    return items;
  }
  function getExclusiveSummary(measurements) {
    var candidates = {};
    var displayName;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      for (var id in allIDs) {
        displayName = measurement.displayNames[id].current;
        candidates[displayName] = candidates[displayName] || {
          componentName: displayName,
          inclusive: 0,
          exclusive: 0,
          render: 0,
          count: 0
        };
        if (measurement.render[id]) {
          candidates[displayName].render += measurement.render[id];
        }
        if (measurement.exclusive[id]) {
          candidates[displayName].exclusive += measurement.exclusive[id];
        }
        if (measurement.inclusive[id]) {
          candidates[displayName].inclusive += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[displayName].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (displayName in candidates) {
      if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[displayName]);
      }
    }
    arr.sort(function(a, b) {
      return b.exclusive - a.exclusive;
    });
    return arr;
  }
  function getInclusiveSummary(measurements, onlyClean) {
    var candidates = {};
    var inclusiveKey;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      var cleanComponents;
      if (onlyClean) {
        cleanComponents = getUnchangedComponents(measurement);
      }
      for (var id in allIDs) {
        if (onlyClean && !cleanComponents[id]) {
          continue;
        }
        var displayName = measurement.displayNames[id];
        inclusiveKey = displayName.owner + ' > ' + displayName.current;
        candidates[inclusiveKey] = candidates[inclusiveKey] || {
          componentName: inclusiveKey,
          time: 0,
          count: 0
        };
        if (measurement.inclusive[id]) {
          candidates[inclusiveKey].time += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[inclusiveKey].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (inclusiveKey in candidates) {
      if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[inclusiveKey]);
      }
    }
    arr.sort(function(a, b) {
      return b.time - a.time;
    });
    return arr;
  }
  function getUnchangedComponents(measurement) {
    var cleanComponents = {};
    var dirtyLeafIDs = Object.keys(measurement.writes);
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    for (var id in allIDs) {
      var isDirty = false;
      for (var i = 0; i < dirtyLeafIDs.length; i++) {
        if (dirtyLeafIDs[i].indexOf(id) === 0) {
          isDirty = true;
          break;
        }
      }
      if (!isDirty && measurement.counts[id] > 0) {
        cleanComponents[id] = true;
      }
    }
    return cleanComponents;
  }
  var ReactDefaultPerfAnalysis = {
    getExclusiveSummary: getExclusiveSummary,
    getInclusiveSummary: getInclusiveSummary,
    getDOMSummary: getDOMSummary,
    getTotalTime: getTotalTime
  };
  module.exports = ReactDefaultPerfAnalysis;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/performance", ["./ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  var performance;
  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }
  module.exports = performance || {};
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactServerRenderingTransaction", ["./PooledClass", "./CallbackQueue", "./ReactPutListenerQueue", "./Transaction", "./Object.assign", "./emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var PooledClass = require("./PooledClass");
  var CallbackQueue = require("./CallbackQueue");
  var ReactPutListenerQueue = require("./ReactPutListenerQueue");
  var Transaction = require("./Transaction");
  var assign = require("./Object.assign");
  var emptyFunction = require("./emptyFunction");
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: emptyFunction
  };
  var PUT_LISTENER_QUEUEING = {
    initialize: function() {
      this.putListenerQueue.reset();
    },
    close: emptyFunction
  };
  var TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, ON_DOM_READY_QUEUEING];
  function ReactServerRenderingTransaction(renderToStaticMarkup) {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = renderToStaticMarkup;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.putListenerQueue = ReactPutListenerQueue.getPooled();
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    getPutListenerQueue: function() {
      return this.putListenerQueue;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
      ReactPutListenerQueue.release(this.putListenerQueue);
      this.putListenerQueue = null;
    }
  };
  assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactServerRenderingTransaction);
  module.exports = ReactServerRenderingTransaction;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/onlyChild", ["./ReactElement", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var invariant = require("./invariant");
    function onlyChild(children) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(children), 'onlyChild must be passed a children with exactly one child.') : invariant(ReactElement.isValidElement(children)));
      return children;
    }
    module.exports = onlyChild;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:immutable@3.7.2/dist/immutable", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Immutable = factory();
  }(this, function() {
    'use strict';
    var SLICE$0 = Array.prototype.slice;
    function createClass(ctor, superClass) {
      if (superClass) {
        ctor.prototype = Object.create(superClass.prototype);
      }
      ctor.prototype.constructor = ctor;
    }
    var DELETE = 'delete';
    var SHIFT = 5;
    var SIZE = 1 << SHIFT;
    var MASK = SIZE - 1;
    var NOT_SET = {};
    var CHANGE_LENGTH = {value: false};
    var DID_ALTER = {value: false};
    function MakeRef(ref) {
      ref.value = false;
      return ref;
    }
    function SetRef(ref) {
      ref && (ref.value = true);
    }
    function OwnerID() {}
    function arrCopy(arr, offset) {
      offset = offset || 0;
      var len = Math.max(0, arr.length - offset);
      var newArr = new Array(len);
      for (var ii = 0; ii < len; ii++) {
        newArr[ii] = arr[ii + offset];
      }
      return newArr;
    }
    function ensureSize(iter) {
      if (iter.size === undefined) {
        iter.size = iter.__iterate(returnTrue);
      }
      return iter.size;
    }
    function wrapIndex(iter, index) {
      return index >= 0 ? (+index) : ensureSize(iter) + (+index);
    }
    function returnTrue() {
      return true;
    }
    function wholeSlice(begin, end, size) {
      return (begin === 0 || (size !== undefined && begin <= -size)) && (end === undefined || (size !== undefined && end >= size));
    }
    function resolveBegin(begin, size) {
      return resolveIndex(begin, size, 0);
    }
    function resolveEnd(end, size) {
      return resolveIndex(end, size, size);
    }
    function resolveIndex(index, size, defaultIndex) {
      return index === undefined ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === undefined ? index : Math.min(size, index);
    }
    function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }
    createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }
    createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }
    createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }
    function isIterable(maybeIterable) {
      return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
    }
    function isKeyed(maybeKeyed) {
      return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
    }
    function isIndexed(maybeIndexed) {
      return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
    }
    function isAssociative(maybeAssociative) {
      return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
    }
    function isOrdered(maybeOrdered) {
      return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
    }
    Iterable.isIterable = isIterable;
    Iterable.isKeyed = isKeyed;
    Iterable.isIndexed = isIndexed;
    Iterable.isAssociative = isAssociative;
    Iterable.isOrdered = isOrdered;
    Iterable.Keyed = KeyedIterable;
    Iterable.Indexed = IndexedIterable;
    Iterable.Set = SetIterable;
    var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
    var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
    var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
    var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
    var ITERATE_KEYS = 0;
    var ITERATE_VALUES = 1;
    var ITERATE_ENTRIES = 2;
    var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
    function src_Iterator__Iterator(next) {
      this.next = next;
    }
    src_Iterator__Iterator.prototype.toString = function() {
      return '[Iterator]';
    };
    src_Iterator__Iterator.KEYS = ITERATE_KEYS;
    src_Iterator__Iterator.VALUES = ITERATE_VALUES;
    src_Iterator__Iterator.ENTRIES = ITERATE_ENTRIES;
    src_Iterator__Iterator.prototype.inspect = src_Iterator__Iterator.prototype.toSource = function() {
      return this.toString();
    };
    src_Iterator__Iterator.prototype[ITERATOR_SYMBOL] = function() {
      return this;
    };
    function iteratorValue(type, k, v, iteratorResult) {
      var value = type === 0 ? k : type === 1 ? v : [k, v];
      iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
        value: value,
        done: false
      });
      return iteratorResult;
    }
    function iteratorDone() {
      return {
        value: undefined,
        done: true
      };
    }
    function hasIterator(maybeIterable) {
      return !!getIteratorFn(maybeIterable);
    }
    function isIterator(maybeIterator) {
      return maybeIterator && typeof maybeIterator.next === 'function';
    }
    function getIterator(iterable) {
      var iteratorFn = getIteratorFn(iterable);
      return iteratorFn && iteratorFn.call(iterable);
    }
    function getIteratorFn(iterable) {
      var iteratorFn = iterable && ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) || iterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }
    function isArrayLike(value) {
      return value && typeof value.length === 'number';
    }
    createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === undefined ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);
    }
    Seq.of = function() {
      return Seq(arguments);
    };
    Seq.prototype.toSeq = function() {
      return this;
    };
    Seq.prototype.toString = function() {
      return this.__toString('Seq {', '}');
    };
    Seq.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };
    Seq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };
    Seq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, true);
    };
    createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === undefined ? emptySequence().toKeyedSeq() : isIterable(value) ? (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) : keyedSeqFromValue(value);
    }
    KeyedSeq.prototype.toKeyedSeq = function() {
      return this;
    };
    createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }
    IndexedSeq.of = function() {
      return IndexedSeq(arguments);
    };
    IndexedSeq.prototype.toIndexedSeq = function() {
      return this;
    };
    IndexedSeq.prototype.toString = function() {
      return this.__toString('Seq [', ']');
    };
    IndexedSeq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };
    IndexedSeq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, false);
    };
    createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();
    }
    SetSeq.of = function() {
      return SetSeq(arguments);
    };
    SetSeq.prototype.toSetSeq = function() {
      return this;
    };
    Seq.isSeq = isSeq;
    Seq.Keyed = KeyedSeq;
    Seq.Set = SetSeq;
    Seq.Indexed = IndexedSeq;
    var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
    Seq.prototype[IS_SEQ_SENTINEL] = true;
    createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }
    ArraySeq.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };
    ArraySeq.prototype.__iterate = function(fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    ArraySeq.prototype.__iterator = function(type, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new src_Iterator__Iterator(function() {
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);
      });
    };
    createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }
    ObjectSeq.prototype.get = function(key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };
    ObjectSeq.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };
    ObjectSeq.prototype.__iterate = function(fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    ObjectSeq.prototype.__iterator = function(type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      var ii = 0;
      return new src_Iterator__Iterator(function() {
        var key = keys[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);
      });
    };
    ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
    createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }
    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };
    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new src_Iterator__Iterator(iteratorDone);
      }
      var iterations = 0;
      return new src_Iterator__Iterator(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };
    createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }
    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new src_Iterator__Iterator(function() {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type, iterations, cache[iterations++]);
      });
    };
    function isSeq(maybeSeq) {
      return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
    }
    var EMPTY_SEQ;
    function emptySequence() {
      return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
    }
    function keyedSeqFromValue(value) {
      var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === 'object' ? new ObjectSeq(value) : undefined;
      if (!seq) {
        throw new TypeError('Expected Array or iterable object of [k, v] entries, ' + 'or keyed object: ' + value);
      }
      return seq;
    }
    function indexedSeqFromValue(value) {
      var seq = maybeIndexedSeqFromValue(value);
      if (!seq) {
        throw new TypeError('Expected Array or iterable object of values: ' + value);
      }
      return seq;
    }
    function seqFromValue(value) {
      var seq = maybeIndexedSeqFromValue(value) || (typeof value === 'object' && new ObjectSeq(value));
      if (!seq) {
        throw new TypeError('Expected Array or iterable object of values, or keyed object: ' + value);
      }
      return seq;
    }
    function maybeIndexedSeqFromValue(value) {
      return (isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : undefined);
    }
    function seqIterate(seq, fn, reverse, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          var entry = cache[reverse ? maxIndex - ii : ii];
          if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
            return ii + 1;
          }
        }
        return ii;
      }
      return seq.__iterateUncached(fn, reverse);
    }
    function seqIterator(seq, type, reverse, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        var ii = 0;
        return new src_Iterator__Iterator(function() {
          var entry = cache[reverse ? maxIndex - ii : ii];
          return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
        });
      }
      return seq.__iteratorUncached(type, reverse);
    }
    createClass(Collection, Iterable);
    function Collection() {
      throw TypeError('Abstract');
    }
    createClass(KeyedCollection, Collection);
    function KeyedCollection() {}
    createClass(IndexedCollection, Collection);
    function IndexedCollection() {}
    createClass(SetCollection, Collection);
    function SetCollection() {}
    Collection.Keyed = KeyedCollection;
    Collection.Indexed = IndexedCollection;
    Collection.Set = SetCollection;
    function is(valueA, valueB) {
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
      if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
        valueA = valueA.valueOf();
        valueB = valueB.valueOf();
        if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
          return true;
        }
        if (!valueA || !valueB) {
          return false;
        }
      }
      if (typeof valueA.equals === 'function' && typeof valueB.equals === 'function' && valueA.equals(valueB)) {
        return true;
      }
      return false;
    }
    function fromJS(json, converter) {
      return converter ? fromJSWith(converter, json, '', {'': json}) : fromJSDefault(json);
    }
    function fromJSWith(converter, json, key, parentJSON) {
      if (Array.isArray(json)) {
        return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k) {
          return fromJSWith(converter, v, k, json);
        }));
      }
      if (isPlainObj(json)) {
        return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k) {
          return fromJSWith(converter, v, k, json);
        }));
      }
      return json;
    }
    function fromJSDefault(json) {
      if (Array.isArray(json)) {
        return IndexedSeq(json).map(fromJSDefault).toList();
      }
      if (isPlainObj(json)) {
        return KeyedSeq(json).map(fromJSDefault).toMap();
      }
      return json;
    }
    function isPlainObj(value) {
      return value && (value.constructor === Object || value.constructor === undefined);
    }
    var src_Math__imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
      a = a | 0;
      b = b | 0;
      var c = a & 0xffff;
      var d = b & 0xffff;
      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0;
    };
    function smi(i32) {
      return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
    }
    function hash(o) {
      if (o === false || o === null || o === undefined) {
        return 0;
      }
      if (typeof o.valueOf === 'function') {
        o = o.valueOf();
        if (o === false || o === null || o === undefined) {
          return 0;
        }
      }
      if (o === true) {
        return 1;
      }
      var type = typeof o;
      if (type === 'number') {
        var h = o | 0;
        if (h !== o) {
          h ^= o * 0xFFFFFFFF;
        }
        while (o > 0xFFFFFFFF) {
          o /= 0xFFFFFFFF;
          h ^= o;
        }
        return smi(h);
      }
      if (type === 'string') {
        return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
      }
      if (typeof o.hashCode === 'function') {
        return o.hashCode();
      }
      return hashJSObj(o);
    }
    function cachedHashString(string) {
      var hash = stringHashCache[string];
      if (hash === undefined) {
        hash = hashString(string);
        if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
          STRING_HASH_CACHE_SIZE = 0;
          stringHashCache = {};
        }
        STRING_HASH_CACHE_SIZE++;
        stringHashCache[string] = hash;
      }
      return hash;
    }
    function hashString(string) {
      var hash = 0;
      for (var ii = 0; ii < string.length; ii++) {
        hash = 31 * hash + string.charCodeAt(ii) | 0;
      }
      return smi(hash);
    }
    function hashJSObj(obj) {
      var hash;
      if (usingWeakMap) {
        hash = weakMap.get(obj);
        if (hash !== undefined) {
          return hash;
        }
      }
      hash = obj[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }
      if (!canDefineProperty) {
        hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
        if (hash !== undefined) {
          return hash;
        }
        hash = getIENodeHash(obj);
        if (hash !== undefined) {
          return hash;
        }
      }
      hash = ++objHashUID;
      if (objHashUID & 0x40000000) {
        objHashUID = 0;
      }
      if (usingWeakMap) {
        weakMap.set(obj, hash);
      } else if (isExtensible !== undefined && isExtensible(obj) === false) {
        throw new Error('Non-extensible objects are not allowed as keys.');
      } else if (canDefineProperty) {
        Object.defineProperty(obj, UID_HASH_KEY, {
          'enumerable': false,
          'configurable': false,
          'writable': false,
          'value': hash
        });
      } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
        obj.propertyIsEnumerable = function() {
          return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
        };
        obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
      } else if (obj.nodeType !== undefined) {
        obj[UID_HASH_KEY] = hash;
      } else {
        throw new Error('Unable to set a non-enumerable property on object.');
      }
      return hash;
    }
    var isExtensible = Object.isExtensible;
    var canDefineProperty = (function() {
      try {
        Object.defineProperty({}, '@', {});
        return true;
      } catch (e) {
        return false;
      }
    }());
    function getIENodeHash(node) {
      if (node && node.nodeType > 0) {
        switch (node.nodeType) {
          case 1:
            return node.uniqueID;
          case 9:
            return node.documentElement && node.documentElement.uniqueID;
        }
      }
    }
    var usingWeakMap = typeof WeakMap === 'function';
    var weakMap;
    if (usingWeakMap) {
      weakMap = new WeakMap();
    }
    var objHashUID = 0;
    var UID_HASH_KEY = '__immutablehash__';
    if (typeof Symbol === 'function') {
      UID_HASH_KEY = Symbol(UID_HASH_KEY);
    }
    var STRING_HASH_CACHE_MIN_STRLEN = 16;
    var STRING_HASH_CACHE_MAX_SIZE = 255;
    var STRING_HASH_CACHE_SIZE = 0;
    var stringHashCache = {};
    function invariant(condition, error) {
      if (!condition)
        throw new Error(error);
    }
    function assertNotInfinite(size) {
      invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
    }
    createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }
    ToKeyedSequence.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };
    ToKeyedSequence.prototype.has = function(key) {
      return this._iter.has(key);
    };
    ToKeyedSequence.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };
    ToKeyedSequence.prototype.reverse = function() {
      var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function() {
          return this$0._iter.toSeq().reverse();
        };
      }
      return reversedSequence;
    };
    ToKeyedSequence.prototype.map = function(mapper, context) {
      var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function() {
          return this$0._iter.toSeq().map(mapper, context);
        };
      }
      return mappedSequence;
    };
    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      var ii;
      return this._iter.__iterate(this._useKeys ? function(v, k) {
        return fn(v, k, this$0);
      } : ((ii = reverse ? resolveSize(this) : 0), function(v) {
        return fn(v, reverse ? --ii : ii++, this$0);
      }), reverse);
    };
    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new src_Iterator__Iterator(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);
      });
    };
    ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
    createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }
    ToIndexedSequence.prototype.includes = function(value) {
      return this._iter.includes(value);
    };
    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v) {
        return fn(v, iterations++, this$0);
      }, reverse);
    };
    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new src_Iterator__Iterator(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value, step);
      });
    };
    createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }
    ToSetSequence.prototype.has = function(key) {
      return this._iter.includes(key);
    };
    ToSetSequence.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      return this._iter.__iterate(function(v) {
        return fn(v, v, this$0);
      }, reverse);
    };
    ToSetSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new src_Iterator__Iterator(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, step.value, step.value, step);
      });
    };
    createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }
    FromEntriesSequence.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };
    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      return this._iter.__iterate(function(entry) {
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);
        }
      }, reverse);
    };
    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new src_Iterator__Iterator(function() {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);
          }
        }
      });
    };
    ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
    function flipFactory(iterable) {
      var flipSequence = makeSequence(iterable);
      flipSequence._iter = iterable;
      flipSequence.size = iterable.size;
      flipSequence.flip = function() {
        return iterable;
      };
      flipSequence.reverse = function() {
        var reversedSequence = iterable.reverse.apply(this);
        reversedSequence.flip = function() {
          return iterable.reverse();
        };
        return reversedSequence;
      };
      flipSequence.has = function(key) {
        return iterable.includes(key);
      };
      flipSequence.includes = function(key) {
        return iterable.has(key);
      };
      flipSequence.cacheResult = cacheResultThrough;
      flipSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(function(v, k) {
          return fn(k, v, this$0) !== false;
        }, reverse);
      };
      flipSequence.__iteratorUncached = function(type, reverse) {
        if (type === ITERATE_ENTRIES) {
          var iterator = iterable.__iterator(type, reverse);
          return new src_Iterator__Iterator(function() {
            var step = iterator.next();
            if (!step.done) {
              var k = step.value[0];
              step.value[0] = step.value[1];
              step.value[1] = k;
            }
            return step;
          });
        }
        return iterable.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
      };
      return flipSequence;
    }
    function mapFactory(iterable, mapper, context) {
      var mappedSequence = makeSequence(iterable);
      mappedSequence.size = iterable.size;
      mappedSequence.has = function(key) {
        return iterable.has(key);
      };
      mappedSequence.get = function(key, notSetValue) {
        var v = iterable.get(key, NOT_SET);
        return v === NOT_SET ? notSetValue : mapper.call(context, v, key, iterable);
      };
      mappedSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(function(v, k, c) {
          return fn(mapper.call(context, v, k, c), k, this$0) !== false;
        }, reverse);
      };
      mappedSequence.__iteratorUncached = function(type, reverse) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        return new src_Iterator__Iterator(function() {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          return iteratorValue(type, key, mapper.call(context, entry[1], key, iterable), step);
        });
      };
      return mappedSequence;
    }
    function reverseFactory(iterable, useKeys) {
      var reversedSequence = makeSequence(iterable);
      reversedSequence._iter = iterable;
      reversedSequence.size = iterable.size;
      reversedSequence.reverse = function() {
        return iterable;
      };
      if (iterable.flip) {
        reversedSequence.flip = function() {
          var flipSequence = flipFactory(iterable);
          flipSequence.reverse = function() {
            return iterable.flip();
          };
          return flipSequence;
        };
      }
      reversedSequence.get = function(key, notSetValue) {
        return iterable.get(useKeys ? key : -1 - key, notSetValue);
      };
      reversedSequence.has = function(key) {
        return iterable.has(useKeys ? key : -1 - key);
      };
      reversedSequence.includes = function(value) {
        return iterable.includes(value);
      };
      reversedSequence.cacheResult = cacheResultThrough;
      reversedSequence.__iterate = function(fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(function(v, k) {
          return fn(v, k, this$0);
        }, !reverse);
      };
      reversedSequence.__iterator = function(type, reverse) {
        return iterable.__iterator(type, !reverse);
      };
      return reversedSequence;
    }
    function filterFactory(iterable, predicate, context, useKeys) {
      var filterSequence = makeSequence(iterable);
      if (useKeys) {
        filterSequence.has = function(key) {
          var v = iterable.get(key, NOT_SET);
          return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
        };
        filterSequence.get = function(key, notSetValue) {
          var v = iterable.get(key, NOT_SET);
          return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v : notSetValue;
        };
      }
      filterSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        }, reverse);
        return iterations;
      };
      filterSequence.__iteratorUncached = function(type, reverse) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var iterations = 0;
        return new src_Iterator__Iterator(function() {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            var key = entry[0];
            var value = entry[1];
            if (predicate.call(context, value, key, iterable)) {
              return iteratorValue(type, useKeys ? key : iterations++, value, step);
            }
          }
        });
      };
      return filterSequence;
    }
    function countByFactory(iterable, grouper, context) {
      var groups = src_Map__Map().asMutable();
      iterable.__iterate(function(v, k) {
        groups.update(grouper.call(context, v, k, iterable), 0, function(a) {
          return a + 1;
        });
      });
      return groups.asImmutable();
    }
    function groupByFactory(iterable, grouper, context) {
      var isKeyedIter = isKeyed(iterable);
      var groups = (isOrdered(iterable) ? OrderedMap() : src_Map__Map()).asMutable();
      iterable.__iterate(function(v, k) {
        groups.update(grouper.call(context, v, k, iterable), function(a) {
          return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a);
        });
      });
      var coerce = iterableClass(iterable);
      return groups.map(function(arr) {
        return reify(iterable, coerce(arr));
      });
    }
    function sliceFactory(iterable, begin, end, useKeys) {
      var originalSize = iterable.size;
      if (wholeSlice(begin, end, originalSize)) {
        return iterable;
      }
      var resolvedBegin = resolveBegin(begin, originalSize);
      var resolvedEnd = resolveEnd(end, originalSize);
      if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
        return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
      }
      var sliceSize = resolvedEnd - resolvedBegin;
      if (sliceSize < 0) {
        sliceSize = 0;
      }
      var sliceSeq = makeSequence(iterable);
      sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;
      if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
        sliceSeq.get = function(index, notSetValue) {
          index = wrapIndex(this, index);
          return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
        };
      }
      sliceSeq.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        if (sliceSize === 0) {
          return 0;
        }
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var skipped = 0;
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function(v, k) {
          if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
          }
        });
        return iterations;
      };
      sliceSeq.__iteratorUncached = function(type, reverse) {
        if (sliceSize && reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = sliceSize && iterable.__iterator(type, reverse);
        var skipped = 0;
        var iterations = 0;
        return new src_Iterator__Iterator(function() {
          while (skipped++ < resolvedBegin) {
            iterator.next();
          }
          if (++iterations > sliceSize) {
            return iteratorDone();
          }
          var step = iterator.next();
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          } else if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations - 1, undefined, step);
          } else {
            return iteratorValue(type, iterations - 1, step.value[1], step);
          }
        });
      };
      return sliceSeq;
    }
    function takeWhileFactory(iterable, predicate, context) {
      var takeSequence = makeSequence(iterable);
      takeSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var iterations = 0;
        iterable.__iterate(function(v, k, c) {
          return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);
        });
        return iterations;
      };
      takeSequence.__iteratorUncached = function(type, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var iterating = true;
        return new src_Iterator__Iterator(function() {
          if (!iterating) {
            return iteratorDone();
          }
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var k = entry[0];
          var v = entry[1];
          if (!predicate.call(context, v, k, this$0)) {
            iterating = false;
            return iteratorDone();
          }
          return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
        });
      };
      return takeSequence;
    }
    function skipWhileFactory(iterable, predicate, context, useKeys) {
      var skipSequence = makeSequence(iterable);
      skipSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function(v, k, c) {
          if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        });
        return iterations;
      };
      skipSequence.__iteratorUncached = function(type, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var skipping = true;
        var iterations = 0;
        return new src_Iterator__Iterator(function() {
          var step,
              k,
              v;
          do {
            step = iterator.next();
            if (step.done) {
              if (useKeys || type === ITERATE_VALUES) {
                return step;
              } else if (type === ITERATE_KEYS) {
                return iteratorValue(type, iterations++, undefined, step);
              } else {
                return iteratorValue(type, iterations++, step.value[1], step);
              }
            }
            var entry = step.value;
            k = entry[0];
            v = entry[1];
            skipping && (skipping = predicate.call(context, v, k, this$0));
          } while (skipping);
          return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
        });
      };
      return skipSequence;
    }
    function concatFactory(iterable, values) {
      var isKeyedIterable = isKeyed(iterable);
      var iters = [iterable].concat(values).map(function(v) {
        if (!isIterable(v)) {
          v = isKeyedIterable ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
        } else if (isKeyedIterable) {
          v = KeyedIterable(v);
        }
        return v;
      }).filter(function(v) {
        return v.size !== 0;
      });
      if (iters.length === 0) {
        return iterable;
      }
      if (iters.length === 1) {
        var singleton = iters[0];
        if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {
          return singleton;
        }
      }
      var concatSeq = new ArraySeq(iters);
      if (isKeyedIterable) {
        concatSeq = concatSeq.toKeyedSeq();
      } else if (!isIndexed(iterable)) {
        concatSeq = concatSeq.toSetSeq();
      }
      concatSeq = concatSeq.flatten(true);
      concatSeq.size = iters.reduce(function(sum, seq) {
        if (sum !== undefined) {
          var size = seq.size;
          if (size !== undefined) {
            return sum + size;
          }
        }
      }, 0);
      return concatSeq;
    }
    function flattenFactory(iterable, depth, useKeys) {
      var flatSequence = makeSequence(iterable);
      flatSequence.__iterateUncached = function(fn, reverse) {
        var iterations = 0;
        var stopped = false;
        function flatDeep(iter, currentDepth) {
          var this$0 = this;
          iter.__iterate(function(v, k) {
            if ((!depth || currentDepth < depth) && isIterable(v)) {
              flatDeep(v, currentDepth + 1);
            } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
              stopped = true;
            }
            return !stopped;
          }, reverse);
        }
        flatDeep(iterable, 0);
        return iterations;
      };
      flatSequence.__iteratorUncached = function(type, reverse) {
        var iterator = iterable.__iterator(type, reverse);
        var stack = [];
        var iterations = 0;
        return new src_Iterator__Iterator(function() {
          while (iterator) {
            var step = iterator.next();
            if (step.done !== false) {
              iterator = stack.pop();
              continue;
            }
            var v = step.value;
            if (type === ITERATE_ENTRIES) {
              v = v[1];
            }
            if ((!depth || stack.length < depth) && isIterable(v)) {
              stack.push(iterator);
              iterator = v.__iterator(type, reverse);
            } else {
              return useKeys ? step : iteratorValue(type, iterations++, v, step);
            }
          }
          return iteratorDone();
        });
      };
      return flatSequence;
    }
    function flatMapFactory(iterable, mapper, context) {
      var coerce = iterableClass(iterable);
      return iterable.toSeq().map(function(v, k) {
        return coerce(mapper.call(context, v, k, iterable));
      }).flatten(true);
    }
    function interposeFactory(iterable, separator) {
      var interposedSequence = makeSequence(iterable);
      interposedSequence.size = iterable.size && iterable.size * 2 - 1;
      interposedSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function(v, k) {
          return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;
        }, reverse);
        return iterations;
      };
      interposedSequence.__iteratorUncached = function(type, reverse) {
        var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
        var iterations = 0;
        var step;
        return new src_Iterator__Iterator(function() {
          if (!step || iterations % 2) {
            step = iterator.next();
            if (step.done) {
              return step;
            }
          }
          return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
        });
      };
      return interposedSequence;
    }
    function sortFactory(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator;
      }
      var isKeyedIterable = isKeyed(iterable);
      var index = 0;
      var entries = iterable.toSeq().map(function(v, k) {
        return [k, v, index++, mapper ? mapper(v, k, iterable) : v];
      }).toArray();
      entries.sort(function(a, b) {
        return comparator(a[3], b[3]) || a[2] - b[2];
      }).forEach(isKeyedIterable ? function(v, i) {
        entries[i].length = 2;
      } : function(v, i) {
        entries[i] = v[1];
      });
      return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);
    }
    function maxFactory(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator;
      }
      if (mapper) {
        var entry = iterable.toSeq().map(function(v, k) {
          return [v, mapper(v, k, iterable)];
        }).reduce(function(a, b) {
          return maxCompare(comparator, a[1], b[1]) ? b : a;
        });
        return entry && entry[0];
      } else {
        return iterable.reduce(function(a, b) {
          return maxCompare(comparator, a, b) ? b : a;
        });
      }
    }
    function maxCompare(comparator, a, b) {
      var comp = comparator(b, a);
      return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
    }
    function zipWithFactory(keyIter, zipper, iters) {
      var zipSequence = makeSequence(keyIter);
      zipSequence.size = new ArraySeq(iters).map(function(i) {
        return i.size;
      }).min();
      zipSequence.__iterate = function(fn, reverse) {
        var iterator = this.__iterator(ITERATE_VALUES, reverse);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
        return iterations;
      };
      zipSequence.__iteratorUncached = function(type, reverse) {
        var iterators = iters.map(function(i) {
          return (i = Iterable(i), getIterator(reverse ? i.reverse() : i));
        });
        var iterations = 0;
        var isDone = false;
        return new src_Iterator__Iterator(function() {
          var steps;
          if (!isDone) {
            steps = iterators.map(function(i) {
              return i.next();
            });
            isDone = steps.some(function(s) {
              return s.done;
            });
          }
          if (isDone) {
            return iteratorDone();
          }
          return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function(s) {
            return s.value;
          })));
        });
      };
      return zipSequence;
    }
    function reify(iter, seq) {
      return isSeq(iter) ? seq : iter.constructor(seq);
    }
    function validateEntry(entry) {
      if (entry !== Object(entry)) {
        throw new TypeError('Expected [K, V] tuple: ' + entry);
      }
    }
    function resolveSize(iter) {
      assertNotInfinite(iter.size);
      return ensureSize(iter);
    }
    function iterableClass(iterable) {
      return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;
    }
    function makeSequence(iterable) {
      return Object.create((isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype);
    }
    function cacheResultThrough() {
      if (this._iter.cacheResult) {
        this._iter.cacheResult();
        this.size = this._iter.size;
        return this;
      } else {
        return Seq.prototype.cacheResult.call(this);
      }
    }
    function defaultComparator(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
    function forceIterator(keyPath) {
      var iter = getIterator(keyPath);
      if (!iter) {
        if (!isArrayLike(keyPath)) {
          throw new TypeError('Expected iterable or array-like: ' + keyPath);
        }
        iter = getIterator(Iterable(keyPath));
      }
      return iter;
    }
    createClass(src_Map__Map, KeyedCollection);
    function src_Map__Map(value) {
      return value === null || value === undefined ? emptyMap() : isMap(value) ? value : emptyMap().withMutations(function(map) {
        var iter = KeyedIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function(v, k) {
          return map.set(k, v);
        });
      });
    }
    src_Map__Map.prototype.toString = function() {
      return this.__toString('Map {', '}');
    };
    src_Map__Map.prototype.get = function(k, notSetValue) {
      return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
    };
    src_Map__Map.prototype.set = function(k, v) {
      return updateMap(this, k, v);
    };
    src_Map__Map.prototype.setIn = function(keyPath, v) {
      return this.updateIn(keyPath, NOT_SET, function() {
        return v;
      });
    };
    src_Map__Map.prototype.remove = function(k) {
      return updateMap(this, k, NOT_SET);
    };
    src_Map__Map.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function() {
        return NOT_SET;
      });
    };
    src_Map__Map.prototype.update = function(k, notSetValue, updater) {
      return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
    };
    src_Map__Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
      }
      var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);
      return updatedValue === NOT_SET ? undefined : updatedValue;
    };
    src_Map__Map.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };
    src_Map__Map.prototype.merge = function() {
      return mergeIntoMapWith(this, undefined, arguments);
    };
    src_Map__Map.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };
    src_Map__Map.prototype.mergeIn = function(keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(keyPath, emptyMap(), function(m) {
        return m.merge.apply(m, iters);
      });
    };
    src_Map__Map.prototype.mergeDeep = function() {
      return mergeIntoMapWith(this, deepMerger(undefined), arguments);
    };
    src_Map__Map.prototype.mergeDeepWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMerger(merger), iters);
    };
    src_Map__Map.prototype.mergeDeepIn = function(keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(keyPath, emptyMap(), function(m) {
        return m.mergeDeep.apply(m, iters);
      });
    };
    src_Map__Map.prototype.sort = function(comparator) {
      return OrderedMap(sortFactory(this, comparator));
    };
    src_Map__Map.prototype.sortBy = function(mapper, comparator) {
      return OrderedMap(sortFactory(this, comparator, mapper));
    };
    src_Map__Map.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };
    src_Map__Map.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };
    src_Map__Map.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };
    src_Map__Map.prototype.wasAltered = function() {
      return this.__altered;
    };
    src_Map__Map.prototype.__iterator = function(type, reverse) {
      return new MapIterator(this, type, reverse);
    };
    src_Map__Map.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };
    src_Map__Map.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };
    function isMap(maybeMap) {
      return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
    }
    src_Map__Map.isMap = isMap;
    var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
    var MapPrototype = src_Map__Map.prototype;
    MapPrototype[IS_MAP_SENTINEL] = true;
    MapPrototype[DELETE] = MapPrototype.remove;
    MapPrototype.removeIn = MapPrototype.deleteIn;
    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }
    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0,
          len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };
    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && entries.length === 1) {
        return;
      }
      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new ArrayMapNode(ownerID, newEntries);
    };
    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }
    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
    };
    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;
      if (!exists && value === NOT_SET) {
        return this;
      }
      var idx = popCount(bitmap & (bit - 1));
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : undefined;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }
      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }
      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }
      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }
      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };
    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }
    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };
    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];
      if (removed && !node) {
        return this;
      }
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }
      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }
      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };
    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }
    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0,
          len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };
    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var removed = value === NOT_SET;
      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }
      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };
    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }
    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };
    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }
      SetRef(didAlter);
      if (removed) {
        SetRef(didChangeSize);
        return;
      }
      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };
    ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse) {
      var entries = this.entries;
      for (var ii = 0,
          maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
          return false;
        }
      }
    };
    BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse) {
      var nodes = this.nodes;
      for (var ii = 0,
          maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse) === false) {
          return false;
        }
      }
    };
    ValueNode.prototype.iterate = function(fn, reverse) {
      return fn(this.entry);
    };
    createClass(MapIterator, src_Iterator__Iterator);
    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }
    MapIterator.prototype.next = function() {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };
    function mapIteratorValue(type, entry) {
      return iteratorValue(type, entry[0], entry[1]);
    }
    function mapIteratorFrame(node, prev) {
      return {
        node: node,
        index: 0,
        __prev: prev
      };
    }
    function makeMap(size, root, ownerID, hash) {
      var map = Object.create(MapPrototype);
      map.size = size;
      map._root = root;
      map.__ownerID = ownerID;
      map.__hash = hash;
      map.__altered = false;
      return map;
    }
    var EMPTY_MAP;
    function emptyMap() {
      return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
    }
    function updateMap(map, k, v) {
      var newRoot;
      var newSize;
      if (!map._root) {
        if (v === NOT_SET) {
          return map;
        }
        newSize = 1;
        newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
      } else {
        var didChangeSize = MakeRef(CHANGE_LENGTH);
        var didAlter = MakeRef(DID_ALTER);
        newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
        if (!didAlter.value) {
          return map;
        }
        newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
      }
      if (map.__ownerID) {
        map.size = newSize;
        map._root = newRoot;
        map.__hash = undefined;
        map.__altered = true;
        return map;
      }
      return newRoot ? makeMap(newSize, newRoot) : emptyMap();
    }
    function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (!node) {
        if (value === NOT_SET) {
          return node;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return new ValueNode(ownerID, keyHash, [key, value]);
      }
      return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
    }
    function isLeafNode(node) {
      return node.constructor === ValueNode || node.constructor === HashCollisionNode;
    }
    function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
      if (node.keyHash === keyHash) {
        return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
      }
      var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
      var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var newNode;
      var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);
      return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
    }
    function createNodes(ownerID, entries, key, value) {
      if (!ownerID) {
        ownerID = new OwnerID();
      }
      var node = new ValueNode(ownerID, hash(key), [key, value]);
      for (var ii = 0; ii < entries.length; ii++) {
        var entry = entries[ii];
        node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
      }
      return node;
    }
    function packNodes(ownerID, nodes, count, excluding) {
      var bitmap = 0;
      var packedII = 0;
      var packedNodes = new Array(count);
      for (var ii = 0,
          bit = 1,
          len = nodes.length; ii < len; ii++, bit <<= 1) {
        var node = nodes[ii];
        if (node !== undefined && ii !== excluding) {
          bitmap |= bit;
          packedNodes[packedII++] = node;
        }
      }
      return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
    }
    function expandNodes(ownerID, nodes, bitmap, including, node) {
      var count = 0;
      var expandedNodes = new Array(SIZE);
      for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
        expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
      }
      expandedNodes[including] = node;
      return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
    }
    function mergeIntoMapWith(map, merger, iterables) {
      var iters = [];
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = KeyedIterable(value);
        if (!isIterable(value)) {
          iter = iter.map(function(v) {
            return fromJS(v);
          });
        }
        iters.push(iter);
      }
      return mergeIntoCollectionWith(map, merger, iters);
    }
    function deepMerger(merger) {
      return function(existing, value, key) {
        return existing && existing.mergeDeepWith && isIterable(value) ? existing.mergeDeepWith(merger, value) : merger ? merger(existing, value, key) : value;
      };
    }
    function mergeIntoCollectionWith(collection, merger, iters) {
      iters = iters.filter(function(x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return collection;
      }
      if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
        return collection.constructor(iters[0]);
      }
      return collection.withMutations(function(collection) {
        var mergeIntoMap = merger ? function(value, key) {
          collection.update(key, NOT_SET, function(existing) {
            return existing === NOT_SET ? value : merger(existing, value, key);
          });
        } : function(value, key) {
          collection.set(key, value);
        };
        for (var ii = 0; ii < iters.length; ii++) {
          iters[ii].forEach(mergeIntoMap);
        }
      });
    }
    function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
      var isNotSet = existing === NOT_SET;
      var step = keyPathIter.next();
      if (step.done) {
        var existingValue = isNotSet ? notSetValue : existing;
        var newValue = updater(existingValue);
        return newValue === existingValue ? existing : newValue;
      }
      invariant(isNotSet || (existing && existing.set), 'invalid keyPath');
      var key = step.value;
      var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
      var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);
      return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
    }
    function popCount(x) {
      x = x - ((x >> 1) & 0x55555555);
      x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
      x = (x + (x >> 4)) & 0x0f0f0f0f;
      x = x + (x >> 8);
      x = x + (x >> 16);
      return x & 0x7f;
    }
    function setIn(array, idx, val, canEdit) {
      var newArray = canEdit ? array : arrCopy(array);
      newArray[idx] = val;
      return newArray;
    }
    function spliceIn(array, idx, val, canEdit) {
      var newLen = array.length + 1;
      if (canEdit && idx + 1 === newLen) {
        array[idx] = val;
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          newArray[ii] = val;
          after = -1;
        } else {
          newArray[ii] = array[ii + after];
        }
      }
      return newArray;
    }
    function spliceOut(array, idx, canEdit) {
      var newLen = array.length - 1;
      if (canEdit && idx === newLen) {
        array.pop();
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          after = 1;
        }
        newArray[ii] = array[ii + after];
      }
      return newArray;
    }
    var MAX_ARRAY_MAP_SIZE = SIZE / 4;
    var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
    var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
    createClass(List, IndexedCollection);
    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function(list) {
        list.setSize(size);
        iter.forEach(function(v, i) {
          return list.set(i, v);
        });
      });
    }
    List.of = function() {
      return this(arguments);
    };
    List.prototype.toString = function() {
      return this.__toString('List [', ']');
    };
    List.prototype.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      if (index < 0 || index >= this.size) {
        return notSetValue;
      }
      index += this._origin;
      var node = listNodeFor(this, index);
      return node && node.array[index & MASK];
    };
    List.prototype.set = function(index, value) {
      return updateList(this, index, value);
    };
    List.prototype.remove = function(index) {
      return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
    };
    List.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };
    List.prototype.push = function() {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };
    List.prototype.pop = function() {
      return setListBounds(this, 0, -1);
    };
    List.prototype.unshift = function() {
      var values = arguments;
      return this.withMutations(function(list) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };
    List.prototype.shift = function() {
      return setListBounds(this, 1);
    };
    List.prototype.merge = function() {
      return mergeIntoListWith(this, undefined, arguments);
    };
    List.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };
    List.prototype.mergeDeep = function() {
      return mergeIntoListWith(this, deepMerger(undefined), arguments);
    };
    List.prototype.mergeDeepWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMerger(merger), iters);
    };
    List.prototype.setSize = function(size) {
      return setListBounds(this, 0, size);
    };
    List.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
    };
    List.prototype.__iterator = function(type, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      return new src_Iterator__Iterator(function() {
        var value = values();
        return value === DONE ? iteratorDone() : iteratorValue(type, index++, value);
      });
    };
    List.prototype.__iterate = function(fn, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };
    List.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };
    function isList(maybeList) {
      return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
    }
    List.isList = isList;
    var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
    var ListPrototype = List.prototype;
    ListPrototype[IS_LIST_SENTINEL] = true;
    ListPrototype[DELETE] = ListPrototype.remove;
    ListPrototype.setIn = MapPrototype.setIn;
    ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
    ListPrototype.update = MapPrototype.update;
    ListPrototype.updateIn = MapPrototype.updateIn;
    ListPrototype.mergeIn = MapPrototype.mergeIn;
    ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
    ListPrototype.withMutations = MapPrototype.withMutations;
    ListPrototype.asMutable = MapPrototype.asMutable;
    ListPrototype.asImmutable = MapPrototype.asImmutable;
    ListPrototype.wasAltered = MapPrototype.wasAltered;
    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }
    VNode.prototype.removeBefore = function(ownerID, level, index) {
      if (index === level ? 1 << level : 0 || this.array.length === 0) {
        return this;
      }
      var originIndex = (index >>> level) & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = undefined;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };
    VNode.prototype.removeAfter = function(ownerID, level, index) {
      if (index === level ? 1 << level : 0 || this.array.length === 0) {
        return this;
      }
      var sizeIndex = ((index - 1) >>> level) & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }
      var removingLast = sizeIndex === this.array.length - 1;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingLast) {
          return this;
        }
      }
      if (removingLast && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingLast) {
        editable.array.pop();
      }
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };
    var DONE = {};
    function iterateList(list, reverse) {
      var left = list._origin;
      var right = list._capacity;
      var tailPos = getTailOffset(right);
      var tail = list._tail;
      return iterateNodeOrLeaf(list._root, list._level, 0);
      function iterateNodeOrLeaf(node, level, offset) {
        return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
      }
      function iterateLeaf(node, offset) {
        var array = offset === tailPos ? tail && tail.array : node && node.array;
        var from = offset > left ? 0 : left - offset;
        var to = right - offset;
        if (to > SIZE) {
          to = SIZE;
        }
        return function() {
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          return array && array[idx];
        };
      }
      function iterateNode(node, level, offset) {
        var values;
        var array = node && node.array;
        var from = offset > left ? 0 : (left - offset) >> level;
        var to = ((right - offset) >> level) + 1;
        if (to > SIZE) {
          to = SIZE;
        }
        return function() {
          do {
            if (values) {
              var value = values();
              if (value !== DONE) {
                return value;
              }
              values = null;
            }
            if (from === to) {
              return DONE;
            }
            var idx = reverse ? --to : from++;
            values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
          } while (true);
        };
      }
    }
    function makeList(origin, capacity, level, root, tail, ownerID, hash) {
      var list = Object.create(ListPrototype);
      list.size = capacity - origin;
      list._origin = origin;
      list._capacity = capacity;
      list._level = level;
      list._root = root;
      list._tail = tail;
      list.__ownerID = ownerID;
      list.__hash = hash;
      list.__altered = false;
      return list;
    }
    var EMPTY_LIST;
    function emptyList() {
      return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
    }
    function updateList(list, index, value) {
      index = wrapIndex(list, index);
      if (index >= list.size || index < 0) {
        return list.withMutations(function(list) {
          index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
        });
      }
      index += list._origin;
      var newTail = list._tail;
      var newRoot = list._root;
      var didAlter = MakeRef(DID_ALTER);
      if (index >= getTailOffset(list._capacity)) {
        newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
      } else {
        newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
      }
      if (!didAlter.value) {
        return list;
      }
      if (list.__ownerID) {
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = undefined;
        list.__altered = true;
        return list;
      }
      return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
    }
    function updateVNode(node, ownerID, level, index, value, didAlter) {
      var idx = (index >>> level) & MASK;
      var nodeHas = node && idx < node.array.length;
      if (!nodeHas && value === undefined) {
        return node;
      }
      var newNode;
      if (level > 0) {
        var lowerNode = node && node.array[idx];
        var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
        if (newLowerNode === lowerNode) {
          return node;
        }
        newNode = editableVNode(node, ownerID);
        newNode.array[idx] = newLowerNode;
        return newNode;
      }
      if (nodeHas && node.array[idx] === value) {
        return node;
      }
      SetRef(didAlter);
      newNode = editableVNode(node, ownerID);
      if (value === undefined && idx === newNode.array.length - 1) {
        newNode.array.pop();
      } else {
        newNode.array[idx] = value;
      }
      return newNode;
    }
    function editableVNode(node, ownerID) {
      if (ownerID && node && ownerID === node.ownerID) {
        return node;
      }
      return new VNode(node ? node.array.slice() : [], ownerID);
    }
    function listNodeFor(list, rawIndex) {
      if (rawIndex >= getTailOffset(list._capacity)) {
        return list._tail;
      }
      if (rawIndex < 1 << (list._level + SHIFT)) {
        var node = list._root;
        var level = list._level;
        while (node && level > 0) {
          node = node.array[(rawIndex >>> level) & MASK];
          level -= SHIFT;
        }
        return node;
      }
    }
    function setListBounds(list, begin, end) {
      var owner = list.__ownerID || new OwnerID();
      var oldOrigin = list._origin;
      var oldCapacity = list._capacity;
      var newOrigin = oldOrigin + begin;
      var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
      if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
        return list;
      }
      if (newOrigin >= newCapacity) {
        return list.clear();
      }
      var newLevel = list._level;
      var newRoot = list._root;
      var offsetShift = 0;
      while (newOrigin + offsetShift < 0) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
        newLevel += SHIFT;
        offsetShift += 1 << newLevel;
      }
      if (offsetShift) {
        newOrigin += offsetShift;
        oldOrigin += offsetShift;
        newCapacity += offsetShift;
        oldCapacity += offsetShift;
      }
      var oldTailOffset = getTailOffset(oldCapacity);
      var newTailOffset = getTailOffset(newCapacity);
      while (newTailOffset >= 1 << (newLevel + SHIFT)) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
        newLevel += SHIFT;
      }
      var oldTail = list._tail;
      var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
      if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
        newRoot = editableVNode(newRoot, owner);
        var node = newRoot;
        for (var level = newLevel; level > SHIFT; level -= SHIFT) {
          var idx = (oldTailOffset >>> level) & MASK;
          node = node.array[idx] = editableVNode(node.array[idx], owner);
        }
        node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
      }
      if (newCapacity < oldCapacity) {
        newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
      }
      if (newOrigin >= newTailOffset) {
        newOrigin -= newTailOffset;
        newCapacity -= newTailOffset;
        newLevel = SHIFT;
        newRoot = null;
        newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
      } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
        offsetShift = 0;
        while (newRoot) {
          var beginIndex = (newOrigin >>> newLevel) & MASK;
          if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
            break;
          }
          if (beginIndex) {
            offsetShift += (1 << newLevel) * beginIndex;
          }
          newLevel -= SHIFT;
          newRoot = newRoot.array[beginIndex];
        }
        if (newRoot && newOrigin > oldOrigin) {
          newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
        }
        if (newRoot && newTailOffset < oldTailOffset) {
          newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
        }
        if (offsetShift) {
          newOrigin -= offsetShift;
          newCapacity -= offsetShift;
        }
      }
      if (list.__ownerID) {
        list.size = newCapacity - newOrigin;
        list._origin = newOrigin;
        list._capacity = newCapacity;
        list._level = newLevel;
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = undefined;
        list.__altered = true;
        return list;
      }
      return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
    }
    function mergeIntoListWith(list, merger, iterables) {
      var iters = [];
      var maxSize = 0;
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = IndexedIterable(value);
        if (iter.size > maxSize) {
          maxSize = iter.size;
        }
        if (!isIterable(value)) {
          iter = iter.map(function(v) {
            return fromJS(v);
          });
        }
        iters.push(iter);
      }
      if (maxSize > list.size) {
        list = list.setSize(maxSize);
      }
      return mergeIntoCollectionWith(list, merger, iters);
    }
    function getTailOffset(size) {
      return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
    }
    createClass(OrderedMap, src_Map__Map);
    function OrderedMap(value) {
      return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map) {
        var iter = KeyedIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function(v, k) {
          return map.set(k, v);
        });
      });
    }
    OrderedMap.of = function() {
      return this(arguments);
    };
    OrderedMap.prototype.toString = function() {
      return this.__toString('OrderedMap {', '}');
    };
    OrderedMap.prototype.get = function(k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };
    OrderedMap.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };
    OrderedMap.prototype.set = function(k, v) {
      return updateOrderedMap(this, k, v);
    };
    OrderedMap.prototype.remove = function(k) {
      return updateOrderedMap(this, k, NOT_SET);
    };
    OrderedMap.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };
    OrderedMap.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      return this._list.__iterate(function(entry) {
        return entry && fn(entry[1], entry[0], this$0);
      }, reverse);
    };
    OrderedMap.prototype.__iterator = function(type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };
    OrderedMap.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };
    function isOrderedMap(maybeOrderedMap) {
      return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
    }
    OrderedMap.isOrderedMap = isOrderedMap;
    OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
    OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
    function makeOrderedMap(map, list, ownerID, hash) {
      var omap = Object.create(OrderedMap.prototype);
      omap.size = map ? map.size : 0;
      omap._map = map;
      omap._list = list;
      omap.__ownerID = ownerID;
      omap.__hash = hash;
      return omap;
    }
    var EMPTY_ORDERED_MAP;
    function emptyOrderedMap() {
      return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
    }
    function updateOrderedMap(omap, k, v) {
      var map = omap._map;
      var list = omap._list;
      var i = map.get(k);
      var has = i !== undefined;
      var newMap;
      var newList;
      if (v === NOT_SET) {
        if (!has) {
          return omap;
        }
        if (list.size >= SIZE && list.size >= map.size * 2) {
          newList = list.filter(function(entry, idx) {
            return entry !== undefined && i !== idx;
          });
          newMap = newList.toKeyedSeq().map(function(entry) {
            return entry[0];
          }).flip().toMap();
          if (omap.__ownerID) {
            newMap.__ownerID = newList.__ownerID = omap.__ownerID;
          }
        } else {
          newMap = map.remove(k);
          newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
        }
      } else {
        if (has) {
          if (v === list.get(i)[1]) {
            return omap;
          }
          newMap = map;
          newList = list.set(i, [k, v]);
        } else {
          newMap = map.set(k, list.size);
          newList = list.set(list.size, [k, v]);
        }
      }
      if (omap.__ownerID) {
        omap.size = newMap.size;
        omap._map = newMap;
        omap._list = newList;
        omap.__hash = undefined;
        return omap;
      }
      return makeOrderedMap(newMap, newList);
    }
    createClass(Stack, IndexedCollection);
    function Stack(value) {
      return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);
    }
    Stack.of = function() {
      return this(arguments);
    };
    Stack.prototype.toString = function() {
      return this.__toString('Stack [', ']');
    };
    Stack.prototype.get = function(index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };
    Stack.prototype.peek = function() {
      return this._head && this._head.value;
    };
    Stack.prototype.push = function() {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };
    Stack.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };
    Stack.prototype.pop = function() {
      return this.slice(1);
    };
    Stack.prototype.unshift = function() {
      return this.push.apply(this, arguments);
    };
    Stack.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };
    Stack.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };
    Stack.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };
    Stack.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };
    Stack.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };
    Stack.prototype.__iterate = function(fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };
    Stack.prototype.__iterator = function(type, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new src_Iterator__Iterator(function() {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };
    function isStack(maybeStack) {
      return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
    }
    Stack.isStack = isStack;
    var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
    var StackPrototype = Stack.prototype;
    StackPrototype[IS_STACK_SENTINEL] = true;
    StackPrototype.withMutations = MapPrototype.withMutations;
    StackPrototype.asMutable = MapPrototype.asMutable;
    StackPrototype.asImmutable = MapPrototype.asImmutable;
    StackPrototype.wasAltered = MapPrototype.wasAltered;
    function makeStack(size, head, ownerID, hash) {
      var map = Object.create(StackPrototype);
      map.size = size;
      map._head = head;
      map.__ownerID = ownerID;
      map.__hash = hash;
      map.__altered = false;
      return map;
    }
    var EMPTY_STACK;
    function emptyStack() {
      return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
    }
    createClass(src_Set__Set, SetCollection);
    function src_Set__Set(value) {
      return value === null || value === undefined ? emptySet() : isSet(value) ? value : emptySet().withMutations(function(set) {
        var iter = SetIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function(v) {
          return set.add(v);
        });
      });
    }
    src_Set__Set.of = function() {
      return this(arguments);
    };
    src_Set__Set.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };
    src_Set__Set.prototype.toString = function() {
      return this.__toString('Set {', '}');
    };
    src_Set__Set.prototype.has = function(value) {
      return this._map.has(value);
    };
    src_Set__Set.prototype.add = function(value) {
      return updateSet(this, this._map.set(value, true));
    };
    src_Set__Set.prototype.remove = function(value) {
      return updateSet(this, this._map.remove(value));
    };
    src_Set__Set.prototype.clear = function() {
      return updateSet(this, this._map.clear());
    };
    src_Set__Set.prototype.union = function() {
      var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value) {
            return set.add(value);
          });
        }
      });
    };
    src_Set__Set.prototype.intersect = function() {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function(set) {
        originalSet.forEach(function(value) {
          if (!iters.every(function(iter) {
            return iter.includes(value);
          })) {
            set.remove(value);
          }
        });
      });
    };
    src_Set__Set.prototype.subtract = function() {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function(set) {
        originalSet.forEach(function(value) {
          if (iters.some(function(iter) {
            return iter.includes(value);
          })) {
            set.remove(value);
          }
        });
      });
    };
    src_Set__Set.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };
    src_Set__Set.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };
    src_Set__Set.prototype.sort = function(comparator) {
      return OrderedSet(sortFactory(this, comparator));
    };
    src_Set__Set.prototype.sortBy = function(mapper, comparator) {
      return OrderedSet(sortFactory(this, comparator, mapper));
    };
    src_Set__Set.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };
    src_Set__Set.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      return this._map.__iterate(function(_, k) {
        return fn(k, k, this$0);
      }, reverse);
    };
    src_Set__Set.prototype.__iterator = function(type, reverse) {
      return this._map.map(function(_, k) {
        return k;
      }).__iterator(type, reverse);
    };
    src_Set__Set.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };
    function isSet(maybeSet) {
      return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
    }
    src_Set__Set.isSet = isSet;
    var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
    var SetPrototype = src_Set__Set.prototype;
    SetPrototype[IS_SET_SENTINEL] = true;
    SetPrototype[DELETE] = SetPrototype.remove;
    SetPrototype.mergeDeep = SetPrototype.merge;
    SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
    SetPrototype.withMutations = MapPrototype.withMutations;
    SetPrototype.asMutable = MapPrototype.asMutable;
    SetPrototype.asImmutable = MapPrototype.asImmutable;
    SetPrototype.__empty = emptySet;
    SetPrototype.__make = makeSet;
    function updateSet(set, newMap) {
      if (set.__ownerID) {
        set.size = newMap.size;
        set._map = newMap;
        return set;
      }
      return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
    }
    function makeSet(map, ownerID) {
      var set = Object.create(SetPrototype);
      set.size = map ? map.size : 0;
      set._map = map;
      set.__ownerID = ownerID;
      return set;
    }
    var EMPTY_SET;
    function emptySet() {
      return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
    }
    createClass(OrderedSet, src_Set__Set);
    function OrderedSet(value) {
      return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set) {
        var iter = SetIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function(v) {
          return set.add(v);
        });
      });
    }
    OrderedSet.of = function() {
      return this(arguments);
    };
    OrderedSet.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };
    OrderedSet.prototype.toString = function() {
      return this.__toString('OrderedSet {', '}');
    };
    function isOrderedSet(maybeOrderedSet) {
      return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
    }
    OrderedSet.isOrderedSet = isOrderedSet;
    var OrderedSetPrototype = OrderedSet.prototype;
    OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
    OrderedSetPrototype.__empty = emptyOrderedSet;
    OrderedSetPrototype.__make = makeOrderedSet;
    function makeOrderedSet(map, ownerID) {
      var set = Object.create(OrderedSetPrototype);
      set.size = map ? map.size : 0;
      set._map = map;
      set.__ownerID = ownerID;
      return set;
    }
    var EMPTY_ORDERED_SET;
    function emptyOrderedSet() {
      return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
    }
    createClass(Record, KeyedCollection);
    function Record(defaultValues, name) {
      var hasInitialized;
      var RecordType = function Record(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys);
          RecordTypePrototype.size = keys.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = src_Map__Map(values);
      };
      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;
      return RecordType;
    }
    Record.prototype.toString = function() {
      return this.__toString(recordName(this) + ' {', '}');
    };
    Record.prototype.has = function(k) {
      return this._defaultValues.hasOwnProperty(k);
    };
    Record.prototype.get = function(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };
    Record.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };
    Record.prototype.set = function(k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };
    Record.prototype.remove = function(k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };
    Record.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };
    Record.prototype.__iterator = function(type, reverse) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k) {
        return this$0.get(k);
      }).__iterator(type, reverse);
    };
    Record.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k) {
        return this$0.get(k);
      }).__iterate(fn, reverse);
    };
    Record.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };
    var RecordPrototype = Record.prototype;
    RecordPrototype[DELETE] = RecordPrototype.remove;
    RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
    RecordPrototype.merge = MapPrototype.merge;
    RecordPrototype.mergeWith = MapPrototype.mergeWith;
    RecordPrototype.mergeIn = MapPrototype.mergeIn;
    RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
    RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
    RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
    RecordPrototype.setIn = MapPrototype.setIn;
    RecordPrototype.update = MapPrototype.update;
    RecordPrototype.updateIn = MapPrototype.updateIn;
    RecordPrototype.withMutations = MapPrototype.withMutations;
    RecordPrototype.asMutable = MapPrototype.asMutable;
    RecordPrototype.asImmutable = MapPrototype.asImmutable;
    function makeRecord(likeRecord, map, ownerID) {
      var record = Object.create(Object.getPrototypeOf(likeRecord));
      record._map = map;
      record.__ownerID = ownerID;
      return record;
    }
    function recordName(record) {
      return record._name || record.constructor.name || 'Record';
    }
    function setProps(prototype, names) {
      try {
        names.forEach(setProp.bind(undefined, prototype));
      } catch (error) {}
    }
    function setProp(prototype, name) {
      Object.defineProperty(prototype, name, {
        get: function() {
          return this.get(name);
        },
        set: function(value) {
          invariant(this.__ownerID, 'Cannot set on an immutable record.');
          this.set(name, value);
        }
      });
    }
    function deepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (!isIterable(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
        return false;
      }
      if (a.size === 0 && b.size === 0) {
        return true;
      }
      var notAssociative = !isAssociative(a);
      if (isOrdered(a)) {
        var entries = a.entries();
        return b.every(function(v, k) {
          var entry = entries.next().value;
          return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
        }) && entries.next().done;
      }
      var flipped = false;
      if (a.size === undefined) {
        if (b.size === undefined) {
          if (typeof a.cacheResult === 'function') {
            a.cacheResult();
          }
        } else {
          flipped = true;
          var _ = a;
          a = b;
          b = _;
        }
      }
      var allEqual = true;
      var bSize = b.__iterate(function(v, k) {
        if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
          allEqual = false;
          return false;
        }
      });
      return allEqual && a.size === bSize;
    }
    createClass(Range, IndexedSeq);
    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }
    Range.prototype.toString = function() {
      if (this.size === 0) {
        return 'Range []';
      }
      return 'Range [ ' + this._start + '...' + this._end + (this._step > 1 ? ' by ' + this._step : '') + ' ]';
    };
    Range.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
    };
    Range.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
    };
    Range.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };
    Range.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index;
        }
      }
      return -1;
    };
    Range.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };
    Range.prototype.__iterate = function(fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };
    Range.prototype.__iterator = function(type, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new src_Iterator__Iterator(function() {
        var v = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
      });
    };
    Range.prototype.equals = function(other) {
      return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
    };
    var EMPTY_RANGE;
    createClass(Repeat, IndexedSeq);
    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }
    Repeat.prototype.toString = function() {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };
    Repeat.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };
    Repeat.prototype.includes = function(searchValue) {
      return is(this._value, searchValue);
    };
    Repeat.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };
    Repeat.prototype.reverse = function() {
      return this;
    };
    Repeat.prototype.indexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };
    Repeat.prototype.lastIndexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };
    Repeat.prototype.__iterate = function(fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    Repeat.prototype.__iterator = function(type, reverse) {
      var this$0 = this;
      var ii = 0;
      return new src_Iterator__Iterator(function() {
        return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone();
      });
    };
    Repeat.prototype.equals = function(other) {
      return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
    };
    var EMPTY_REPEAT;
    function mixin(ctor, methods) {
      var keyCopier = function(key) {
        ctor.prototype[key] = methods[key];
      };
      Object.keys(methods).forEach(keyCopier);
      Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
      return ctor;
    }
    Iterable.Iterator = src_Iterator__Iterator;
    mixin(Iterable, {
      toArray: function() {
        assertNotInfinite(this.size);
        var array = new Array(this.size || 0);
        this.valueSeq().__iterate(function(v, i) {
          array[i] = v;
        });
        return array;
      },
      toIndexedSeq: function() {
        return new ToIndexedSequence(this);
      },
      toJS: function() {
        return this.toSeq().map(function(value) {
          return value && typeof value.toJS === 'function' ? value.toJS() : value;
        }).__toJS();
      },
      toJSON: function() {
        return this.toSeq().map(function(value) {
          return value && typeof value.toJSON === 'function' ? value.toJSON() : value;
        }).__toJS();
      },
      toKeyedSeq: function() {
        return new ToKeyedSequence(this, true);
      },
      toMap: function() {
        return src_Map__Map(this.toKeyedSeq());
      },
      toObject: function() {
        assertNotInfinite(this.size);
        var object = {};
        this.__iterate(function(v, k) {
          object[k] = v;
        });
        return object;
      },
      toOrderedMap: function() {
        return OrderedMap(this.toKeyedSeq());
      },
      toOrderedSet: function() {
        return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
      },
      toSet: function() {
        return src_Set__Set(isKeyed(this) ? this.valueSeq() : this);
      },
      toSetSeq: function() {
        return new ToSetSequence(this);
      },
      toSeq: function() {
        return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
      },
      toStack: function() {
        return Stack(isKeyed(this) ? this.valueSeq() : this);
      },
      toList: function() {
        return List(isKeyed(this) ? this.valueSeq() : this);
      },
      toString: function() {
        return '[Iterable]';
      },
      __toString: function(head, tail) {
        if (this.size === 0) {
          return head + tail;
        }
        return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
      },
      concat: function() {
        var values = SLICE$0.call(arguments, 0);
        return reify(this, concatFactory(this, values));
      },
      contains: function(searchValue) {
        return this.includes(searchValue);
      },
      includes: function(searchValue) {
        return this.some(function(value) {
          return is(value, searchValue);
        });
      },
      entries: function() {
        return this.__iterator(ITERATE_ENTRIES);
      },
      every: function(predicate, context) {
        assertNotInfinite(this.size);
        var returnValue = true;
        this.__iterate(function(v, k, c) {
          if (!predicate.call(context, v, k, c)) {
            returnValue = false;
            return false;
          }
        });
        return returnValue;
      },
      filter: function(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, true));
      },
      find: function(predicate, context, notSetValue) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[1] : notSetValue;
      },
      findEntry: function(predicate, context) {
        var found;
        this.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            found = [k, v];
            return false;
          }
        });
        return found;
      },
      findLastEntry: function(predicate, context) {
        return this.toSeq().reverse().findEntry(predicate, context);
      },
      forEach: function(sideEffect, context) {
        assertNotInfinite(this.size);
        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
      },
      join: function(separator) {
        assertNotInfinite(this.size);
        separator = separator !== undefined ? '' + separator : ',';
        var joined = '';
        var isFirst = true;
        this.__iterate(function(v) {
          isFirst ? (isFirst = false) : (joined += separator);
          joined += v !== null && v !== undefined ? v.toString() : '';
        });
        return joined;
      },
      keys: function() {
        return this.__iterator(ITERATE_KEYS);
      },
      map: function(mapper, context) {
        return reify(this, mapFactory(this, mapper, context));
      },
      reduce: function(reducer, initialReduction, context) {
        assertNotInfinite(this.size);
        var reduction;
        var useFirst;
        if (arguments.length < 2) {
          useFirst = true;
        } else {
          reduction = initialReduction;
        }
        this.__iterate(function(v, k, c) {
          if (useFirst) {
            useFirst = false;
            reduction = v;
          } else {
            reduction = reducer.call(context, reduction, v, k, c);
          }
        });
        return reduction;
      },
      reduceRight: function(reducer, initialReduction, context) {
        var reversed = this.toKeyedSeq().reverse();
        return reversed.reduce.apply(reversed, arguments);
      },
      reverse: function() {
        return reify(this, reverseFactory(this, true));
      },
      slice: function(begin, end) {
        return reify(this, sliceFactory(this, begin, end, true));
      },
      some: function(predicate, context) {
        return !this.every(not(predicate), context);
      },
      sort: function(comparator) {
        return reify(this, sortFactory(this, comparator));
      },
      values: function() {
        return this.__iterator(ITERATE_VALUES);
      },
      butLast: function() {
        return this.slice(0, -1);
      },
      isEmpty: function() {
        return this.size !== undefined ? this.size === 0 : !this.some(function() {
          return true;
        });
      },
      count: function(predicate, context) {
        return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
      },
      countBy: function(grouper, context) {
        return countByFactory(this, grouper, context);
      },
      equals: function(other) {
        return deepEqual(this, other);
      },
      entrySeq: function() {
        var iterable = this;
        if (iterable._cache) {
          return new ArraySeq(iterable._cache);
        }
        var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
        entriesSequence.fromEntrySeq = function() {
          return iterable.toSeq();
        };
        return entriesSequence;
      },
      filterNot: function(predicate, context) {
        return this.filter(not(predicate), context);
      },
      findLast: function(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
      },
      first: function() {
        return this.find(returnTrue);
      },
      flatMap: function(mapper, context) {
        return reify(this, flatMapFactory(this, mapper, context));
      },
      flatten: function(depth) {
        return reify(this, flattenFactory(this, depth, true));
      },
      fromEntrySeq: function() {
        return new FromEntriesSequence(this);
      },
      get: function(searchKey, notSetValue) {
        return this.find(function(_, key) {
          return is(key, searchKey);
        }, undefined, notSetValue);
      },
      getIn: function(searchKeyPath, notSetValue) {
        var nested = this;
        var iter = forceIterator(searchKeyPath);
        var step;
        while (!(step = iter.next()).done) {
          var key = step.value;
          nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
          if (nested === NOT_SET) {
            return notSetValue;
          }
        }
        return nested;
      },
      groupBy: function(grouper, context) {
        return groupByFactory(this, grouper, context);
      },
      has: function(searchKey) {
        return this.get(searchKey, NOT_SET) !== NOT_SET;
      },
      hasIn: function(searchKeyPath) {
        return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
      },
      isSubset: function(iter) {
        iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
        return this.every(function(value) {
          return iter.includes(value);
        });
      },
      isSuperset: function(iter) {
        return iter.isSubset(this);
      },
      keySeq: function() {
        return this.toSeq().map(keyMapper).toIndexedSeq();
      },
      last: function() {
        return this.toSeq().reverse().first();
      },
      max: function(comparator) {
        return maxFactory(this, comparator);
      },
      maxBy: function(mapper, comparator) {
        return maxFactory(this, comparator, mapper);
      },
      min: function(comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
      },
      minBy: function(mapper, comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
      },
      rest: function() {
        return this.slice(1);
      },
      skip: function(amount) {
        return this.slice(Math.max(0, amount));
      },
      skipLast: function(amount) {
        return reify(this, this.toSeq().reverse().skip(amount).reverse());
      },
      skipWhile: function(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, true));
      },
      skipUntil: function(predicate, context) {
        return this.skipWhile(not(predicate), context);
      },
      sortBy: function(mapper, comparator) {
        return reify(this, sortFactory(this, comparator, mapper));
      },
      take: function(amount) {
        return this.slice(0, Math.max(0, amount));
      },
      takeLast: function(amount) {
        return reify(this, this.toSeq().reverse().take(amount).reverse());
      },
      takeWhile: function(predicate, context) {
        return reify(this, takeWhileFactory(this, predicate, context));
      },
      takeUntil: function(predicate, context) {
        return this.takeWhile(not(predicate), context);
      },
      valueSeq: function() {
        return this.toIndexedSeq();
      },
      hashCode: function() {
        return this.__hash || (this.__hash = hashIterable(this));
      }
    });
    var IterablePrototype = Iterable.prototype;
    IterablePrototype[IS_ITERABLE_SENTINEL] = true;
    IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
    IterablePrototype.__toJS = IterablePrototype.toArray;
    IterablePrototype.__toStringMapper = quoteString;
    IterablePrototype.inspect = IterablePrototype.toSource = function() {
      return this.toString();
    };
    IterablePrototype.chain = IterablePrototype.flatMap;
    (function() {
      try {
        Object.defineProperty(IterablePrototype, 'length', {get: function() {
            if (!Iterable.noLengthWarning) {
              var stack;
              try {
                throw new Error();
              } catch (error) {
                stack = error.stack;
              }
              if (stack.indexOf('_wrapObject') === -1) {
                console && console.warn && console.warn('iterable.length has been deprecated, ' + 'use iterable.size or iterable.count(). ' + 'This warning will become a silent error in a future version. ' + stack);
                return this.size;
              }
            }
          }});
      } catch (e) {}
    })();
    mixin(KeyedIterable, {
      flip: function() {
        return reify(this, flipFactory(this));
      },
      findKey: function(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry && entry[0];
      },
      findLastKey: function(predicate, context) {
        return this.toSeq().reverse().findKey(predicate, context);
      },
      keyOf: function(searchValue) {
        return this.findKey(function(value) {
          return is(value, searchValue);
        });
      },
      lastKeyOf: function(searchValue) {
        return this.findLastKey(function(value) {
          return is(value, searchValue);
        });
      },
      mapEntries: function(mapper, context) {
        var this$0 = this;
        var iterations = 0;
        return reify(this, this.toSeq().map(function(v, k) {
          return mapper.call(context, [k, v], iterations++, this$0);
        }).fromEntrySeq());
      },
      mapKeys: function(mapper, context) {
        var this$0 = this;
        return reify(this, this.toSeq().flip().map(function(k, v) {
          return mapper.call(context, k, v, this$0);
        }).flip());
      }
    });
    var KeyedIterablePrototype = KeyedIterable.prototype;
    KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
    KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
    KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
    KeyedIterablePrototype.__toStringMapper = function(v, k) {
      return JSON.stringify(k) + ': ' + quoteString(v);
    };
    mixin(IndexedIterable, {
      toKeyedSeq: function() {
        return new ToKeyedSequence(this, false);
      },
      filter: function(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, false));
      },
      findIndex: function(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[0] : -1;
      },
      indexOf: function(searchValue) {
        var key = this.toKeyedSeq().keyOf(searchValue);
        return key === undefined ? -1 : key;
      },
      lastIndexOf: function(searchValue) {
        return this.toSeq().reverse().indexOf(searchValue);
      },
      reverse: function() {
        return reify(this, reverseFactory(this, false));
      },
      slice: function(begin, end) {
        return reify(this, sliceFactory(this, begin, end, false));
      },
      splice: function(index, removeNum) {
        var numArgs = arguments.length;
        removeNum = Math.max(removeNum | 0, 0);
        if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
          return this;
        }
        index = resolveBegin(index, this.size);
        var spliced = this.slice(0, index);
        return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
      },
      findLastIndex: function(predicate, context) {
        var key = this.toKeyedSeq().findLastKey(predicate, context);
        return key === undefined ? -1 : key;
      },
      first: function() {
        return this.get(0);
      },
      flatten: function(depth) {
        return reify(this, flattenFactory(this, depth, false));
      },
      get: function(index, notSetValue) {
        index = wrapIndex(this, index);
        return (index < 0 || (this.size === Infinity || (this.size !== undefined && index > this.size))) ? notSetValue : this.find(function(_, key) {
          return key === index;
        }, undefined, notSetValue);
      },
      has: function(index) {
        index = wrapIndex(this, index);
        return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
      },
      interpose: function(separator) {
        return reify(this, interposeFactory(this, separator));
      },
      interleave: function() {
        var iterables = [this].concat(arrCopy(arguments));
        var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
        var interleaved = zipped.flatten(true);
        if (zipped.size) {
          interleaved.size = zipped.size * iterables.length;
        }
        return reify(this, interleaved);
      },
      last: function() {
        return this.get(-1);
      },
      skipWhile: function(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, false));
      },
      zip: function() {
        var iterables = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, iterables));
      },
      zipWith: function(zipper) {
        var iterables = arrCopy(arguments);
        iterables[0] = this;
        return reify(this, zipWithFactory(this, zipper, iterables));
      }
    });
    IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
    IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
    mixin(SetIterable, {
      get: function(value, notSetValue) {
        return this.has(value) ? value : notSetValue;
      },
      includes: function(value) {
        return this.has(value);
      },
      keySeq: function() {
        return this.valueSeq();
      }
    });
    SetIterable.prototype.has = IterablePrototype.includes;
    mixin(KeyedSeq, KeyedIterable.prototype);
    mixin(IndexedSeq, IndexedIterable.prototype);
    mixin(SetSeq, SetIterable.prototype);
    mixin(KeyedCollection, KeyedIterable.prototype);
    mixin(IndexedCollection, IndexedIterable.prototype);
    mixin(SetCollection, SetIterable.prototype);
    function keyMapper(v, k) {
      return k;
    }
    function entryMapper(v, k) {
      return [k, v];
    }
    function not(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    }
    function neg(predicate) {
      return function() {
        return -predicate.apply(this, arguments);
      };
    }
    function quoteString(value) {
      return typeof value === 'string' ? JSON.stringify(value) : value;
    }
    function defaultZipper() {
      return arrCopy(arguments);
    }
    function defaultNegComparator(a, b) {
      return a < b ? 1 : a > b ? -1 : 0;
    }
    function hashIterable(iterable) {
      if (iterable.size === Infinity) {
        return 0;
      }
      var ordered = isOrdered(iterable);
      var keyed = isKeyed(iterable);
      var h = ordered ? 1 : 0;
      var size = iterable.__iterate(keyed ? ordered ? function(v, k) {
        h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
      } : function(v, k) {
        h = h + hashMerge(hash(v), hash(k)) | 0;
      } : ordered ? function(v) {
        h = 31 * h + hash(v) | 0;
      } : function(v) {
        h = h + hash(v) | 0;
      });
      return murmurHashOfSize(size, h);
    }
    function murmurHashOfSize(size, h) {
      h = src_Math__imul(h, 0xCC9E2D51);
      h = src_Math__imul(h << 15 | h >>> -15, 0x1B873593);
      h = src_Math__imul(h << 13 | h >>> -13, 5);
      h = (h + 0xE6546B64 | 0) ^ size;
      h = src_Math__imul(h ^ h >>> 16, 0x85EBCA6B);
      h = src_Math__imul(h ^ h >>> 13, 0xC2B2AE35);
      h = smi(h ^ h >>> 16);
      return h;
    }
    function hashMerge(a, b) {
      return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0;
    }
    var Immutable = {
      Iterable: Iterable,
      Seq: Seq,
      Collection: Collection,
      Map: src_Map__Map,
      OrderedMap: OrderedMap,
      List: List,
      Stack: Stack,
      Set: src_Set__Set,
      OrderedSet: OrderedSet,
      Record: Record,
      Range: Range,
      Repeat: Repeat,
      is: is,
      fromJS: fromJS
    };
    return Immutable;
  }));
  global.define = __define;
  return module.exports;
});



System.register("npm:immutable@3.7.2/contrib/cursor", ["immutable"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var Immutable = require('immutable');
  var Iterable = Immutable.Iterable;
  var Iterator = Iterable.Iterator;
  var Seq = Immutable.Seq;
  var Map = Immutable.Map;
  function cursorFrom(rootData, keyPath, onChange) {
    if (arguments.length === 1) {
      keyPath = [];
    } else if (typeof keyPath === 'function') {
      onChange = keyPath;
      keyPath = [];
    } else {
      keyPath = valToKeyPath(keyPath);
    }
    return makeCursor(rootData, keyPath, onChange);
  }
  var KeyedCursorPrototype = Object.create(Seq.Keyed.prototype);
  var IndexedCursorPrototype = Object.create(Seq.Indexed.prototype);
  function KeyedCursor(rootData, keyPath, onChange, size) {
    this.size = size;
    this._rootData = rootData;
    this._keyPath = keyPath;
    this._onChange = onChange;
  }
  KeyedCursorPrototype.constructor = KeyedCursor;
  function IndexedCursor(rootData, keyPath, onChange, size) {
    this.size = size;
    this._rootData = rootData;
    this._keyPath = keyPath;
    this._onChange = onChange;
  }
  IndexedCursorPrototype.constructor = IndexedCursor;
  KeyedCursorPrototype.toString = function() {
    return this.__toString('Cursor {', '}');
  };
  IndexedCursorPrototype.toString = function() {
    return this.__toString('Cursor [', ']');
  };
  KeyedCursorPrototype.deref = KeyedCursorPrototype.valueOf = IndexedCursorPrototype.deref = IndexedCursorPrototype.valueOf = function(notSetValue) {
    return this._rootData.getIn(this._keyPath, notSetValue);
  };
  KeyedCursorPrototype.get = IndexedCursorPrototype.get = function(key, notSetValue) {
    return this.getIn([key], notSetValue);
  };
  KeyedCursorPrototype.getIn = IndexedCursorPrototype.getIn = function(keyPath, notSetValue) {
    keyPath = listToKeyPath(keyPath);
    if (keyPath.length === 0) {
      return this;
    }
    var value = this._rootData.getIn(newKeyPath(this._keyPath, keyPath), NOT_SET);
    return value === NOT_SET ? notSetValue : wrappedValue(this, keyPath, value);
  };
  IndexedCursorPrototype.set = KeyedCursorPrototype.set = function(key, value) {
    return updateCursor(this, function(m) {
      return m.set(key, value);
    }, [key]);
  };
  IndexedCursorPrototype.push = function() {
    var args = arguments;
    return updateCursor(this, function(m) {
      return m.push.apply(m, args);
    });
  };
  IndexedCursorPrototype.pop = function() {
    return updateCursor(this, function(m) {
      return m.pop();
    });
  };
  IndexedCursorPrototype.unshift = function() {
    var args = arguments;
    return updateCursor(this, function(m) {
      return m.unshift.apply(m, args);
    });
  };
  IndexedCursorPrototype.shift = function() {
    return updateCursor(this, function(m) {
      return m.shift();
    });
  };
  IndexedCursorPrototype.setIn = KeyedCursorPrototype.setIn = Map.prototype.setIn;
  KeyedCursorPrototype.remove = KeyedCursorPrototype['delete'] = IndexedCursorPrototype.remove = IndexedCursorPrototype['delete'] = function(key) {
    return updateCursor(this, function(m) {
      return m.remove(key);
    }, [key]);
  };
  IndexedCursorPrototype.removeIn = IndexedCursorPrototype.deleteIn = KeyedCursorPrototype.removeIn = KeyedCursorPrototype.deleteIn = Map.prototype.deleteIn;
  KeyedCursorPrototype.clear = IndexedCursorPrototype.clear = function() {
    return updateCursor(this, function(m) {
      return m.clear();
    });
  };
  IndexedCursorPrototype.update = KeyedCursorPrototype.update = function(keyOrFn, notSetValue, updater) {
    return arguments.length === 1 ? updateCursor(this, keyOrFn) : this.updateIn([keyOrFn], notSetValue, updater);
  };
  IndexedCursorPrototype.updateIn = KeyedCursorPrototype.updateIn = function(keyPath, notSetValue, updater) {
    return updateCursor(this, function(m) {
      return m.updateIn(keyPath, notSetValue, updater);
    }, keyPath);
  };
  IndexedCursorPrototype.merge = KeyedCursorPrototype.merge = function() {
    var args = arguments;
    return updateCursor(this, function(m) {
      return m.merge.apply(m, args);
    });
  };
  IndexedCursorPrototype.mergeWith = KeyedCursorPrototype.mergeWith = function(merger) {
    var args = arguments;
    return updateCursor(this, function(m) {
      return m.mergeWith.apply(m, args);
    });
  };
  IndexedCursorPrototype.mergeIn = KeyedCursorPrototype.mergeIn = Map.prototype.mergeIn;
  IndexedCursorPrototype.mergeDeep = KeyedCursorPrototype.mergeDeep = function() {
    var args = arguments;
    return updateCursor(this, function(m) {
      return m.mergeDeep.apply(m, args);
    });
  };
  IndexedCursorPrototype.mergeDeepWith = KeyedCursorPrototype.mergeDeepWith = function(merger) {
    var args = arguments;
    return updateCursor(this, function(m) {
      return m.mergeDeepWith.apply(m, args);
    });
  };
  IndexedCursorPrototype.mergeDeepIn = KeyedCursorPrototype.mergeDeepIn = Map.prototype.mergeDeepIn;
  KeyedCursorPrototype.withMutations = IndexedCursorPrototype.withMutations = function(fn) {
    return updateCursor(this, function(m) {
      return (m || Map()).withMutations(fn);
    });
  };
  KeyedCursorPrototype.cursor = IndexedCursorPrototype.cursor = function(subKeyPath) {
    subKeyPath = valToKeyPath(subKeyPath);
    return subKeyPath.length === 0 ? this : subCursor(this, subKeyPath);
  };
  KeyedCursorPrototype.__iterate = IndexedCursorPrototype.__iterate = function(fn, reverse) {
    var cursor = this;
    var deref = cursor.deref();
    return deref && deref.__iterate ? deref.__iterate(function(v, k) {
      return fn(wrappedValue(cursor, [k], v), k, cursor);
    }, reverse) : 0;
  };
  KeyedCursorPrototype.__iterator = IndexedCursorPrototype.__iterator = function(type, reverse) {
    var deref = this.deref();
    var cursor = this;
    var iterator = deref && deref.__iterator && deref.__iterator(Iterator.ENTRIES, reverse);
    return new Iterator(function() {
      if (!iterator) {
        return {
          value: undefined,
          done: true
        };
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = wrappedValue(cursor, [k], entry[1]);
      return {
        value: type === Iterator.KEYS ? k : type === Iterator.VALUES ? v : [k, v],
        done: false
      };
    });
  };
  KeyedCursor.prototype = KeyedCursorPrototype;
  IndexedCursor.prototype = IndexedCursorPrototype;
  var NOT_SET = {};
  function makeCursor(rootData, keyPath, onChange, value) {
    if (arguments.length < 4) {
      value = rootData.getIn(keyPath);
    }
    var size = value && value.size;
    var CursorClass = Iterable.isIndexed(value) ? IndexedCursor : KeyedCursor;
    return new CursorClass(rootData, keyPath, onChange, size);
  }
  function wrappedValue(cursor, keyPath, value) {
    return Iterable.isIterable(value) ? subCursor(cursor, keyPath, value) : value;
  }
  function subCursor(cursor, keyPath, value) {
    if (arguments.length < 3) {
      return makeCursor(cursor._rootData, newKeyPath(cursor._keyPath, keyPath), cursor._onChange);
    }
    return makeCursor(cursor._rootData, newKeyPath(cursor._keyPath, keyPath), cursor._onChange, value);
  }
  function updateCursor(cursor, changeFn, changeKeyPath) {
    var deepChange = arguments.length > 2;
    var newRootData = cursor._rootData.updateIn(cursor._keyPath, deepChange ? Map() : undefined, changeFn);
    var keyPath = cursor._keyPath || [];
    var result = cursor._onChange && cursor._onChange.call(undefined, newRootData, cursor._rootData, deepChange ? newKeyPath(keyPath, changeKeyPath) : keyPath);
    if (result !== undefined) {
      newRootData = result;
    }
    return makeCursor(newRootData, cursor._keyPath, cursor._onChange);
  }
  function newKeyPath(head, tail) {
    return head.concat(listToKeyPath(tail));
  }
  function listToKeyPath(list) {
    return Array.isArray(list) ? list : Immutable.Iterable(list).toArray();
  }
  function valToKeyPath(val) {
    return Array.isArray(val) ? val : Iterable.isIterable(val) ? val.toArray() : [val];
  }
  exports.from = cursorFrom;
  global.define = __define;
  return module.exports;
});



System.register("npm:eventemitter3@0.1.6/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function EventEmitter() {}
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype.listeners = function listeners(event) {
    if (!this._events || !this._events[event])
      return [];
    if (this._events[event].fn)
      return [this._events[event].fn];
    for (var i = 0,
        l = this._events[event].length,
        ee = new Array(l); i < l; i++) {
      ee[i] = this._events[event][i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    if (!this._events || !this._events[event])
      return false;
    var listeners = this._events[event],
        len = arguments.length,
        args,
        i;
    if ('function' === typeof listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length,
          j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    var listener = new EE(fn, context || this);
    if (!this._events)
      this._events = {};
    if (!this._events[event])
      this._events[event] = listener;
    else {
      if (!this._events[event].fn)
        this._events[event].push(listener);
      else
        this._events[event] = [this._events[event], listener];
    }
    return this;
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    var listener = new EE(fn, context || this, true);
    if (!this._events)
      this._events = {};
    if (!this._events[event])
      this._events[event] = listener;
    else {
      if (!this._events[event].fn)
        this._events[event].push(listener);
      else
        this._events[event] = [this._events[event], listener];
    }
    return this;
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, once) {
    if (!this._events || !this._events[event])
      return this;
    var listeners = this._events[event],
        events = [];
    if (fn) {
      if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {
        events.push(listeners);
      }
      if (!listeners.fn)
        for (var i = 0,
            length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || (once && !listeners[i].once)) {
            events.push(listeners[i]);
          }
        }
    }
    if (events.length) {
      this._events[event] = events.length === 1 ? events[0] : events;
    } else {
      delete this._events[event];
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    if (!this._events)
      return this;
    if (event)
      delete this._events[event];
    else
      this._events = {};
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
    return this;
  };
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.EventEmitter2 = EventEmitter;
  EventEmitter.EventEmitter3 = EventEmitter;
  module.exports = EventEmitter;
  global.define = __define;
  return module.exports;
});



System.register("npm:inherits@2.0.1/inherits_browser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  if (typeof Object.create === 'function') {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }});
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  global.define = __define;
  return module.exports;
});



System.register("npm:immstruct@1.4.0/src/utils", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports.generateRandomKey = function(len) {
    len = len || 10;
    return Math.random().toString(36).substring(2).substring(0, len);
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:deep-equal@0.2.2/lib/keys", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;
  exports.shim = shim;
  function shim(obj) {
    var keys = [];
    for (var key in obj)
      keys.push(key);
    return keys;
  }
  global.define = __define;
  return module.exports;
});



System.register("npm:deep-equal@0.2.2/lib/is_arguments", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var supportsArgumentsClass = (function() {
    return Object.prototype.toString.call(arguments);
  })() == '[object Arguments]';
  exports = module.exports = supportsArgumentsClass ? supported : unsupported;
  exports.supported = supported;
  function supported(object) {
    return Object.prototype.toString.call(object) == '[object Arguments]';
  }
  ;
  exports.unsupported = unsupported;
  function unsupported(object) {
    return object && typeof object == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
  }
  ;
  global.define = __define;
  return module.exports;
});



System.register("lib/components/tangle-text.jsx!github:floatdrop/plugin-jsx@0.1.1", ["react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require('react');
  var TangleText = React.createClass({
    displayName: "TangleText",
    propTypes: {
      value: React.PropTypes.number.isRequired,
      onChange: React.PropTypes.func.isRequired,
      min: React.PropTypes.number,
      max: React.PropTypes.number,
      step: React.PropTypes.number,
      className: React.PropTypes.string,
      onInput: React.PropTypes.func,
      format: React.PropTypes.func,
      size: React.PropTypes.number
    },
    getDefaultProps: function() {
      return {
        min: -Infinity,
        max: Infinity,
        step: 1,
        className: 'react-tangle-input-old',
        format: function(x) {
          return x;
        },
        onInput: function() {}
      };
    },
    componentWillMount: function() {
      this.__isMouseDown = false;
    },
    componentWillReceiveProps: function(nextProps) {
      this.setState({value: nextProps.value});
    },
    getInitialState: function() {
      return {value: this.props.value};
    },
    bounds: function(num) {
      num = Math.max(num, this.props.min);
      num = Math.min(num, this.props.max);
      return num;
    },
    onChange: function(e) {
      this.setState({value: e.target.value});
    },
    onBlur: function(e) {
      var parsed = parseFloat(this.state.value);
      if (isNaN(parsed)) {
        this.setState({value: this.props.value});
      } else {
        this.props.onChange(this.bounds(parsed));
        this.setState({value: this.bounds(parsed)});
      }
    },
    onMouseMove: function(e) {
      var change = this.startX - e.screenX;
      this.dragged = true;
      var value = this.bounds(this.startValue - (change * this.props.step));
      this.setState({value: value});
      this.props.onInput(value);
    },
    onMouseDown: function(e) {
      if (e.target === document.activeElement || e.button !== 0)
        return;
      this.__isMouseDown = true;
      e.preventDefault();
      this.dragged = false;
      this.startX = e.screenX;
      this.startValue = this.state.value;
      window.addEventListener('mousemove', this.onMouseMove);
      window.addEventListener('mouseup', this.onMouseUp);
    },
    onMouseUp: function(e) {
      if (this.__isMouseDown) {
        e.preventDefault();
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('mouseup', this.onMouseUp);
        if (this.dragged)
          this.onBlur();
        this.__isMouseDown = false;
      }
    },
    onDoubleClick: function(e) {
      e.target.focus();
    },
    onKeyDown: function(e) {
      var value;
      if (e.which == 38) {
        e.preventDefault();
        value = this.state.value + this.props.step;
        this.setState({value: value});
        this.props.onInput(value);
      } else if (e.which == 40) {
        e.preventDefault();
        value = this.state.value - this.props.step;
        this.setState({value: value});
        this.props.onInput(value);
      } else if (e.which == 13) {
        this.onBlur(e);
        e.target.blur();
      } else {
        console.log('another key pressed.');
      }
    },
    render: function() {
      return (React.createElement("input", {
        className: this.props.className,
        disabled: this.props.disabled,
        type: "text",
        size: this.props.size,
        onChange: this.onChange,
        onMouseDown: this.onMouseDown,
        onKeyDown: this.onKeyDown,
        onMouseUp: this.onMouseUp,
        onDoubleClick: this.onDoubleClick,
        onBlur: this.onBlur,
        onInput: this.props.onInput,
        value: this.props.format(this.state.value)
      }));
    }
  });
  module.exports = TangleText;
  global.define = __define;
  return module.exports;
});



System.register("npm:lodash@2.4.1/dist/lodash", ["process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function() {
      var undefined;
      var arrayPool = [],
          objectPool = [];
      var idCounter = 0;
      var keyPrefix = +new Date + '';
      var largeArraySize = 75;
      var maxPoolSize = 40;
      var whitespace = (' \t\x0B\f\xA0\ufeff' + '\n\r\u2028\u2029' + '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000');
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reFuncName = /^\s*function[ \n\r\t]+\w/;
      var reInterpolate = /<%=([\s\S]+?)%>/g;
      var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
      var reNoMatch = /($^)/;
      var reThis = /\bthis\b/;
      var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
      var contextProps = ['Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object', 'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN', 'parseInt', 'setTimeout'];
      var templateCounter = 0;
      var argsClass = '[object Arguments]',
          arrayClass = '[object Array]',
          boolClass = '[object Boolean]',
          dateClass = '[object Date]',
          funcClass = '[object Function]',
          numberClass = '[object Number]',
          objectClass = '[object Object]',
          regexpClass = '[object RegExp]',
          stringClass = '[object String]';
      var cloneableClasses = {};
      cloneableClasses[funcClass] = false;
      cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
      var debounceOptions = {
        'leading': false,
        'maxWait': 0,
        'trailing': false
      };
      var descriptor = {
        'configurable': false,
        'enumerable': false,
        'value': null,
        'writable': false
      };
      var objectTypes = {
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\t': 't',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var root = (objectTypes[typeof window] && window) || this;
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var freeGlobal = objectTypes[typeof global] && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
      }
      function baseIndexOf(array, value, fromIndex) {
        var index = (fromIndex || 0) - 1,
            length = array ? array.length : 0;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function cacheIndexOf(cache, value) {
        var type = typeof value;
        cache = cache.cache;
        if (type == 'boolean' || value == null) {
          return cache[value] ? 0 : -1;
        }
        if (type != 'number' && type != 'string') {
          type = 'object';
        }
        var key = type == 'number' ? value : keyPrefix + value;
        cache = (cache = cache[type]) && cache[key];
        return type == 'object' ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1) : (cache ? 0 : -1);
      }
      function cachePush(value) {
        var cache = this.cache,
            type = typeof value;
        if (type == 'boolean' || value == null) {
          cache[value] = true;
        } else {
          if (type != 'number' && type != 'string') {
            type = 'object';
          }
          var key = type == 'number' ? value : keyPrefix + value,
              typeCache = cache[type] || (cache[type] = {});
          if (type == 'object') {
            (typeCache[key] || (typeCache[key] = [])).push(value);
          } else {
            typeCache[key] = true;
          }
        }
      }
      function charAtCallback(value) {
        return value.charCodeAt(0);
      }
      function compareAscending(a, b) {
        var ac = a.criteria,
            bc = b.criteria,
            index = -1,
            length = ac.length;
        while (++index < length) {
          var value = ac[index],
              other = bc[index];
          if (value !== other) {
            if (value > other || typeof value == 'undefined') {
              return 1;
            }
            if (value < other || typeof other == 'undefined') {
              return -1;
            }
          }
        }
        return a.index - b.index;
      }
      function createCache(array) {
        var index = -1,
            length = array.length,
            first = array[0],
            mid = array[(length / 2) | 0],
            last = array[length - 1];
        if (first && typeof first == 'object' && mid && typeof mid == 'object' && last && typeof last == 'object') {
          return false;
        }
        var cache = getObject();
        cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
        var result = getObject();
        result.array = array;
        result.cache = cache;
        result.push = cachePush;
        while (++index < length) {
          result.push(array[index]);
        }
        return result;
      }
      function escapeStringChar(match) {
        return '\\' + stringEscapes[match];
      }
      function getArray() {
        return arrayPool.pop() || [];
      }
      function getObject() {
        return objectPool.pop() || {
          'array': null,
          'cache': null,
          'criteria': null,
          'false': false,
          'index': 0,
          'null': false,
          'number': null,
          'object': null,
          'push': null,
          'string': null,
          'true': false,
          'undefined': false,
          'value': null
        };
      }
      function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
          arrayPool.push(array);
        }
      }
      function releaseObject(object) {
        var cache = object.cache;
        if (cache) {
          releaseObject(cache);
        }
        object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
        if (objectPool.length < maxPoolSize) {
          objectPool.push(object);
        }
      }
      function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == 'undefined') {
          end = array ? array.length : 0;
        }
        var index = -1,
            length = end - start || 0,
            result = Array(length < 0 ? 0 : length);
        while (++index < length) {
          result[index] = array[start + index];
        }
        return result;
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array,
            Boolean = context.Boolean,
            Date = context.Date,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
        var arrayRef = [];
        var objectProto = Object.prototype;
        var oldDash = context._;
        var toString = objectProto.toString;
        var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
        var ceil = Math.ceil,
            clearTimeout = context.clearTimeout,
            floor = Math.floor,
            fnToString = Function.prototype.toString,
            getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
            hasOwnProperty = objectProto.hasOwnProperty,
            push = arrayRef.push,
            setTimeout = context.setTimeout,
            splice = arrayRef.splice,
            unshift = arrayRef.unshift;
        var defineProperty = (function() {
          try {
            var o = {},
                func = isNative(func = Object.defineProperty) && func,
                result = func(o, o, o) && func;
          } catch (e) {}
          return result;
        }());
        var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
            nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
            nativeIsFinite = context.isFinite,
            nativeIsNaN = context.isNaN,
            nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
        var ctorByClass = {};
        ctorByClass[arrayClass] = Array;
        ctorByClass[boolClass] = Boolean;
        ctorByClass[dateClass] = Date;
        ctorByClass[funcClass] = Function;
        ctorByClass[objectClass] = Object;
        ctorByClass[numberClass] = Number;
        ctorByClass[regexpClass] = RegExp;
        ctorByClass[stringClass] = String;
        function lodash(value) {
          return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__')) ? value : new lodashWrapper(value);
        }
        function lodashWrapper(value, chainAll) {
          this.__chain__ = !!chainAll;
          this.__wrapped__ = value;
        }
        lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
        support.funcNames = typeof Function.name == 'string';
        lodash.templateSettings = {
          'escape': /<%-([\s\S]+?)%>/g,
          'evaluate': /<%([\s\S]+?)%>/g,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        function baseBind(bindData) {
          var func = bindData[0],
              partialArgs = bindData[2],
              thisArg = bindData[4];
          function bound() {
            if (partialArgs) {
              var args = slice(partialArgs);
              push.apply(args, arguments);
            }
            if (this instanceof bound) {
              var thisBinding = baseCreate(func.prototype),
                  result = func.apply(thisBinding, args || arguments);
              return isObject(result) ? result : thisBinding;
            }
            return func.apply(thisArg, args || arguments);
          }
          setBindData(bound, bindData);
          return bound;
        }
        function baseClone(value, isDeep, callback, stackA, stackB) {
          if (callback) {
            var result = callback(value);
            if (typeof result != 'undefined') {
              return result;
            }
          }
          var isObj = isObject(value);
          if (isObj) {
            var className = toString.call(value);
            if (!cloneableClasses[className]) {
              return value;
            }
            var ctor = ctorByClass[className];
            switch (className) {
              case boolClass:
              case dateClass:
                return new ctor(+value);
              case numberClass:
              case stringClass:
                return new ctor(value);
              case regexpClass:
                result = ctor(value.source, reFlags.exec(value));
                result.lastIndex = value.lastIndex;
                return result;
            }
          } else {
            return value;
          }
          var isArr = isArray(value);
          if (isDeep) {
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
            var length = stackA.length;
            while (length--) {
              if (stackA[length] == value) {
                return stackB[length];
              }
            }
            result = isArr ? ctor(value.length) : {};
          } else {
            result = isArr ? slice(value) : assign({}, value);
          }
          if (isArr) {
            if (hasOwnProperty.call(value, 'index')) {
              result.index = value.index;
            }
            if (hasOwnProperty.call(value, 'input')) {
              result.input = value.input;
            }
          }
          if (!isDeep) {
            return result;
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? forEach : forOwn)(value, function(objValue, key) {
            result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
          });
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return result;
        }
        function baseCreate(prototype, properties) {
          return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        if (!nativeCreate) {
          baseCreate = (function() {
            function Object() {}
            return function(prototype) {
              if (isObject(prototype)) {
                Object.prototype = prototype;
                var result = new Object;
                Object.prototype = null;
              }
              return result || context.Object();
            };
          }());
        }
        function baseCreateCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (typeof thisArg == 'undefined' || !('prototype' in func)) {
            return func;
          }
          var bindData = func.__bindData__;
          if (typeof bindData == 'undefined') {
            if (support.funcNames) {
              bindData = !func.name;
            }
            bindData = bindData || !support.funcDecomp;
            if (!bindData) {
              var source = fnToString.call(func);
              if (!support.funcNames) {
                bindData = !reFuncName.test(source);
              }
              if (!bindData) {
                bindData = reThis.test(source);
                setBindData(func, bindData);
              }
            }
          }
          if (bindData === false || (bindData !== true && bindData[1] & 1)) {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 2:
              return function(a, b) {
                return func.call(thisArg, a, b);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
          }
          return bind(func, thisArg);
        }
        function baseCreateWrapper(bindData) {
          var func = bindData[0],
              bitmask = bindData[1],
              partialArgs = bindData[2],
              partialRightArgs = bindData[3],
              thisArg = bindData[4],
              arity = bindData[5];
          var isBind = bitmask & 1,
              isBindKey = bitmask & 2,
              isCurry = bitmask & 4,
              isCurryBound = bitmask & 8,
              key = func;
          function bound() {
            var thisBinding = isBind ? thisArg : this;
            if (partialArgs) {
              var args = slice(partialArgs);
              push.apply(args, arguments);
            }
            if (partialRightArgs || isCurry) {
              args || (args = slice(arguments));
              if (partialRightArgs) {
                push.apply(args, partialRightArgs);
              }
              if (isCurry && args.length < arity) {
                bitmask |= 16 & ~32;
                return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
              }
            }
            args || (args = arguments);
            if (isBindKey) {
              func = thisBinding[key];
            }
            if (this instanceof bound) {
              thisBinding = baseCreate(func.prototype);
              var result = func.apply(thisBinding, args);
              return isObject(result) ? result : thisBinding;
            }
            return func.apply(thisBinding, args);
          }
          setBindData(bound, bindData);
          return bound;
        }
        function baseDifference(array, values) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array ? array.length : 0,
              isLarge = length >= largeArraySize && indexOf === baseIndexOf,
              result = [];
          if (isLarge) {
            var cache = createCache(values);
            if (cache) {
              indexOf = cacheIndexOf;
              values = cache;
            } else {
              isLarge = false;
            }
          }
          while (++index < length) {
            var value = array[index];
            if (indexOf(values, value) < 0) {
              result.push(value);
            }
          }
          if (isLarge) {
            releaseObject(values);
          }
          return result;
        }
        function baseFlatten(array, isShallow, isStrict, fromIndex) {
          var index = (fromIndex || 0) - 1,
              length = array ? array.length : 0,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value && typeof value == 'object' && typeof value.length == 'number' && (isArray(value) || isArguments(value))) {
              if (!isShallow) {
                value = baseFlatten(value, isShallow, isStrict);
              }
              var valIndex = -1,
                  valLength = value.length,
                  resIndex = result.length;
              result.length += valLength;
              while (++valIndex < valLength) {
                result[resIndex++] = value[valIndex];
              }
            } else if (!isStrict) {
              result.push(value);
            }
          }
          return result;
        }
        function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
          if (callback) {
            var result = callback(a, b);
            if (typeof result != 'undefined') {
              return !!result;
            }
          }
          if (a === b) {
            return a !== 0 || (1 / a == 1 / b);
          }
          var type = typeof a,
              otherType = typeof b;
          if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
            return false;
          }
          if (a == null || b == null) {
            return a === b;
          }
          var className = toString.call(a),
              otherClass = toString.call(b);
          if (className == argsClass) {
            className = objectClass;
          }
          if (otherClass == argsClass) {
            otherClass = objectClass;
          }
          if (className != otherClass) {
            return false;
          }
          switch (className) {
            case boolClass:
            case dateClass:
              return +a == +b;
            case numberClass:
              return (a != +a) ? b != +b : (a == 0 ? (1 / a == 1 / b) : a == +b);
            case regexpClass:
            case stringClass:
              return a == String(b);
          }
          var isArr = className == arrayClass;
          if (!isArr) {
            var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
                bWrapped = hasOwnProperty.call(b, '__wrapped__');
            if (aWrapped || bWrapped) {
              return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
            }
            if (className != objectClass) {
              return false;
            }
            var ctorA = a.constructor,
                ctorB = b.constructor;
            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
              return false;
            }
          }
          var initedStack = !stackA;
          stackA || (stackA = getArray());
          stackB || (stackB = getArray());
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == a) {
              return stackB[length] == b;
            }
          }
          var size = 0;
          result = true;
          stackA.push(a);
          stackB.push(b);
          if (isArr) {
            length = a.length;
            size = b.length;
            result = size == length;
            if (result || isWhere) {
              while (size--) {
                var index = length,
                    value = b[size];
                if (isWhere) {
                  while (index--) {
                    if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                      break;
                    }
                  }
                } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            }
          } else {
            forIn(b, function(value, key, b) {
              if (hasOwnProperty.call(b, key)) {
                size++;
                return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
              }
            });
            if (result && !isWhere) {
              forIn(a, function(value, key, a) {
                if (hasOwnProperty.call(a, key)) {
                  return (result = --size > -1);
                }
              });
            }
          }
          stackA.pop();
          stackB.pop();
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return result;
        }
        function baseMerge(object, source, callback, stackA, stackB) {
          (isArray(source) ? forEach : forOwn)(source, function(source, key) {
            var found,
                isArr,
                result = source,
                value = object[key];
            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
              var stackLength = stackA.length;
              while (stackLength--) {
                if ((found = stackA[stackLength] == source)) {
                  value = stackB[stackLength];
                  break;
                }
              }
              if (!found) {
                var isShallow;
                if (callback) {
                  result = callback(value, source);
                  if ((isShallow = typeof result != 'undefined')) {
                    value = result;
                  }
                }
                if (!isShallow) {
                  value = isArr ? (isArray(value) ? value : []) : (isPlainObject(value) ? value : {});
                }
                stackA.push(source);
                stackB.push(value);
                if (!isShallow) {
                  baseMerge(value, source, callback, stackA, stackB);
                }
              }
            } else {
              if (callback) {
                result = callback(value, source);
                if (typeof result == 'undefined') {
                  result = source;
                }
              }
              if (typeof result != 'undefined') {
                value = result;
              }
            }
            object[key] = value;
          });
        }
        function baseRandom(min, max) {
          return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseUniq(array, isSorted, callback) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array ? array.length : 0,
              result = [];
          var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
              seen = (callback || isLarge) ? getArray() : result;
          if (isLarge) {
            var cache = createCache(seen);
            indexOf = cacheIndexOf;
            seen = cache;
          }
          while (++index < length) {
            var value = array[index],
                computed = callback ? callback(value, index, array) : value;
            if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
              if (callback || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          if (isLarge) {
            releaseArray(seen.array);
            releaseObject(seen);
          } else if (callback) {
            releaseArray(seen);
          }
          return result;
        }
        function createAggregator(setter) {
          return function(collection, callback, thisArg) {
            var result = {};
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1,
                length = collection ? collection.length : 0;
            if (typeof length == 'number') {
              while (++index < length) {
                var value = collection[index];
                setter(result, value, callback(value, index, collection), collection);
              }
            } else {
              forOwn(collection, function(value, key, collection) {
                setter(result, value, callback(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
          var isBind = bitmask & 1,
              isBindKey = bitmask & 2,
              isCurry = bitmask & 4,
              isCurryBound = bitmask & 8,
              isPartial = bitmask & 16,
              isPartialRight = bitmask & 32;
          if (!isBindKey && !isFunction(func)) {
            throw new TypeError;
          }
          if (isPartial && !partialArgs.length) {
            bitmask &= ~16;
            isPartial = partialArgs = false;
          }
          if (isPartialRight && !partialRightArgs.length) {
            bitmask &= ~32;
            isPartialRight = partialRightArgs = false;
          }
          var bindData = func && func.__bindData__;
          if (bindData && bindData !== true) {
            bindData = slice(bindData);
            if (bindData[2]) {
              bindData[2] = slice(bindData[2]);
            }
            if (bindData[3]) {
              bindData[3] = slice(bindData[3]);
            }
            if (isBind && !(bindData[1] & 1)) {
              bindData[4] = thisArg;
            }
            if (!isBind && bindData[1] & 1) {
              bitmask |= 8;
            }
            if (isCurry && !(bindData[1] & 4)) {
              bindData[5] = arity;
            }
            if (isPartial) {
              push.apply(bindData[2] || (bindData[2] = []), partialArgs);
            }
            if (isPartialRight) {
              unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
            }
            bindData[1] |= bitmask;
            return createWrapper.apply(null, bindData);
          }
          var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
          return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
        }
        function escapeHtmlChar(match) {
          return htmlEscapes[match];
        }
        function getIndexOf() {
          var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
          return result;
        }
        function isNative(value) {
          return typeof value == 'function' && reNative.test(value);
        }
        var setBindData = !defineProperty ? noop : function(func, value) {
          descriptor.value = value;
          defineProperty(func, '__bindData__', descriptor);
        };
        function shimIsPlainObject(value) {
          var ctor,
              result;
          if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
            return false;
          }
          forIn(value, function(value, key) {
            result = key;
          });
          return typeof result == 'undefined' || hasOwnProperty.call(value, result);
        }
        function unescapeHtmlChar(match) {
          return htmlUnescapes[match];
        }
        function isArguments(value) {
          return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == argsClass || false;
        }
        var isArray = nativeIsArray || function(value) {
          return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == arrayClass || false;
        };
        var shimKeys = function(object) {
          var index,
              iterable = object,
              result = [];
          if (!iterable)
            return result;
          if (!(objectTypes[typeof object]))
            return result;
          for (index in iterable) {
            if (hasOwnProperty.call(iterable, index)) {
              result.push(index);
            }
          }
          return result;
        };
        var keys = !nativeKeys ? shimKeys : function(object) {
          if (!isObject(object)) {
            return [];
          }
          return nativeKeys(object);
        };
        var htmlEscapes = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        };
        var htmlUnescapes = invert(htmlEscapes);
        var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
            reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
        var assign = function(object, source, guard) {
          var index,
              iterable = object,
              result = iterable;
          if (!iterable)
            return result;
          var args = arguments,
              argsIndex = 0,
              argsLength = typeof guard == 'number' ? 2 : args.length;
          if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
          } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
            callback = args[--argsLength];
          }
          while (++argsIndex < argsLength) {
            iterable = args[argsIndex];
            if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1,
                  ownProps = objectTypes[typeof iterable] && keys(iterable),
                  length = ownProps ? ownProps.length : 0;
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
              }
            }
          }
          return result;
        };
        function clone(value, isDeep, callback, thisArg) {
          if (typeof isDeep != 'boolean' && isDeep != null) {
            thisArg = callback;
            callback = isDeep;
            isDeep = false;
          }
          return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
        }
        function cloneDeep(value, callback, thisArg) {
          return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
        }
        function create(prototype, properties) {
          var result = baseCreate(prototype);
          return properties ? assign(result, properties) : result;
        }
        var defaults = function(object, source, guard) {
          var index,
              iterable = object,
              result = iterable;
          if (!iterable)
            return result;
          var args = arguments,
              argsIndex = 0,
              argsLength = typeof guard == 'number' ? 2 : args.length;
          while (++argsIndex < argsLength) {
            iterable = args[argsIndex];
            if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1,
                  ownProps = objectTypes[typeof iterable] && keys(iterable),
                  length = ownProps ? ownProps.length : 0;
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                if (typeof result[index] == 'undefined')
                  result[index] = iterable[index];
              }
            }
          }
          return result;
        };
        function findKey(object, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg, 3);
          forOwn(object, function(value, key, object) {
            if (callback(value, key, object)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function findLastKey(object, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg, 3);
          forOwnRight(object, function(value, key, object) {
            if (callback(value, key, object)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        var forIn = function(collection, callback, thisArg) {
          var index,
              iterable = collection,
              result = iterable;
          if (!iterable)
            return result;
          if (!objectTypes[typeof iterable])
            return result;
          callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
          for (index in iterable) {
            if (callback(iterable[index], index, collection) === false)
              return result;
          }
          return result;
        };
        function forInRight(object, callback, thisArg) {
          var pairs = [];
          forIn(object, function(value, key) {
            pairs.push(key, value);
          });
          var length = pairs.length;
          callback = baseCreateCallback(callback, thisArg, 3);
          while (length--) {
            if (callback(pairs[length--], pairs[length], object) === false) {
              break;
            }
          }
          return object;
        }
        var forOwn = function(collection, callback, thisArg) {
          var index,
              iterable = collection,
              result = iterable;
          if (!iterable)
            return result;
          if (!objectTypes[typeof iterable])
            return result;
          callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
          var ownIndex = -1,
              ownProps = objectTypes[typeof iterable] && keys(iterable),
              length = ownProps ? ownProps.length : 0;
          while (++ownIndex < length) {
            index = ownProps[ownIndex];
            if (callback(iterable[index], index, collection) === false)
              return result;
          }
          return result;
        };
        function forOwnRight(object, callback, thisArg) {
          var props = keys(object),
              length = props.length;
          callback = baseCreateCallback(callback, thisArg, 3);
          while (length--) {
            var key = props[length];
            if (callback(object[key], key, object) === false) {
              break;
            }
          }
          return object;
        }
        function functions(object) {
          var result = [];
          forIn(object, function(value, key) {
            if (isFunction(value)) {
              result.push(key);
            }
          });
          return result.sort();
        }
        function has(object, key) {
          return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index];
            result[object[key]] = key;
          }
          return result;
        }
        function isBoolean(value) {
          return value === true || value === false || value && typeof value == 'object' && toString.call(value) == boolClass || false;
        }
        function isDate(value) {
          return value && typeof value == 'object' && toString.call(value) == dateClass || false;
        }
        function isElement(value) {
          return value && value.nodeType === 1 || false;
        }
        function isEmpty(value) {
          var result = true;
          if (!value) {
            return result;
          }
          var className = toString.call(value),
              length = value.length;
          if ((className == arrayClass || className == stringClass || className == argsClass) || (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
            return !length;
          }
          forOwn(value, function() {
            return (result = false);
          });
          return result;
        }
        function isEqual(a, b, callback, thisArg) {
          return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
        }
        function isFinite(value) {
          return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        function isFunction(value) {
          return typeof value == 'function';
        }
        function isObject(value) {
          return !!(value && objectTypes[typeof value]);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || value && typeof value == 'object' && toString.call(value) == numberClass || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
          if (!(value && toString.call(value) == objectClass)) {
            return false;
          }
          var valueOf = value.valueOf,
              objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
          return objProto ? (value == objProto || getPrototypeOf(value) == objProto) : shimIsPlainObject(value);
        };
        function isRegExp(value) {
          return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
        }
        function isString(value) {
          return typeof value == 'string' || value && typeof value == 'object' && toString.call(value) == stringClass || false;
        }
        function isUndefined(value) {
          return typeof value == 'undefined';
        }
        function mapValues(object, callback, thisArg) {
          var result = {};
          callback = lodash.createCallback(callback, thisArg, 3);
          forOwn(object, function(value, key, object) {
            result[key] = callback(value, key, object);
          });
          return result;
        }
        function merge(object) {
          var args = arguments,
              length = 2;
          if (!isObject(object)) {
            return object;
          }
          if (typeof args[2] != 'number') {
            length = args.length;
          }
          if (length > 3 && typeof args[length - 2] == 'function') {
            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
          } else if (length > 2 && typeof args[length - 1] == 'function') {
            callback = args[--length];
          }
          var sources = slice(arguments, 1, length),
              index = -1,
              stackA = getArray(),
              stackB = getArray();
          while (++index < length) {
            baseMerge(object, sources[index], callback, stackA, stackB);
          }
          releaseArray(stackA);
          releaseArray(stackB);
          return object;
        }
        function omit(object, callback, thisArg) {
          var result = {};
          if (typeof callback != 'function') {
            var props = [];
            forIn(object, function(value, key) {
              props.push(key);
            });
            props = baseDifference(props, baseFlatten(arguments, true, false, 1));
            var index = -1,
                length = props.length;
            while (++index < length) {
              var key = props[index];
              result[key] = object[key];
            }
          } else {
            callback = lodash.createCallback(callback, thisArg, 3);
            forIn(object, function(value, key, object) {
              if (!callback(value, key, object)) {
                result[key] = value;
              }
            });
          }
          return result;
        }
        function pairs(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
        function pick(object, callback, thisArg) {
          var result = {};
          if (typeof callback != 'function') {
            var index = -1,
                props = baseFlatten(arguments, true, false, 1),
                length = isObject(object) ? props.length : 0;
            while (++index < length) {
              var key = props[index];
              if (key in object) {
                result[key] = object[key];
              }
            }
          } else {
            callback = lodash.createCallback(callback, thisArg, 3);
            forIn(object, function(value, key, object) {
              if (callback(value, key, object)) {
                result[key] = value;
              }
            });
          }
          return result;
        }
        function transform(object, callback, accumulator, thisArg) {
          var isArr = isArray(object);
          if (accumulator == null) {
            if (isArr) {
              accumulator = [];
            } else {
              var ctor = object && object.constructor,
                  proto = ctor && ctor.prototype;
              accumulator = baseCreate(proto);
            }
          }
          if (callback) {
            callback = lodash.createCallback(callback, thisArg, 4);
            (isArr ? forEach : forOwn)(object, function(value, index, object) {
              return callback(accumulator, value, index, object);
            });
          }
          return accumulator;
        }
        function values(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function at(collection) {
          var args = arguments,
              index = -1,
              props = baseFlatten(args, true, false, 1),
              length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = collection[props[index]];
          }
          return result;
        }
        function contains(collection, target, fromIndex) {
          var index = -1,
              indexOf = getIndexOf(),
              length = collection ? collection.length : 0,
              result = false;
          fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
          if (isArray(collection)) {
            result = indexOf(collection, target, fromIndex) > -1;
          } else if (typeof length == 'number') {
            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
          } else {
            forOwn(collection, function(value) {
              if (++index >= fromIndex) {
                return !(result = value === target);
              }
            });
          }
          return result;
        }
        var countBy = createAggregator(function(result, value, key) {
          (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
        });
        function every(collection, callback, thisArg) {
          var result = true;
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1,
              length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              if (!(result = !!callback(collection[index], index, collection))) {
                break;
              }
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              return (result = !!callback(value, index, collection));
            });
          }
          return result;
        }
        function filter(collection, callback, thisArg) {
          var result = [];
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1,
              length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                result.push(value);
              }
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              if (callback(value, index, collection)) {
                result.push(value);
              }
            });
          }
          return result;
        }
        function find(collection, callback, thisArg) {
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1,
              length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                return value;
              }
            }
          } else {
            var result;
            forOwn(collection, function(value, index, collection) {
              if (callback(value, index, collection)) {
                result = value;
                return false;
              }
            });
            return result;
          }
        }
        function findLast(collection, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg, 3);
          forEachRight(collection, function(value, index, collection) {
            if (callback(value, index, collection)) {
              result = value;
              return false;
            }
          });
          return result;
        }
        function forEach(collection, callback, thisArg) {
          var index = -1,
              length = collection ? collection.length : 0;
          callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
          if (typeof length == 'number') {
            while (++index < length) {
              if (callback(collection[index], index, collection) === false) {
                break;
              }
            }
          } else {
            forOwn(collection, callback);
          }
          return collection;
        }
        function forEachRight(collection, callback, thisArg) {
          var length = collection ? collection.length : 0;
          callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
          if (typeof length == 'number') {
            while (length--) {
              if (callback(collection[length], length, collection) === false) {
                break;
              }
            }
          } else {
            var props = keys(collection);
            length = props.length;
            forOwn(collection, function(value, key, collection) {
              key = props ? props[--length] : --length;
              return callback(collection[key], key, collection);
            });
          }
          return collection;
        }
        var groupBy = createAggregator(function(result, value, key) {
          (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
        });
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        function invoke(collection, methodName) {
          var args = slice(arguments, 2),
              index = -1,
              isFunc = typeof methodName == 'function',
              length = collection ? collection.length : 0,
              result = Array(typeof length == 'number' ? length : 0);
          forEach(collection, function(value) {
            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
          });
          return result;
        }
        function map(collection, callback, thisArg) {
          var index = -1,
              length = collection ? collection.length : 0;
          callback = lodash.createCallback(callback, thisArg, 3);
          if (typeof length == 'number') {
            var result = Array(length);
            while (++index < length) {
              result[index] = callback(collection[index], index, collection);
            }
          } else {
            result = [];
            forOwn(collection, function(value, key, collection) {
              result[++index] = callback(value, key, collection);
            });
          }
          return result;
        }
        function max(collection, callback, thisArg) {
          var computed = -Infinity,
              result = computed;
          if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
            callback = null;
          }
          if (callback == null && isArray(collection)) {
            var index = -1,
                length = collection.length;
            while (++index < length) {
              var value = collection[index];
              if (value > result) {
                result = value;
              }
            }
          } else {
            callback = (callback == null && isString(collection)) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
            forEach(collection, function(value, index, collection) {
              var current = callback(value, index, collection);
              if (current > computed) {
                computed = current;
                result = value;
              }
            });
          }
          return result;
        }
        function min(collection, callback, thisArg) {
          var computed = Infinity,
              result = computed;
          if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
            callback = null;
          }
          if (callback == null && isArray(collection)) {
            var index = -1,
                length = collection.length;
            while (++index < length) {
              var value = collection[index];
              if (value < result) {
                result = value;
              }
            }
          } else {
            callback = (callback == null && isString(collection)) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
            forEach(collection, function(value, index, collection) {
              var current = callback(value, index, collection);
              if (current < computed) {
                computed = current;
                result = value;
              }
            });
          }
          return result;
        }
        var pluck = map;
        function reduce(collection, callback, accumulator, thisArg) {
          if (!collection)
            return accumulator;
          var noaccum = arguments.length < 3;
          callback = lodash.createCallback(callback, thisArg, 4);
          var index = -1,
              length = collection.length;
          if (typeof length == 'number') {
            if (noaccum) {
              accumulator = collection[++index];
            }
            while (++index < length) {
              accumulator = callback(accumulator, collection[index], index, collection);
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
            });
          }
          return accumulator;
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
          var noaccum = arguments.length < 3;
          callback = lodash.createCallback(callback, thisArg, 4);
          forEachRight(collection, function(value, index, collection) {
            accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
          });
          return accumulator;
        }
        function reject(collection, callback, thisArg) {
          callback = lodash.createCallback(callback, thisArg, 3);
          return filter(collection, function(value, index, collection) {
            return !callback(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (collection && typeof collection.length != 'number') {
            collection = values(collection);
          }
          if (n == null || guard) {
            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
          }
          var result = shuffle(collection);
          result.length = nativeMin(nativeMax(0, n), result.length);
          return result;
        }
        function shuffle(collection) {
          var index = -1,
              length = collection ? collection.length : 0,
              result = Array(typeof length == 'number' ? length : 0);
          forEach(collection, function(value) {
            var rand = baseRandom(0, ++index);
            result[index] = result[rand];
            result[rand] = value;
          });
          return result;
        }
        function size(collection) {
          var length = collection ? collection.length : 0;
          return typeof length == 'number' ? length : keys(collection).length;
        }
        function some(collection, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1,
              length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              if ((result = callback(collection[index], index, collection))) {
                break;
              }
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              return !(result = callback(value, index, collection));
            });
          }
          return !!result;
        }
        function sortBy(collection, callback, thisArg) {
          var index = -1,
              isArr = isArray(callback),
              length = collection ? collection.length : 0,
              result = Array(typeof length == 'number' ? length : 0);
          if (!isArr) {
            callback = lodash.createCallback(callback, thisArg, 3);
          }
          forEach(collection, function(value, key, collection) {
            var object = result[++index] = getObject();
            if (isArr) {
              object.criteria = map(callback, function(key) {
                return value[key];
              });
            } else {
              (object.criteria = getArray())[0] = callback(value, key, collection);
            }
            object.index = index;
            object.value = value;
          });
          length = result.length;
          result.sort(compareAscending);
          while (length--) {
            var object = result[length];
            result[length] = object.value;
            if (!isArr) {
              releaseArray(object.criteria);
            }
            releaseObject(object);
          }
          return result;
        }
        function toArray(collection) {
          if (collection && typeof collection.length == 'number') {
            return slice(collection);
          }
          return values(collection);
        }
        var where = filter;
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result.push(value);
            }
          }
          return result;
        }
        function difference(array) {
          return baseDifference(array, baseFlatten(arguments, true, true, 1));
        }
        function findIndex(array, callback, thisArg) {
          var index = -1,
              length = array ? array.length : 0;
          callback = lodash.createCallback(callback, thisArg, 3);
          while (++index < length) {
            if (callback(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function findLastIndex(array, callback, thisArg) {
          var length = array ? array.length : 0;
          callback = lodash.createCallback(callback, thisArg, 3);
          while (length--) {
            if (callback(array[length], length, array)) {
              return length;
            }
          }
          return -1;
        }
        function first(array, callback, thisArg) {
          var n = 0,
              length = array ? array.length : 0;
          if (typeof callback != 'number' && callback != null) {
            var index = -1;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback;
            if (n == null || thisArg) {
              return array ? array[0] : undefined;
            }
          }
          return slice(array, 0, nativeMin(nativeMax(0, n), length));
        }
        function flatten(array, isShallow, callback, thisArg) {
          if (typeof isShallow != 'boolean' && isShallow != null) {
            thisArg = callback;
            callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
            isShallow = false;
          }
          if (callback != null) {
            array = map(array, callback, thisArg);
          }
          return baseFlatten(array, isShallow);
        }
        function indexOf(array, value, fromIndex) {
          if (typeof fromIndex == 'number') {
            var length = array ? array.length : 0;
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
          } else if (fromIndex) {
            var index = sortedIndex(array, value);
            return array[index] === value ? index : -1;
          }
          return baseIndexOf(array, value, fromIndex);
        }
        function initial(array, callback, thisArg) {
          var n = 0,
              length = array ? array.length : 0;
          if (typeof callback != 'number' && callback != null) {
            var index = length;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (index-- && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = (callback == null || thisArg) ? 1 : callback || n;
          }
          return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        function intersection() {
          var args = [],
              argsIndex = -1,
              argsLength = arguments.length,
              caches = getArray(),
              indexOf = getIndexOf(),
              trustIndexOf = indexOf === baseIndexOf,
              seen = getArray();
          while (++argsIndex < argsLength) {
            var value = arguments[argsIndex];
            if (isArray(value) || isArguments(value)) {
              args.push(value);
              caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
            }
          }
          var array = args[0],
              index = -1,
              length = array ? array.length : 0,
              result = [];
          outer: while (++index < length) {
            var cache = caches[0];
            value = array[index];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
              argsIndex = argsLength;
              (cache || seen).push(value);
              while (--argsIndex) {
                cache = caches[argsIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                  continue outer;
                }
              }
              result.push(value);
            }
          }
          while (argsLength--) {
            cache = caches[argsLength];
            if (cache) {
              releaseObject(cache);
            }
          }
          releaseArray(caches);
          releaseArray(seen);
          return result;
        }
        function last(array, callback, thisArg) {
          var n = 0,
              length = array ? array.length : 0;
          if (typeof callback != 'number' && callback != null) {
            var index = length;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (index-- && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback;
            if (n == null || thisArg) {
              return array ? array[length - 1] : undefined;
            }
          }
          return slice(array, nativeMax(0, length - n));
        }
        function lastIndexOf(array, value, fromIndex) {
          var index = array ? array.length : 0;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull(array) {
          var args = arguments,
              argsIndex = 0,
              argsLength = args.length,
              length = array ? array.length : 0;
          while (++argsIndex < argsLength) {
            var index = -1,
                value = args[argsIndex];
            while (++index < length) {
              if (array[index] === value) {
                splice.call(array, index--, 1);
                length--;
              }
            }
          }
          return array;
        }
        function range(start, end, step) {
          start = +start || 0;
          step = typeof step == 'number' ? step : (+step || 1);
          if (end == null) {
            end = start;
            start = 0;
          }
          var index = -1,
              length = nativeMax(0, ceil((end - start) / (step || 1))),
              result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function remove(array, callback, thisArg) {
          var index = -1,
              length = array ? array.length : 0,
              result = [];
          callback = lodash.createCallback(callback, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (callback(value, index, array)) {
              result.push(value);
              splice.call(array, index--, 1);
              length--;
            }
          }
          return result;
        }
        function rest(array, callback, thisArg) {
          if (typeof callback != 'number' && callback != null) {
            var n = 0,
                index = -1,
                length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
          }
          return slice(array, n);
        }
        function sortedIndex(array, value, callback, thisArg) {
          var low = 0,
              high = array ? array.length : low;
          callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
          value = callback(value);
          while (low < high) {
            var mid = (low + high) >>> 1;
            (callback(array[mid]) < value) ? low = mid + 1 : high = mid;
          }
          return low;
        }
        function union() {
          return baseUniq(baseFlatten(arguments, true, true));
        }
        function uniq(array, isSorted, callback, thisArg) {
          if (typeof isSorted != 'boolean' && isSorted != null) {
            thisArg = callback;
            callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
            isSorted = false;
          }
          if (callback != null) {
            callback = lodash.createCallback(callback, thisArg, 3);
          }
          return baseUniq(array, isSorted, callback);
        }
        function without(array) {
          return baseDifference(array, slice(arguments, 1));
        }
        function xor() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArray(array) || isArguments(array)) {
              var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
            }
          }
          return result || [];
        }
        function zip() {
          var array = arguments.length > 1 ? arguments : arguments[0],
              index = -1,
              length = array ? max(pluck(array, 'length')) : 0,
              result = Array(length < 0 ? 0 : length);
          while (++index < length) {
            result[index] = pluck(array, index);
          }
          return result;
        }
        function zipObject(keys, values) {
          var index = -1,
              length = keys ? keys.length : 0,
              result = {};
          if (!values && length && !isArray(keys[0])) {
            values = [];
          }
          while (++index < length) {
            var key = keys[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        function after(n, func) {
          if (!isFunction(func)) {
            throw new TypeError;
          }
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function bind(func, thisArg) {
          return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
        }
        function bindAll(object) {
          var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
              index = -1,
              length = funcs.length;
          while (++index < length) {
            var key = funcs[index];
            object[key] = createWrapper(object[key], 1, null, null, object);
          }
          return object;
        }
        function bindKey(object, key) {
          return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
        }
        function compose() {
          var funcs = arguments,
              length = funcs.length;
          while (length--) {
            if (!isFunction(funcs[length])) {
              throw new TypeError;
            }
          }
          return function() {
            var args = arguments,
                length = funcs.length;
            while (length--) {
              args = [funcs[length].apply(this, args)];
            }
            return args[0];
          };
        }
        function curry(func, arity) {
          arity = typeof arity == 'number' ? arity : (+arity || func.length);
          return createWrapper(func, 4, null, null, null, arity);
        }
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
          if (!isFunction(func)) {
            throw new TypeError;
          }
          wait = nativeMax(0, wait) || 0;
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = options.leading;
            maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          var delayed = function() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0) {
              if (maxTimeoutId) {
                clearTimeout(maxTimeoutId);
              }
              var isCalled = trailingCall;
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (isCalled) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          };
          var maxDelayed = function() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (trailing || (maxWait !== wait)) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
            }
          };
          return function() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
            return result;
          };
        }
        function defer(func) {
          if (!isFunction(func)) {
            throw new TypeError;
          }
          var args = slice(arguments, 1);
          return setTimeout(function() {
            func.apply(undefined, args);
          }, 1);
        }
        function delay(func, wait) {
          if (!isFunction(func)) {
            throw new TypeError;
          }
          var args = slice(arguments, 2);
          return setTimeout(function() {
            func.apply(undefined, args);
          }, wait);
        }
        function memoize(func, resolver) {
          if (!isFunction(func)) {
            throw new TypeError;
          }
          var memoized = function() {
            var cache = memoized.cache,
                key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
            return hasOwnProperty.call(cache, key) ? cache[key] : (cache[key] = func.apply(this, arguments));
          };
          memoized.cache = {};
          return memoized;
        }
        function once(func) {
          var ran,
              result;
          if (!isFunction(func)) {
            throw new TypeError;
          }
          return function() {
            if (ran) {
              return result;
            }
            ran = true;
            result = func.apply(this, arguments);
            func = null;
            return result;
          };
        }
        function partial(func) {
          return createWrapper(func, 16, slice(arguments, 1));
        }
        function partialRight(func) {
          return createWrapper(func, 32, null, slice(arguments, 1));
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (!isFunction(func)) {
            throw new TypeError;
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? options.leading : leading;
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          debounceOptions.leading = leading;
          debounceOptions.maxWait = wait;
          debounceOptions.trailing = trailing;
          return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
          return createWrapper(wrapper, 16, [value]);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function createCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (func == null || type == 'function') {
            return baseCreateCallback(func, thisArg, argCount);
          }
          if (type != 'object') {
            return property(func);
          }
          var props = keys(func),
              key = props[0],
              a = func[key];
          if (props.length == 1 && a === a && !isObject(a)) {
            return function(object) {
              var b = object[key];
              return a === b && (a !== 0 || (1 / a == 1 / b));
            };
          }
          return function(object) {
            var length = props.length,
                result = false;
            while (length--) {
              if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                break;
              }
            }
            return result;
          };
        }
        function escape(string) {
          return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        function identity(value) {
          return value;
        }
        function mixin(object, source, options) {
          var chain = true,
              methodNames = source && functions(source);
          if (!source || (!options && !methodNames.length)) {
            if (options == null) {
              options = source;
            }
            ctor = lodashWrapper;
            source = object;
            object = lodash;
            methodNames = functions(source);
          }
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          var ctor = object,
              isFunc = isFunction(ctor);
          forEach(methodNames, function(methodName) {
            var func = object[methodName] = source[methodName];
            if (isFunc) {
              ctor.prototype[methodName] = function() {
                var chainAll = this.__chain__,
                    value = this.__wrapped__,
                    args = [value];
                push.apply(args, arguments);
                var result = func.apply(object, args);
                if (chain || chainAll) {
                  if (value === result && isObject(result)) {
                    return this;
                  }
                  result = new ctor(result);
                  result.__chain__ = chainAll;
                }
                return result;
              };
            }
          });
        }
        function noConflict() {
          context._ = oldDash;
          return this;
        }
        function noop() {}
        var now = isNative(now = Date.now) && now || function() {
          return new Date().getTime();
        };
        var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
          return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
        };
        function property(key) {
          return function(object) {
            return object[key];
          };
        }
        function random(min, max, floating) {
          var noMin = min == null,
              noMax = max == null;
          if (floating == null) {
            if (typeof min == 'boolean' && noMax) {
              floating = min;
              min = 1;
            } else if (!noMax && typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
        function result(object, key) {
          if (object) {
            var value = object[key];
            return isFunction(value) ? object[key]() : value;
          }
        }
        function template(text, data, options) {
          var settings = lodash.templateSettings;
          text = String(text || '');
          options = defaults({}, options, settings);
          var imports = defaults({}, options.imports, settings.imports),
              importsKeys = keys(imports),
              importsValues = values(imports);
          var isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable,
              hasVariable = variable;
          if (!hasVariable) {
            variable = 'obj';
            source = 'with (' + variable + ') {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + variable + ') {\n' + (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';
          try {
            var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
          } catch (e) {
            e.source = source;
            throw e;
          }
          if (data) {
            return result(data);
          }
          result.source = source;
          return result;
        }
        function times(n, callback, thisArg) {
          n = (n = +n) > -1 ? n : 0;
          var index = -1,
              result = Array(n);
          callback = baseCreateCallback(callback, thisArg, 1);
          while (++index < n) {
            result[index] = callback(index);
          }
          return result;
        }
        function unescape(string) {
          return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return String(prefix == null ? '' : prefix) + id;
        }
        function chain(value) {
          value = new lodashWrapper(value);
          value.__chain__ = true;
          return value;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function wrapperChain() {
          this.__chain__ = true;
          return this;
        }
        function wrapperToString() {
          return String(this.__wrapped__);
        }
        function wrapperValueOf() {
          return this.__wrapped__;
        }
        lodash.after = after;
        lodash.assign = assign;
        lodash.at = at;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.chain = chain;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.createCallback = createCallback;
        lodash.curry = curry;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.pull = pull;
        lodash.range = range;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        lodash.unzip = zip;
        mixin(lodash);
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
        mixin(function() {
          var source = {};
          forOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }(), false);
        lodash.first = first;
        lodash.last = last;
        lodash.sample = sample;
        lodash.take = first;
        lodash.head = first;
        forOwn(lodash, function(func, methodName) {
          var callbackable = methodName !== 'sample';
          if (!lodash.prototype[methodName]) {
            lodash.prototype[methodName] = function(n, guard) {
              var chainAll = this.__chain__,
                  result = func(this.__wrapped__, n, guard);
              return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function'))) ? result : new lodashWrapper(result, chainAll);
            };
          }
        });
        lodash.VERSION = '2.4.1';
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.value = wrapperValueOf;
        lodash.prototype.valueOf = wrapperValueOf;
        forEach(['join', 'pop', 'shift'], function(methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                result = func.apply(this.__wrapped__, arguments);
            return chainAll ? new lodashWrapper(result, chainAll) : result;
          };
        });
        forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function() {
            func.apply(this.__wrapped__, arguments);
            return this;
          };
        });
        forEach(['concat', 'slice', 'splice'], function(methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function() {
            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
          };
        });
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:d3@3.5.5/d3", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    "format global";
    "exports d3";
    !function() {
      var d3 = {version: "3.5.5"};
      var d3_arraySlice = [].slice,
          d3_array = function(list) {
            return d3_arraySlice.call(list);
          };
      var d3_document = this.document;
      function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
      }
      function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
      }
      if (d3_document) {
        try {
          d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        } catch (e) {
          d3_array = function(list) {
            var i = list.length,
                array = new Array(i);
            while (i--)
              array[i] = list[i];
            return array;
          };
        }
      }
      if (!Date.now)
        Date.now = function() {
          return +new Date();
        };
      if (d3_document) {
        try {
          d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
        } catch (error) {
          var d3_element_prototype = this.Element.prototype,
              d3_element_setAttribute = d3_element_prototype.setAttribute,
              d3_element_setAttributeNS = d3_element_prototype.setAttributeNS,
              d3_style_prototype = this.CSSStyleDeclaration.prototype,
              d3_style_setProperty = d3_style_prototype.setProperty;
          d3_element_prototype.setAttribute = function(name, value) {
            d3_element_setAttribute.call(this, name, value + "");
          };
          d3_element_prototype.setAttributeNS = function(space, local, value) {
            d3_element_setAttributeNS.call(this, space, local, value + "");
          };
          d3_style_prototype.setProperty = function(name, value, priority) {
            d3_style_setProperty.call(this, name, value + "", priority);
          };
        }
      }
      d3.ascending = d3_ascending;
      function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      d3.descending = function(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
      };
      d3.min = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null && a > b)
              a = b;
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && a > b)
              a = b;
        }
        return a;
      };
      d3.max = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null && b > a)
              a = b;
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b > a)
              a = b;
        }
        return a;
      };
      d3.extent = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b,
            c;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = c = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null) {
              if (a > b)
                a = b;
              if (c < b)
                c = b;
            }
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = c = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null) {
              if (a > b)
                a = b;
              if (c < b)
                c = b;
            }
        }
        return [a, c];
      };
      function d3_number(x) {
        return x === null ? NaN : +x;
      }
      function d3_numeric(x) {
        return !isNaN(x);
      }
      d3.sum = function(array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = +array[i]))
              s += a;
        } else {
          while (++i < n)
            if (d3_numeric(a = +f.call(array, array[i], i)))
              s += a;
        }
        return s;
      };
      d3.mean = function(array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1,
            j = n;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = d3_number(array[i])))
              s += a;
            else
              --j;
        } else {
          while (++i < n)
            if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
              s += a;
            else
              --j;
        }
        if (j)
          return s / j;
      };
      d3.quantile = function(values, p) {
        var H = (values.length - 1) * p + 1,
            h = Math.floor(H),
            v = +values[h - 1],
            e = H - h;
        return e ? v + e * (values[h] - v) : v;
      };
      d3.median = function(array, f) {
        var numbers = [],
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = d3_number(array[i])))
              numbers.push(a);
        } else {
          while (++i < n)
            if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
              numbers.push(a);
        }
        if (numbers.length)
          return d3.quantile(numbers.sort(d3_ascending), .5);
      };
      d3.variance = function(array, f) {
        var n = array.length,
            m = 0,
            a,
            d,
            s = 0,
            i = -1,
            j = 0;
        if (arguments.length === 1) {
          while (++i < n) {
            if (d3_numeric(a = d3_number(array[i]))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        } else {
          while (++i < n) {
            if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        }
        if (j > 1)
          return s / (j - 1);
      };
      d3.deviation = function() {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
      };
      function d3_bisector(compare) {
        return {
          left: function(a, x, lo, hi) {
            if (arguments.length < 3)
              lo = 0;
            if (arguments.length < 4)
              hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) < 0)
                lo = mid + 1;
              else
                hi = mid;
            }
            return lo;
          },
          right: function(a, x, lo, hi) {
            if (arguments.length < 3)
              lo = 0;
            if (arguments.length < 4)
              hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) > 0)
                hi = mid;
              else
                lo = mid + 1;
            }
            return lo;
          }
        };
      }
      var d3_bisect = d3_bisector(d3_ascending);
      d3.bisectLeft = d3_bisect.left;
      d3.bisect = d3.bisectRight = d3_bisect.right;
      d3.bisector = function(f) {
        return d3_bisector(f.length === 1 ? function(d, x) {
          return d3_ascending(f(d), x);
        } : f);
      };
      d3.shuffle = function(array, i0, i1) {
        if ((m = arguments.length) < 3) {
          i1 = array.length;
          if (m < 2)
            i0 = 0;
        }
        var m = i1 - i0,
            t,
            i;
        while (m) {
          i = Math.random() * m-- | 0;
          t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
      };
      d3.permute = function(array, indexes) {
        var i = indexes.length,
            permutes = new Array(i);
        while (i--)
          permutes[i] = array[indexes[i]];
        return permutes;
      };
      d3.pairs = function(array) {
        var i = 0,
            n = array.length - 1,
            p0,
            p1 = array[0],
            pairs = new Array(n < 0 ? 0 : n);
        while (i < n)
          pairs[i] = [p0 = p1, p1 = array[++i]];
        return pairs;
      };
      d3.zip = function() {
        if (!(n = arguments.length))
          return [];
        for (var i = -1,
            m = d3.min(arguments, d3_zipLength),
            zips = new Array(m); ++i < m; ) {
          for (var j = -1,
              n,
              zip = zips[i] = new Array(n); ++j < n; ) {
            zip[j] = arguments[j][i];
          }
        }
        return zips;
      };
      function d3_zipLength(d) {
        return d.length;
      }
      d3.transpose = function(matrix) {
        return d3.zip.apply(d3, matrix);
      };
      d3.keys = function(map) {
        var keys = [];
        for (var key in map)
          keys.push(key);
        return keys;
      };
      d3.values = function(map) {
        var values = [];
        for (var key in map)
          values.push(map[key]);
        return values;
      };
      d3.entries = function(map) {
        var entries = [];
        for (var key in map)
          entries.push({
            key: key,
            value: map[key]
          });
        return entries;
      };
      d3.merge = function(arrays) {
        var n = arrays.length,
            m,
            i = -1,
            j = 0,
            merged,
            array;
        while (++i < n)
          j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
          array = arrays[n];
          m = array.length;
          while (--m >= 0) {
            merged[--j] = array[m];
          }
        }
        return merged;
      };
      var abs = Math.abs;
      d3.range = function(start, stop, step) {
        if (arguments.length < 3) {
          step = 1;
          if (arguments.length < 2) {
            stop = start;
            start = 0;
          }
        }
        if ((stop - start) / step === Infinity)
          throw new Error("infinite range");
        var range = [],
            k = d3_range_integerScale(abs(step)),
            i = -1,
            j;
        start *= k, stop *= k, step *= k;
        if (step < 0)
          while ((j = start + step * ++i) > stop)
            range.push(j / k);
        else
          while ((j = start + step * ++i) < stop)
            range.push(j / k);
        return range;
      };
      function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1)
          k *= 10;
        return k;
      }
      function d3_class(ctor, properties) {
        for (var key in properties) {
          Object.defineProperty(ctor.prototype, key, {
            value: properties[key],
            enumerable: false
          });
        }
      }
      d3.map = function(object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
          object.forEach(function(key, value) {
            map.set(key, value);
          });
        } else if (Array.isArray(object)) {
          var i = -1,
              n = object.length,
              o;
          if (arguments.length === 1)
            while (++i < n)
              map.set(i, object[i]);
          else
            while (++i < n)
              map.set(f.call(object, o = object[i], i), o);
        } else {
          for (var key in object)
            map.set(key, object[key]);
        }
        return map;
      };
      function d3_Map() {
        this._ = Object.create(null);
      }
      var d3_map_proto = "__proto__",
          d3_map_zero = "\x00";
      d3_class(d3_Map, {
        has: d3_map_has,
        get: function(key) {
          return this._[d3_map_escape(key)];
        },
        set: function(key, value) {
          return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function() {
          var values = [];
          for (var key in this._)
            values.push(this._[key]);
          return values;
        },
        entries: function() {
          var entries = [];
          for (var key in this._)
            entries.push({
              key: d3_map_unescape(key),
              value: this._[key]
            });
          return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
          for (var key in this._)
            f.call(this, d3_map_unescape(key), this._[key]);
        }
      });
      function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
      }
      function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
      }
      function d3_map_has(key) {
        return d3_map_escape(key) in this._;
      }
      function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
      }
      function d3_map_keys() {
        var keys = [];
        for (var key in this._)
          keys.push(d3_map_unescape(key));
        return keys;
      }
      function d3_map_size() {
        var size = 0;
        for (var key in this._)
          ++size;
        return size;
      }
      function d3_map_empty() {
        for (var key in this._)
          return false;
        return true;
      }
      d3.nest = function() {
        var nest = {},
            keys = [],
            sortKeys = [],
            sortValues,
            rollup;
        function map(mapType, array, depth) {
          if (depth >= keys.length)
            return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
          var i = -1,
              n = array.length,
              key = keys[depth++],
              keyValue,
              object,
              setter,
              valuesByKey = new d3_Map(),
              values;
          while (++i < n) {
            if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
              values.push(object);
            } else {
              valuesByKey.set(keyValue, [object]);
            }
          }
          if (mapType) {
            object = mapType();
            setter = function(keyValue, values) {
              object.set(keyValue, map(mapType, values, depth));
            };
          } else {
            object = {};
            setter = function(keyValue, values) {
              object[keyValue] = map(mapType, values, depth);
            };
          }
          valuesByKey.forEach(setter);
          return object;
        }
        function entries(map, depth) {
          if (depth >= keys.length)
            return map;
          var array = [],
              sortKey = sortKeys[depth++];
          map.forEach(function(key, keyMap) {
            array.push({
              key: key,
              values: entries(keyMap, depth)
            });
          });
          return sortKey ? array.sort(function(a, b) {
            return sortKey(a.key, b.key);
          }) : array;
        }
        nest.map = function(array, mapType) {
          return map(mapType, array, 0);
        };
        nest.entries = function(array) {
          return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function(d) {
          keys.push(d);
          return nest;
        };
        nest.sortKeys = function(order) {
          sortKeys[keys.length - 1] = order;
          return nest;
        };
        nest.sortValues = function(order) {
          sortValues = order;
          return nest;
        };
        nest.rollup = function(f) {
          rollup = f;
          return nest;
        };
        return nest;
      };
      d3.set = function(array) {
        var set = new d3_Set();
        if (array)
          for (var i = 0,
              n = array.length; i < n; ++i)
            set.add(array[i]);
        return set;
      };
      function d3_Set() {
        this._ = Object.create(null);
      }
      d3_class(d3_Set, {
        has: d3_map_has,
        add: function(key) {
          this._[d3_map_escape(key += "")] = true;
          return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
          for (var key in this._)
            f.call(this, d3_map_unescape(key));
        }
      });
      d3.behavior = {};
      function d3_identity(d) {
        return d;
      }
      d3.rebind = function(target, source) {
        var i = 1,
            n = arguments.length,
            method;
        while (++i < n)
          target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
      };
      function d3_rebind(target, source, method) {
        return function() {
          var value = method.apply(source, arguments);
          return value === source ? target : value;
        };
      }
      function d3_vendorSymbol(object, name) {
        if (name in object)
          return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0,
            n = d3_vendorPrefixes.length; i < n; ++i) {
          var prefixName = d3_vendorPrefixes[i] + name;
          if (prefixName in object)
            return prefixName;
        }
      }
      var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
      function d3_noop() {}
      d3.dispatch = function() {
        var dispatch = new d3_dispatch(),
            i = -1,
            n = arguments.length;
        while (++i < n)
          dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
      };
      function d3_dispatch() {}
      d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf("."),
            name = "";
        if (i >= 0) {
          name = type.slice(i + 1);
          type = type.slice(0, i);
        }
        if (type)
          return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
          if (listener == null)
            for (type in this) {
              if (this.hasOwnProperty(type))
                this[type].on(name, null);
            }
          return this;
        }
      };
      function d3_dispatch_event(dispatch) {
        var listeners = [],
            listenerByName = new d3_Map();
        function event() {
          var z = listeners,
              i = -1,
              n = z.length,
              l;
          while (++i < n)
            if (l = z[i].on)
              l.apply(this, arguments);
          return dispatch;
        }
        event.on = function(name, listener) {
          var l = listenerByName.get(name),
              i;
          if (arguments.length < 2)
            return l && l.on;
          if (l) {
            l.on = null;
            listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
            listenerByName.remove(name);
          }
          if (listener)
            listeners.push(listenerByName.set(name, {on: listener}));
          return dispatch;
        };
        return event;
      }
      d3.event = null;
      function d3_eventPreventDefault() {
        d3.event.preventDefault();
      }
      function d3_eventSource() {
        var e = d3.event,
            s;
        while (s = e.sourceEvent)
          e = s;
        return e;
      }
      function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(),
            i = 0,
            n = arguments.length;
        while (++i < n)
          dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function(thiz, argumentz) {
          return function(e1) {
            try {
              var e0 = e1.sourceEvent = d3.event;
              e1.target = target;
              d3.event = e1;
              dispatch[e1.type].apply(thiz, argumentz);
            } finally {
              d3.event = e0;
            }
          };
        };
        return dispatch;
      }
      d3.requote = function(s) {
        return s.replace(d3_requote_re, "\\$&");
      };
      var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      var d3_subclass = {}.__proto__ ? function(object, prototype) {
        object.__proto__ = prototype;
      } : function(object, prototype) {
        for (var property in prototype)
          object[property] = prototype[property];
      };
      function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
      }
      var d3_select = function(s, n) {
        return n.querySelector(s);
      },
          d3_selectAll = function(s, n) {
            return n.querySelectorAll(s);
          },
          d3_selectMatches = function(n, s) {
            var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
            d3_selectMatches = function(n, s) {
              return d3_selectMatcher.call(n, s);
            };
            return d3_selectMatches(n, s);
          };
      if (typeof Sizzle === "function") {
        d3_select = function(s, n) {
          return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
      }
      d3.selection = function() {
        return d3.select(d3_document.documentElement);
      };
      var d3_selectionPrototype = d3.selection.prototype = [];
      d3_selectionPrototype.select = function(selector) {
        var subgroups = [],
            subgroup,
            subnode,
            group,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroup.push(subnode = selector.call(node, node.__data__, i, j));
              if (subnode && "__data__" in node)
                subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function() {
          return d3_select(selector, this);
        };
      }
      d3_selectionPrototype.selectAll = function(selector) {
        var subgroups = [],
            subgroup,
            node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
              subgroup.parentNode = node;
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function() {
          return d3_selectAll(selector, this);
        };
      }
      var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: "http://www.w3.org/1999/xhtml",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
      d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function(name) {
          var i = name.indexOf(":"),
              prefix = name;
          if (i >= 0) {
            prefix = name.slice(0, i);
            name = name.slice(i + 1);
          }
          return d3_nsPrefix.hasOwnProperty(prefix) ? {
            space: d3_nsPrefix[prefix],
            local: name
          } : name;
        }
      };
      d3_selectionPrototype.attr = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node();
            name = d3.ns.qualify(name);
            return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
          }
          for (value in name)
            this.each(d3_selection_attr(value, name[value]));
          return this;
        }
        return this.each(d3_selection_attr(name, value));
      };
      function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
          this.setAttribute(name, value);
        }
        function attrConstantNS() {
          this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.removeAttribute(name);
          else
            this.setAttribute(name, x);
        }
        function attrFunctionNS() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.removeAttributeNS(name.space, name.local);
          else
            this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
      }
      function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
      }
      d3_selectionPrototype.classed = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node(),
                n = (name = d3_selection_classes(name)).length,
                i = -1;
            if (value = node.classList) {
              while (++i < n)
                if (!value.contains(name[i]))
                  return false;
            } else {
              value = node.getAttribute("class");
              while (++i < n)
                if (!d3_selection_classedRe(name[i]).test(value))
                  return false;
            }
            return true;
          }
          for (value in name)
            this.each(d3_selection_classed(value, name[value]));
          return this;
        }
        return this.each(d3_selection_classed(name, value));
      };
      function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
      }
      function d3_selection_classes(name) {
        return (name + "").trim().split(/^|\s+/);
      }
      function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
          var i = -1;
          while (++i < n)
            name[i](this, value);
        }
        function classedFunction() {
          var i = -1,
              x = value.apply(this, arguments);
          while (++i < n)
            name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
      }
      function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function(node, value) {
          if (c = node.classList)
            return value ? c.add(name) : c.remove(name);
          var c = node.getAttribute("class") || "";
          if (value) {
            re.lastIndex = 0;
            if (!re.test(c))
              node.setAttribute("class", d3_collapse(c + " " + name));
          } else {
            node.setAttribute("class", d3_collapse(c.replace(re, " ")));
          }
        };
      }
      d3_selectionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2)
              value = "";
            for (priority in name)
              this.each(d3_selection_style(priority, name[priority], value));
            return this;
          }
          if (n < 2) {
            var node = this.node();
            return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
          }
          priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
      };
      function d3_selection_style(name, value, priority) {
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleConstant() {
          this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.style.removeProperty(name);
          else
            this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
      }
      d3_selectionPrototype.property = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string")
            return this.node()[name];
          for (value in name)
            this.each(d3_selection_property(value, name[value]));
          return this;
        }
        return this.each(d3_selection_property(name, value));
      };
      function d3_selection_property(name, value) {
        function propertyNull() {
          delete this[name];
        }
        function propertyConstant() {
          this[name] = value;
        }
        function propertyFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            delete this[name];
          else
            this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
      }
      d3_selectionPrototype.text = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
          var v = value.apply(this, arguments);
          this.textContent = v == null ? "" : v;
        } : value == null ? function() {
          this.textContent = "";
        } : function() {
          this.textContent = value;
        }) : this.node().textContent;
      };
      d3_selectionPrototype.html = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
          var v = value.apply(this, arguments);
          this.innerHTML = v == null ? "" : v;
        } : value == null ? function() {
          this.innerHTML = "";
        } : function() {
          this.innerHTML = value;
        }) : this.node().innerHTML;
      };
      d3_selectionPrototype.append = function(name) {
        name = d3_selection_creator(name);
        return this.select(function() {
          return this.appendChild(name.apply(this, arguments));
        });
      };
      function d3_selection_creator(name) {
        function create() {
          var document = this.ownerDocument,
              namespace = this.namespaceURI;
          return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
        }
        function createNS() {
          return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
      }
      d3_selectionPrototype.insert = function(name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function() {
          return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
      };
      d3_selectionPrototype.remove = function() {
        return this.each(d3_selectionRemove);
      };
      function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent)
          parent.removeChild(this);
      }
      d3_selectionPrototype.data = function(value, key) {
        var i = -1,
            n = this.length,
            group,
            node;
        if (!arguments.length) {
          value = new Array(n = (group = this[0]).length);
          while (++i < n) {
            if (node = group[i]) {
              value[i] = node.__data__;
            }
          }
          return value;
        }
        function bind(group, groupData) {
          var i,
              n = group.length,
              m = groupData.length,
              n0 = Math.min(n, m),
              updateNodes = new Array(m),
              enterNodes = new Array(m),
              exitNodes = new Array(n),
              node,
              nodeData;
          if (key) {
            var nodeByKeyValue = new d3_Map(),
                keyValues = new Array(n),
                keyValue;
            for (i = -1; ++i < n; ) {
              if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
                exitNodes[i] = node;
              } else {
                nodeByKeyValue.set(keyValue, node);
              }
              keyValues[i] = keyValue;
            }
            for (i = -1; ++i < m; ) {
              if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              } else if (node !== true) {
                updateNodes[i] = node;
                node.__data__ = nodeData;
              }
              nodeByKeyValue.set(keyValue, true);
            }
            for (i = -1; ++i < n; ) {
              if (nodeByKeyValue.get(keyValues[i]) !== true) {
                exitNodes[i] = group[i];
              }
            }
          } else {
            for (i = -1; ++i < n0; ) {
              node = group[i];
              nodeData = groupData[i];
              if (node) {
                node.__data__ = nodeData;
                updateNodes[i] = node;
              } else {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              }
            }
            for (; i < m; ++i) {
              enterNodes[i] = d3_selection_dataNode(groupData[i]);
            }
            for (; i < n; ++i) {
              exitNodes[i] = group[i];
            }
          }
          enterNodes.update = updateNodes;
          enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
          enter.push(enterNodes);
          update.push(updateNodes);
          exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]),
            update = d3_selection([]),
            exit = d3_selection([]);
        if (typeof value === "function") {
          while (++i < n) {
            bind(group = this[i], value.call(group, group.parentNode.__data__, i));
          }
        } else {
          while (++i < n) {
            bind(group = this[i], value);
          }
        }
        update.enter = function() {
          return enter;
        };
        update.exit = function() {
          return exit;
        };
        return update;
      };
      function d3_selection_dataNode(data) {
        return {__data__: data};
      }
      d3_selectionPrototype.datum = function(value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
      };
      d3_selectionPrototype.filter = function(filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function")
          filter = d3_selection_filter(filter);
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = 0,
              n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_filter(selector) {
        return function() {
          return d3_selectMatches(this, selector);
        };
      }
      d3_selectionPrototype.order = function() {
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = group.length - 1,
              next = group[i],
              node; --i >= 0; ) {
            if (node = group[i]) {
              if (next && next !== node.nextSibling)
                next.parentNode.insertBefore(node, next);
              next = node;
            }
          }
        }
        return this;
      };
      d3_selectionPrototype.sort = function(comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1,
            m = this.length; ++j < m; )
          this[j].sort(comparator);
        return this.order();
      };
      function d3_selection_sortComparator(comparator) {
        if (!arguments.length)
          comparator = d3_ascending;
        return function(a, b) {
          return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
      }
      d3_selectionPrototype.each = function(callback) {
        return d3_selection_each(this, function(node, i, j) {
          callback.call(node, node.__data__, i, j);
        });
      };
      function d3_selection_each(groups, callback) {
        for (var j = 0,
            m = groups.length; j < m; j++) {
          for (var group = groups[j],
              i = 0,
              n = group.length,
              node; i < n; i++) {
            if (node = group[i])
              callback(node, i, j);
          }
        }
        return groups;
      }
      d3_selectionPrototype.call = function(callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
      };
      d3_selectionPrototype.empty = function() {
        return !this.node();
      };
      d3_selectionPrototype.node = function() {
        for (var j = 0,
            m = this.length; j < m; j++) {
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            var node = group[i];
            if (node)
              return node;
          }
        }
        return null;
      };
      d3_selectionPrototype.size = function() {
        var n = 0;
        d3_selection_each(this, function() {
          ++n;
        });
        return n;
      };
      function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
      }
      var d3_selection_enterPrototype = [];
      d3.selection.enter = d3_selection_enter;
      d3.selection.enter.prototype = d3_selection_enterPrototype;
      d3_selection_enterPrototype.append = d3_selectionPrototype.append;
      d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
      d3_selection_enterPrototype.node = d3_selectionPrototype.node;
      d3_selection_enterPrototype.call = d3_selectionPrototype.call;
      d3_selection_enterPrototype.size = d3_selectionPrototype.size;
      d3_selection_enterPrototype.select = function(selector) {
        var subgroups = [],
            subgroup,
            subnode,
            upgroup,
            group,
            node;
        for (var j = -1,
            m = this.length; ++j < m; ) {
          upgroup = (group = this[j]).update;
          subgroups.push(subgroup = []);
          subgroup.parentNode = group.parentNode;
          for (var i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
              subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      d3_selection_enterPrototype.insert = function(name, before) {
        if (arguments.length < 2)
          before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
      };
      function d3_selection_enterInsertBefore(enter) {
        var i0,
            j0;
        return function(d, i, j) {
          var group = enter[j].update,
              n = group.length,
              node;
          if (j != j0)
            j0 = j, i0 = 0;
          if (i >= i0)
            i0 = i + 1;
          while (!(node = group[i0]) && ++i0 < n)
            ;
          return node;
        };
      }
      d3.select = function(node) {
        var group;
        if (typeof node === "string") {
          group = [d3_select(node, d3_document)];
          group.parentNode = d3_document.documentElement;
        } else {
          group = [node];
          group.parentNode = d3_documentElement(node);
        }
        return d3_selection([group]);
      };
      d3.selectAll = function(nodes) {
        var group;
        if (typeof nodes === "string") {
          group = d3_array(d3_selectAll(nodes, d3_document));
          group.parentNode = d3_document.documentElement;
        } else {
          group = nodes;
          group.parentNode = null;
        }
        return d3_selection([group]);
      };
      d3_selectionPrototype.on = function(type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof type !== "string") {
            if (n < 2)
              listener = false;
            for (capture in type)
              this.each(d3_selection_on(capture, type[capture], listener));
            return this;
          }
          if (n < 2)
            return (n = this.node()["__on" + type]) && n._;
          capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
      };
      function d3_selection_on(type, listener, capture) {
        var name = "__on" + type,
            i = type.indexOf("."),
            wrap = d3_selection_onListener;
        if (i > 0)
          type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter)
          type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
          var l = this[name];
          if (l) {
            this.removeEventListener(type, l, l.$);
            delete this[name];
          }
        }
        function onAdd() {
          var l = wrap(listener, d3_array(arguments));
          onRemove.call(this);
          this.addEventListener(type, this[name] = l, l.$ = capture);
          l._ = listener;
        }
        function removeAll() {
          var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"),
              match;
          for (var name in this) {
            if (match = name.match(re)) {
              var l = this[name];
              this.removeEventListener(match[1], l, l.$);
              delete this[name];
            }
          }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
      }
      var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
      });
      if (d3_document) {
        d3_selection_onFilters.forEach(function(k) {
          if ("on" + k in d3_document)
            d3_selection_onFilters.remove(k);
        });
      }
      function d3_selection_onListener(listener, argumentz) {
        return function(e) {
          var o = d3.event;
          d3.event = e;
          argumentz[0] = this.__data__;
          try {
            listener.apply(this, argumentz);
          } finally {
            d3.event = o;
          }
        };
      }
      function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function(e) {
          var target = this,
              related = e.relatedTarget;
          if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
            l.call(target, e);
          }
        };
      }
      var d3_event_dragSelect,
          d3_event_dragId = 0;
      function d3_event_dragSuppress(node) {
        var name = ".dragsuppress-" + ++d3_event_dragId,
            click = "click" + name,
            w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
          d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
        }
        if (d3_event_dragSelect) {
          var style = d3_documentElement(node).style,
              select = style[d3_event_dragSelect];
          style[d3_event_dragSelect] = "none";
        }
        return function(suppressClick) {
          w.on(name, null);
          if (d3_event_dragSelect)
            style[d3_event_dragSelect] = select;
          if (suppressClick) {
            var off = function() {
              w.on(click, null);
            };
            w.on(click, function() {
              d3_eventPreventDefault();
              off();
            }, true);
            setTimeout(off, 0);
          }
        };
      }
      d3.mouse = function(container) {
        return d3_mousePoint(container, d3_eventSource());
      };
      var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
      function d3_mousePoint(container, e) {
        if (e.changedTouches)
          e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          if (d3_mouse_bug44083 < 0) {
            var window = d3_window(container);
            if (window.scrollX || window.scrollY) {
              svg = d3.select("body").append("svg").style({
                position: "absolute",
                top: 0,
                left: 0,
                margin: 0,
                padding: 0,
                border: "none"
              }, "important");
              var ctm = svg[0][0].getScreenCTM();
              d3_mouse_bug44083 = !(ctm.f || ctm.e);
              svg.remove();
            }
          }
          if (d3_mouse_bug44083)
            point.x = e.pageX, point.y = e.pageY;
          else
            point.x = e.clientX, point.y = e.clientY;
          point = point.matrixTransform(container.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        var rect = container.getBoundingClientRect();
        return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
      }
      d3.touch = function(container, touches, identifier) {
        if (arguments.length < 3)
          identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches)
          for (var i = 0,
              n = touches.length,
              touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
              return d3_mousePoint(container, touch);
            }
          }
      };
      d3.behavior.drag = function() {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"),
            origin = null,
            mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"),
            touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
        function drag() {
          this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
          return function() {
            var that = this,
                target = d3.event.target,
                parent = that.parentNode,
                dispatch = event.of(that, arguments),
                dragged = 0,
                dragId = id(),
                dragName = ".drag" + (dragId == null ? "" : "-" + dragId),
                dragOffset,
                dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended),
                dragRestore = d3_event_dragSuppress(target),
                position0 = position(parent, dragId);
            if (origin) {
              dragOffset = origin.apply(that, arguments);
              dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
            } else {
              dragOffset = [0, 0];
            }
            dispatch({type: "dragstart"});
            function moved() {
              var position1 = position(parent, dragId),
                  dx,
                  dy;
              if (!position1)
                return;
              dx = position1[0] - position0[0];
              dy = position1[1] - position0[1];
              dragged |= dx | dy;
              position0 = position1;
              dispatch({
                type: "drag",
                x: position1[0] + dragOffset[0],
                y: position1[1] + dragOffset[1],
                dx: dx,
                dy: dy
              });
            }
            function ended() {
              if (!position(parent, dragId))
                return;
              dragSubject.on(move + dragName, null).on(end + dragName, null);
              dragRestore(dragged && d3.event.target === target);
              dispatch({type: "dragend"});
            }
          };
        }
        drag.origin = function(x) {
          if (!arguments.length)
            return origin;
          origin = x;
          return drag;
        };
        return d3.rebind(drag, event, "on");
      };
      function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
      }
      d3.touches = function(container, touches) {
        if (arguments.length < 2)
          touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function(touch) {
          var point = d3_mousePoint(container, touch);
          point.identifier = touch.identifier;
          return point;
        }) : [];
      };
      var ε = 1e-6,
          ε2 = ε * ε,
          π = Math.PI,
          τ = 2 * π,
          τε = τ - ε,
          halfπ = π / 2,
          d3_radians = π / 180,
          d3_degrees = 180 / π;
      function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
      }
      function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
      }
      function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
      }
      function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
      }
      function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
      }
      function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
      }
      function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
      }
      function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
      }
      var ρ = Math.SQRT2,
          ρ2 = 2,
          ρ4 = 4;
      d3.interpolateZoom = function(p0, p1) {
        var ux0 = p0[0],
            uy0 = p0[1],
            w0 = p0[2],
            ux1 = p1[0],
            uy1 = p1[1],
            w1 = p1[2];
        var dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            d1 = Math.sqrt(d2),
            b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1),
            b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1),
            r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
            r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1),
            dr = r1 - r0,
            S = (dr || Math.log(w1 / w0)) / ρ;
        function interpolate(t) {
          var s = t * S;
          if (dr) {
            var coshr0 = d3_cosh(r0),
                u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
            return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0)];
          }
          return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s)];
        }
        interpolate.duration = S * 1e3;
        return interpolate;
      };
      d3.behavior.zoom = function() {
        var view = {
          x: 0,
          y: 0,
          k: 1
        },
            translate0,
            center0,
            center,
            size = [960, 500],
            scaleExtent = d3_behavior_zoomInfinity,
            duration = 250,
            zooming = 0,
            mousedown = "mousedown.zoom",
            mousemove = "mousemove.zoom",
            mouseup = "mouseup.zoom",
            mousewheelTimer,
            touchstart = "touchstart.zoom",
            touchtime,
            event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"),
            x0,
            x1,
            y0,
            y1;
        if (!d3_behavior_zoomWheel) {
          d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
            return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
          }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
            return d3.event.wheelDelta;
          }, "mousewheel") : (d3_behavior_zoomDelta = function() {
            return -d3.event.detail;
          }, "MozMousePixelScroll");
        }
        function zoom(g) {
          g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function(g) {
          g.each(function() {
            var dispatch = event.of(this, arguments),
                view1 = view;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.zoom", function() {
                view = this.__chart__ || {
                  x: 0,
                  y: 0,
                  k: 1
                };
                zoomstarted(dispatch);
              }).tween("zoom:zoom", function() {
                var dx = size[0],
                    dy = size[1],
                    cx = center0 ? center0[0] : dx / 2,
                    cy = center0 ? center0[1] : dy / 2,
                    i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                return function(t) {
                  var l = i(t),
                      k = dx / l[2];
                  this.__chart__ = view = {
                    x: cx - l[0] * k,
                    y: cy - l[1] * k,
                    k: k
                  };
                  zoomed(dispatch);
                };
              }).each("interrupt.zoom", function() {
                zoomended(dispatch);
              }).each("end.zoom", function() {
                zoomended(dispatch);
              });
            } else {
              this.__chart__ = view;
              zoomstarted(dispatch);
              zoomed(dispatch);
              zoomended(dispatch);
            }
          });
        };
        zoom.translate = function(_) {
          if (!arguments.length)
            return [view.x, view.y];
          view = {
            x: +_[0],
            y: +_[1],
            k: view.k
          };
          rescale();
          return zoom;
        };
        zoom.scale = function(_) {
          if (!arguments.length)
            return view.k;
          view = {
            x: view.x,
            y: view.y,
            k: +_
          };
          rescale();
          return zoom;
        };
        zoom.scaleExtent = function(_) {
          if (!arguments.length)
            return scaleExtent;
          scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];
          return zoom;
        };
        zoom.center = function(_) {
          if (!arguments.length)
            return center;
          center = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.size = function(_) {
          if (!arguments.length)
            return size;
          size = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.duration = function(_) {
          if (!arguments.length)
            return duration;
          duration = +_;
          return zoom;
        };
        zoom.x = function(z) {
          if (!arguments.length)
            return x1;
          x1 = z;
          x0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        zoom.y = function(z) {
          if (!arguments.length)
            return y1;
          y1 = z;
          y0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        function location(p) {
          return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
        }
        function point(l) {
          return [l[0] * view.k + view.x, l[1] * view.k + view.y];
        }
        function scaleTo(s) {
          view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
          l = point(l);
          view.x += p[0] - l[0];
          view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
          that.__chart__ = {
            x: view.x,
            y: view.y,
            k: view.k
          };
          scaleTo(Math.pow(2, k));
          translateTo(center0 = p, l);
          that = d3.select(that);
          if (duration > 0)
            that = that.transition().duration(duration);
          that.call(zoom.event);
        }
        function rescale() {
          if (x1)
            x1.domain(x0.range().map(function(x) {
              return (x - view.x) / view.k;
            }).map(x0.invert));
          if (y1)
            y1.domain(y0.range().map(function(y) {
              return (y - view.y) / view.k;
            }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
          if (!zooming++)
            dispatch({type: "zoomstart"});
        }
        function zoomed(dispatch) {
          rescale();
          dispatch({
            type: "zoom",
            scale: view.k,
            translate: [view.x, view.y]
          });
        }
        function zoomended(dispatch) {
          if (!--zooming)
            dispatch({type: "zoomend"});
          center0 = null;
        }
        function mousedowned() {
          var that = this,
              target = d3.event.target,
              dispatch = event.of(that, arguments),
              dragged = 0,
              subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended),
              location0 = location(d3.mouse(that)),
              dragRestore = d3_event_dragSuppress(that);
          d3_selection_interrupt.call(that);
          zoomstarted(dispatch);
          function moved() {
            dragged = 1;
            translateTo(d3.mouse(that), location0);
            zoomed(dispatch);
          }
          function ended() {
            subject.on(mousemove, null).on(mouseup, null);
            dragRestore(dragged && d3.event.target === target);
            zoomended(dispatch);
          }
        }
        function touchstarted() {
          var that = this,
              dispatch = event.of(that, arguments),
              locations0 = {},
              distance0 = 0,
              scale0,
              zoomName = ".zoom-" + d3.event.changedTouches[0].identifier,
              touchmove = "touchmove" + zoomName,
              touchend = "touchend" + zoomName,
              targets = [],
              subject = d3.select(that),
              dragRestore = d3_event_dragSuppress(that);
          started();
          zoomstarted(dispatch);
          subject.on(mousedown, null).on(touchstart, started);
          function relocate() {
            var touches = d3.touches(that);
            scale0 = view.k;
            touches.forEach(function(t) {
              if (t.identifier in locations0)
                locations0[t.identifier] = location(t);
            });
            return touches;
          }
          function started() {
            var target = d3.event.target;
            d3.select(target).on(touchmove, moved).on(touchend, ended);
            targets.push(target);
            var changed = d3.event.changedTouches;
            for (var i = 0,
                n = changed.length; i < n; ++i) {
              locations0[changed[i].identifier] = null;
            }
            var touches = relocate(),
                now = Date.now();
            if (touches.length === 1) {
              if (now - touchtime < 500) {
                var p = touches[0];
                zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                d3_eventPreventDefault();
              }
              touchtime = now;
            } else if (touches.length > 1) {
              var p = touches[0],
                  q = touches[1],
                  dx = p[0] - q[0],
                  dy = p[1] - q[1];
              distance0 = dx * dx + dy * dy;
            }
          }
          function moved() {
            var touches = d3.touches(that),
                p0,
                l0,
                p1,
                l1;
            d3_selection_interrupt.call(that);
            for (var i = 0,
                n = touches.length; i < n; ++i, l1 = null) {
              p1 = touches[i];
              if (l1 = locations0[p1.identifier]) {
                if (l0)
                  break;
                p0 = p1, l0 = l1;
              }
            }
            if (l1) {
              var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1,
                  scale1 = distance0 && Math.sqrt(distance1 / distance0);
              p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
              l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
              scaleTo(scale1 * scale0);
            }
            touchtime = null;
            translateTo(p0, l0);
            zoomed(dispatch);
          }
          function ended() {
            if (d3.event.touches.length) {
              var changed = d3.event.changedTouches;
              for (var i = 0,
                  n = changed.length; i < n; ++i) {
                delete locations0[changed[i].identifier];
              }
              for (var identifier in locations0) {
                return void relocate();
              }
            }
            d3.selectAll(targets).on(zoomName, null);
            subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
            dragRestore();
            zoomended(dispatch);
          }
        }
        function mousewheeled() {
          var dispatch = event.of(this, arguments);
          if (mousewheelTimer)
            clearTimeout(mousewheelTimer);
          else
            translate0 = location(center0 = center || d3.mouse(this)), d3_selection_interrupt.call(this), zoomstarted(dispatch);
          mousewheelTimer = setTimeout(function() {
            mousewheelTimer = null;
            zoomended(dispatch);
          }, 50);
          d3_eventPreventDefault();
          scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
          translateTo(center0, translate0);
          zoomed(dispatch);
        }
        function dblclicked() {
          var p = d3.mouse(this),
              k = Math.log(view.k) / Math.LN2;
          zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, "on");
      };
      var d3_behavior_zoomInfinity = [0, Infinity],
          d3_behavior_zoomDelta,
          d3_behavior_zoomWheel;
      d3.color = d3_color;
      function d3_color() {}
      d3_color.prototype.toString = function() {
        return this.rgb() + "";
      };
      d3.hsl = d3_hsl;
      function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void(this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
      }
      var d3_hslPrototype = d3_hsl.prototype = new d3_color();
      d3_hslPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
      };
      d3_hslPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
      };
      d3_hslPrototype.rgb = function() {
        return d3_hsl_rgb(this.h, this.s, this.l);
      };
      function d3_hsl_rgb(h, s, l) {
        var m1,
            m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
          if (h > 360)
            h -= 360;
          else if (h < 0)
            h += 360;
          if (h < 60)
            return m1 + (m2 - m1) * h / 60;
          if (h < 180)
            return m2;
          if (h < 240)
            return m1 + (m2 - m1) * (240 - h) / 60;
          return m1;
        }
        function vv(h) {
          return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
      }
      d3.hcl = d3_hcl;
      function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void(this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
      }
      var d3_hclPrototype = d3_hcl.prototype = new d3_color();
      d3_hclPrototype.brighter = function(k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.darker = function(k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.rgb = function() {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
      };
      function d3_hcl_lab(h, c, l) {
        if (isNaN(h))
          h = 0;
        if (isNaN(c))
          c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
      }
      d3.lab = d3_lab;
      function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void(this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
      }
      var d3_lab_K = 18;
      var d3_lab_X = .95047,
          d3_lab_Y = 1,
          d3_lab_Z = 1.08883;
      var d3_labPrototype = d3_lab.prototype = new d3_color();
      d3_labPrototype.brighter = function(k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.darker = function(k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.rgb = function() {
        return d3_lab_rgb(this.l, this.a, this.b);
      };
      function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116,
            x = y + a / 500,
            z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
      }
      function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
      }
      function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
      }
      function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
      }
      function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
      }
      d3.rgb = d3_rgb;
      function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void(this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
      }
      function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
      }
      function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
      }
      var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
      d3_rgbPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r,
            g = this.g,
            b = this.b,
            i = 30;
        if (!r && !g && !b)
          return new d3_rgb(i, i, i);
        if (r && r < i)
          r = i;
        if (g && g < i)
          g = i;
        if (b && b < i)
          b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
      };
      d3_rgbPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
      };
      d3_rgbPrototype.hsl = function() {
        return d3_rgb_hsl(this.r, this.g, this.b);
      };
      d3_rgbPrototype.toString = function() {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
      };
      function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
      }
      function d3_rgb_parse(format, rgb, hsl) {
        var r = 0,
            g = 0,
            b = 0,
            m1,
            m2,
            color;
        m1 = /([a-z]+)\((.*)\)/i.exec(format);
        if (m1) {
          m2 = m1[2].split(",");
          switch (m1[1]) {
            case "hsl":
              {
                return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
              }
            case "rgb":
              {
                return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
              }
          }
        }
        if (color = d3_rgb_names.get(format.toLowerCase())) {
          return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
          if (format.length === 4) {
            r = (color & 3840) >> 4;
            r = r >> 4 | r;
            g = color & 240;
            g = g >> 4 | g;
            b = color & 15;
            b = b << 4 | b;
          } else if (format.length === 7) {
            r = (color & 16711680) >> 16;
            g = (color & 65280) >> 8;
            b = color & 255;
          }
        }
        return rgb(r, g, b);
      }
      function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255),
            max = Math.max(r, g, b),
            d = max - min,
            h,
            s,
            l = (max + min) / 2;
        if (d) {
          s = l < .5 ? d / (max + min) : d / (2 - max - min);
          if (r == max)
            h = (g - b) / d + (g < b ? 6 : 0);
          else if (g == max)
            h = (b - r) / d + 2;
          else
            h = (r - g) / d + 4;
          h *= 60;
        } else {
          h = NaN;
          s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
      }
      function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X),
            y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y),
            z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
      }
      function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
      }
      function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
      }
      var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      });
      d3_rgb_names.forEach(function(key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
      });
      function d3_functor(v) {
        return typeof v === "function" ? v : function() {
          return v;
        };
      }
      d3.functor = d3_functor;
      d3.xhr = d3_xhrType(d3_identity);
      function d3_xhrType(response) {
        return function(url, mimeType, callback) {
          if (arguments.length === 2 && typeof mimeType === "function")
            callback = mimeType, mimeType = null;
          return d3_xhr(url, mimeType, response, callback);
        };
      }
      function d3_xhr(url, mimeType, response, callback) {
        var xhr = {},
            dispatch = d3.dispatch("beforesend", "progress", "load", "error"),
            headers = {},
            request = new XMLHttpRequest(),
            responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url))
          request = new XDomainRequest();
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
          request.readyState > 3 && respond();
        };
        function respond() {
          var status = request.status,
              result;
          if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
            try {
              result = response.call(xhr, request);
            } catch (e) {
              dispatch.error.call(xhr, e);
              return;
            }
            dispatch.load.call(xhr, result);
          } else {
            dispatch.error.call(xhr, request);
          }
        }
        request.onprogress = function(event) {
          var o = d3.event;
          d3.event = event;
          try {
            dispatch.progress.call(xhr, request);
          } finally {
            d3.event = o;
          }
        };
        xhr.header = function(name, value) {
          name = (name + "").toLowerCase();
          if (arguments.length < 2)
            return headers[name];
          if (value == null)
            delete headers[name];
          else
            headers[name] = value + "";
          return xhr;
        };
        xhr.mimeType = function(value) {
          if (!arguments.length)
            return mimeType;
          mimeType = value == null ? null : value + "";
          return xhr;
        };
        xhr.responseType = function(value) {
          if (!arguments.length)
            return responseType;
          responseType = value;
          return xhr;
        };
        xhr.response = function(value) {
          response = value;
          return xhr;
        };
        ["get", "post"].forEach(function(method) {
          xhr[method] = function() {
            return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
          };
        });
        xhr.send = function(method, data, callback) {
          if (arguments.length === 2 && typeof data === "function")
            callback = data, data = null;
          request.open(method, url, true);
          if (mimeType != null && !("accept" in headers))
            headers["accept"] = mimeType + ",*/*";
          if (request.setRequestHeader)
            for (var name in headers)
              request.setRequestHeader(name, headers[name]);
          if (mimeType != null && request.overrideMimeType)
            request.overrideMimeType(mimeType);
          if (responseType != null)
            request.responseType = responseType;
          if (callback != null)
            xhr.on("error", callback).on("load", function(request) {
              callback(null, request);
            });
          dispatch.beforesend.call(xhr, request);
          request.send(data == null ? null : data);
          return xhr;
        };
        xhr.abort = function() {
          request.abort();
          return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
      }
      function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
          callback(error == null ? request : null);
        } : callback;
      }
      function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
      }
      d3.dsv = function(delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"),
            delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
          if (arguments.length < 3)
            callback = row, row = null;
          var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
          xhr.row = function(_) {
            return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
          };
          return xhr;
        }
        function response(request) {
          return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
          return function(request) {
            return dsv.parse(request.responseText, f);
          };
        }
        dsv.parse = function(text, f) {
          var o;
          return dsv.parseRows(text, function(row, i) {
            if (o)
              return o(row, i - 1);
            var a = new Function("d", "return {" + row.map(function(name, i) {
              return JSON.stringify(name) + ": d[" + i + "]";
            }).join(",") + "}");
            o = f ? function(row, i) {
              return f(a(row), i);
            } : a;
          });
        };
        dsv.parseRows = function(text, f) {
          var EOL = {},
              EOF = {},
              rows = [],
              N = text.length,
              I = 0,
              n = 0,
              t,
              eol;
          function token() {
            if (I >= N)
              return EOF;
            if (eol)
              return eol = false, EOL;
            var j = I;
            if (text.charCodeAt(j) === 34) {
              var i = j;
              while (i++ < N) {
                if (text.charCodeAt(i) === 34) {
                  if (text.charCodeAt(i + 1) !== 34)
                    break;
                  ++i;
                }
              }
              I = i + 2;
              var c = text.charCodeAt(i + 1);
              if (c === 13) {
                eol = true;
                if (text.charCodeAt(i + 2) === 10)
                  ++I;
              } else if (c === 10) {
                eol = true;
              }
              return text.slice(j + 1, i).replace(/""/g, '"');
            }
            while (I < N) {
              var c = text.charCodeAt(I++),
                  k = 1;
              if (c === 10)
                eol = true;
              else if (c === 13) {
                eol = true;
                if (text.charCodeAt(I) === 10)
                  ++I, ++k;
              } else if (c !== delimiterCode)
                continue;
              return text.slice(j, I - k);
            }
            return text.slice(j);
          }
          while ((t = token()) !== EOF) {
            var a = [];
            while (t !== EOL && t !== EOF) {
              a.push(t);
              t = token();
            }
            if (f && (a = f(a, n++)) == null)
              continue;
            rows.push(a);
          }
          return rows;
        };
        dsv.format = function(rows) {
          if (Array.isArray(rows[0]))
            return dsv.formatRows(rows);
          var fieldSet = new d3_Set(),
              fields = [];
          rows.forEach(function(row) {
            for (var field in row) {
              if (!fieldSet.has(field)) {
                fields.push(fieldSet.add(field));
              }
            }
          });
          return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
            return fields.map(function(field) {
              return formatValue(row[field]);
            }).join(delimiter);
          })).join("\n");
        };
        dsv.formatRows = function(rows) {
          return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
          return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
          return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
      };
      d3.csv = d3.dsv(",", "text/csv");
      d3.tsv = d3.dsv("	", "text/tab-separated-values");
      var d3_timer_queueHead,
          d3_timer_queueTail,
          d3_timer_interval,
          d3_timer_timeout,
          d3_timer_active,
          d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
            setTimeout(callback, 17);
          };
      d3.timer = function(callback, delay, then) {
        var n = arguments.length;
        if (n < 2)
          delay = 0;
        if (n < 3)
          then = Date.now();
        var time = then + delay,
            timer = {
              c: callback,
              t: time,
              f: false,
              n: null
            };
        if (d3_timer_queueTail)
          d3_timer_queueTail.n = timer;
        else
          d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
          d3_timer_timeout = clearTimeout(d3_timer_timeout);
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
      };
      function d3_timer_step() {
        var now = d3_timer_mark(),
            delay = d3_timer_sweep() - now;
        if (delay > 24) {
          if (isFinite(delay)) {
            clearTimeout(d3_timer_timeout);
            d3_timer_timeout = setTimeout(d3_timer_step, delay);
          }
          d3_timer_interval = 0;
        } else {
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
      }
      d3.timer.flush = function() {
        d3_timer_mark();
        d3_timer_sweep();
      };
      function d3_timer_mark() {
        var now = Date.now();
        d3_timer_active = d3_timer_queueHead;
        while (d3_timer_active) {
          if (now >= d3_timer_active.t)
            d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
          d3_timer_active = d3_timer_active.n;
        }
        return now;
      }
      function d3_timer_sweep() {
        var t0,
            t1 = d3_timer_queueHead,
            time = Infinity;
        while (t1) {
          if (t1.f) {
            t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
          } else {
            if (t1.t < time)
              time = t1.t;
            t1 = (t0 = t1).n;
          }
        }
        d3_timer_queueTail = t0;
        return time;
      }
      function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
      }
      d3.round = function(x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
      };
      var d3_formatPrefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(d3_formatPrefix);
      d3.formatPrefix = function(value, precision) {
        var i = 0;
        if (value) {
          if (value < 0)
            value *= -1;
          if (precision)
            value = d3.round(value, d3_format_precision(value, precision));
          i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
          i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
      };
      function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
          scale: i > 8 ? function(d) {
            return d / k;
          } : function(d) {
            return d * k;
          },
          symbol: d
        };
      }
      function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal,
            locale_thousands = locale.thousands,
            locale_grouping = locale.grouping,
            locale_currency = locale.currency,
            formatGroup = locale_grouping && locale_thousands ? function(value, width) {
              var i = value.length,
                  t = [],
                  j = 0,
                  g = locale_grouping[0],
                  length = 0;
              while (i > 0 && g > 0) {
                if (length + g + 1 > width)
                  g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width)
                  break;
                g = locale_grouping[j = (j + 1) % locale_grouping.length];
              }
              return t.reverse().join(locale_thousands);
            } : d3_identity;
        return function(specifier) {
          var match = d3_format_re.exec(specifier),
              fill = match[1] || " ",
              align = match[2] || ">",
              sign = match[3] || "-",
              symbol = match[4] || "",
              zfill = match[5],
              width = +match[6],
              comma = match[7],
              precision = match[8],
              type = match[9],
              scale = 1,
              prefix = "",
              suffix = "",
              integer = false,
              exponent = true;
          if (precision)
            precision = +precision.substring(1);
          if (zfill || fill === "0" && align === "=") {
            zfill = fill = "0";
            align = "=";
          }
          switch (type) {
            case "n":
              comma = true;
              type = "g";
              break;
            case "%":
              scale = 100;
              suffix = "%";
              type = "f";
              break;
            case "p":
              scale = 100;
              suffix = "%";
              type = "r";
              break;
            case "b":
            case "o":
            case "x":
            case "X":
              if (symbol === "#")
                prefix = "0" + type.toLowerCase();
            case "c":
              exponent = false;
            case "d":
              integer = true;
              precision = 0;
              break;
            case "s":
              scale = -1;
              type = "r";
              break;
          }
          if (symbol === "$")
            prefix = locale_currency[0], suffix = locale_currency[1];
          if (type == "r" && !precision)
            type = "g";
          if (precision != null) {
            if (type == "g")
              precision = Math.max(1, Math.min(21, precision));
            else if (type == "e" || type == "f")
              precision = Math.max(0, Math.min(20, precision));
          }
          type = d3_format_types.get(type) || d3_format_typeDefault;
          var zcomma = zfill && comma;
          return function(value) {
            var fullSuffix = suffix;
            if (integer && value % 1)
              return "";
            var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
            if (scale < 0) {
              var unit = d3.formatPrefix(value, precision);
              value = unit.scale(value);
              fullSuffix = unit.symbol + suffix;
            } else {
              value *= scale;
            }
            value = type(value, precision);
            var i = value.lastIndexOf("."),
                before,
                after;
            if (i < 0) {
              var j = exponent ? value.lastIndexOf("e") : -1;
              if (j < 0)
                before = value, after = "";
              else
                before = value.substring(0, j), after = value.substring(j);
            } else {
              before = value.substring(0, i);
              after = locale_decimal + value.substring(i + 1);
            }
            if (!zfill && comma)
              before = formatGroup(before, Infinity);
            var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length),
                padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
            if (zcomma)
              before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
            negative += prefix;
            value = before + after;
            return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
          };
        };
      }
      var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
      var d3_format_types = d3.map({
        b: function(x) {
          return x.toString(2);
        },
        c: function(x) {
          return String.fromCharCode(x);
        },
        o: function(x) {
          return x.toString(8);
        },
        x: function(x) {
          return x.toString(16);
        },
        X: function(x) {
          return x.toString(16).toUpperCase();
        },
        g: function(x, p) {
          return x.toPrecision(p);
        },
        e: function(x, p) {
          return x.toExponential(p);
        },
        f: function(x, p) {
          return x.toFixed(p);
        },
        r: function(x, p) {
          return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
      });
      function d3_format_typeDefault(x) {
        return x + "";
      }
      var d3_time = d3.time = {},
          d3_date = Date;
      function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
      }
      d3_date_utc.prototype = {
        getDate: function() {
          return this._.getUTCDate();
        },
        getDay: function() {
          return this._.getUTCDay();
        },
        getFullYear: function() {
          return this._.getUTCFullYear();
        },
        getHours: function() {
          return this._.getUTCHours();
        },
        getMilliseconds: function() {
          return this._.getUTCMilliseconds();
        },
        getMinutes: function() {
          return this._.getUTCMinutes();
        },
        getMonth: function() {
          return this._.getUTCMonth();
        },
        getSeconds: function() {
          return this._.getUTCSeconds();
        },
        getTime: function() {
          return this._.getTime();
        },
        getTimezoneOffset: function() {
          return 0;
        },
        valueOf: function() {
          return this._.valueOf();
        },
        setDate: function() {
          d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function() {
          d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function() {
          d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function() {
          d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function() {
          d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function() {
          d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function() {
          d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function() {
          d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function() {
          d3_time_prototype.setTime.apply(this._, arguments);
        }
      };
      var d3_time_prototype = Date.prototype;
      function d3_time_interval(local, step, number) {
        function round(date) {
          var d0 = local(date),
              d1 = offset(d0, 1);
          return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
          step(date = local(new d3_date(date - 1)), 1);
          return date;
        }
        function offset(date, k) {
          step(date = new d3_date(+date), k);
          return date;
        }
        function range(t0, t1, dt) {
          var time = ceil(t0),
              times = [];
          if (dt > 1) {
            while (time < t1) {
              if (!(number(time) % dt))
                times.push(new Date(+time));
              step(time, 1);
            }
          } else {
            while (time < t1)
              times.push(new Date(+time)), step(time, 1);
          }
          return times;
        }
        function range_utc(t0, t1, dt) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = t0;
            return range(utc, t1, dt);
          } finally {
            d3_date = Date;
          }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
      }
      function d3_time_interval_utc(method) {
        return function(date, k) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = date;
            return method(utc, k)._;
          } finally {
            d3_date = Date;
          }
        };
      }
      d3_time.year = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
      }, function(date, offset) {
        date.setFullYear(date.getFullYear() + offset);
      }, function(date) {
        return date.getFullYear();
      });
      d3_time.years = d3_time.year.range;
      d3_time.years.utc = d3_time.year.utc.range;
      d3_time.day = d3_time_interval(function(date) {
        var day = new d3_date(2e3, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
      }, function(date, offset) {
        date.setDate(date.getDate() + offset);
      }, function(date) {
        return date.getDate() - 1;
      });
      d3_time.days = d3_time.day.range;
      d3_time.days.utc = d3_time.day.utc.range;
      d3_time.dayOfYear = function(date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
      };
      ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function(day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function(date) {
          (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
          return date;
        }, function(date, offset) {
          date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function(date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + "s"] = interval.range;
        d3_time[day + "s"].utc = interval.utc.range;
        d3_time[day + "OfYear"] = function(date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
      });
      d3_time.week = d3_time.sunday;
      d3_time.weeks = d3_time.sunday.range;
      d3_time.weeks.utc = d3_time.sunday.utc.range;
      d3_time.weekOfYear = d3_time.sundayOfYear;
      function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime,
            locale_date = locale.date,
            locale_time = locale.time,
            locale_periods = locale.periods,
            locale_days = locale.days,
            locale_shortDays = locale.shortDays,
            locale_months = locale.months,
            locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
          var n = template.length;
          function format(date) {
            var string = [],
                i = -1,
                j = 0,
                c,
                p,
                f;
            while (++i < n) {
              if (template.charCodeAt(i) === 37) {
                string.push(template.slice(j, i));
                if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null)
                  c = template.charAt(++i);
                if (f = d3_time_formats[c])
                  c = f(date, p == null ? c === "e" ? " " : "0" : p);
                string.push(c);
                j = i + 1;
              }
            }
            string.push(template.slice(j, i));
            return string.join("");
          }
          format.parse = function(string) {
            var d = {
              y: 1900,
              m: 0,
              d: 1,
              H: 0,
              M: 0,
              S: 0,
              L: 0,
              Z: null
            },
                i = d3_time_parse(d, template, string, 0);
            if (i != string.length)
              return null;
            if ("p" in d)
              d.H = d.H % 12 + d.p * 12;
            var localZ = d.Z != null && d3_date !== d3_date_utc,
                date = new (localZ ? d3_date_utc : d3_date)();
            if ("j" in d)
              date.setFullYear(d.y, 0, d.j);
            else if ("w" in d && ("W" in d || "U" in d)) {
              date.setFullYear(d.y, 0, 1);
              date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
            } else
              date.setFullYear(d.y, d.m, d.d);
            date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
            return localZ ? date._ : date;
          };
          format.toString = function() {
            return template;
          };
          return format;
        }
        function d3_time_parse(date, template, string, j) {
          var c,
              p,
              t,
              i = 0,
              n = template.length,
              m = string.length;
          while (i < n) {
            if (j >= m)
              return -1;
            c = template.charCodeAt(i++);
            if (c === 37) {
              t = template.charAt(i++);
              p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
              if (!p || (j = p(date, string, j)) < 0)
                return -1;
            } else if (c != string.charCodeAt(j++)) {
              return -1;
            }
          }
          return j;
        }
        d3_time_format.utc = function(template) {
          var local = d3_time_format(template);
          function format(date) {
            try {
              d3_date = d3_date_utc;
              var utc = new d3_date();
              utc._ = date;
              return local(utc);
            } finally {
              d3_date = Date;
            }
          }
          format.parse = function(string) {
            try {
              d3_date = d3_date_utc;
              var date = local.parse(string);
              return date && date._;
            } finally {
              d3_date = Date;
            }
          };
          format.toString = local.toString;
          return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(),
            d3_time_dayRe = d3_time_formatRe(locale_days),
            d3_time_dayLookup = d3_time_formatLookup(locale_days),
            d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays),
            d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays),
            d3_time_monthRe = d3_time_formatRe(locale_months),
            d3_time_monthLookup = d3_time_formatLookup(locale_months),
            d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths),
            d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function(p, i) {
          d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
          a: function(d) {
            return locale_shortDays[d.getDay()];
          },
          A: function(d) {
            return locale_days[d.getDay()];
          },
          b: function(d) {
            return locale_shortMonths[d.getMonth()];
          },
          B: function(d) {
            return locale_months[d.getMonth()];
          },
          c: d3_time_format(locale_dateTime),
          d: function(d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          e: function(d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          H: function(d, p) {
            return d3_time_formatPad(d.getHours(), p, 2);
          },
          I: function(d, p) {
            return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
          },
          j: function(d, p) {
            return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
          },
          L: function(d, p) {
            return d3_time_formatPad(d.getMilliseconds(), p, 3);
          },
          m: function(d, p) {
            return d3_time_formatPad(d.getMonth() + 1, p, 2);
          },
          M: function(d, p) {
            return d3_time_formatPad(d.getMinutes(), p, 2);
          },
          p: function(d) {
            return locale_periods[+(d.getHours() >= 12)];
          },
          S: function(d, p) {
            return d3_time_formatPad(d.getSeconds(), p, 2);
          },
          U: function(d, p) {
            return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
          },
          w: function(d) {
            return d.getDay();
          },
          W: function(d, p) {
            return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
          },
          x: d3_time_format(locale_date),
          X: d3_time_format(locale_time),
          y: function(d, p) {
            return d3_time_formatPad(d.getFullYear() % 100, p, 2);
          },
          Y: function(d, p) {
            return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
          },
          Z: d3_time_zone,
          "%": function() {
            return "%";
          }
        };
        var d3_time_parsers = {
          a: d3_time_parseWeekdayAbbrev,
          A: d3_time_parseWeekday,
          b: d3_time_parseMonthAbbrev,
          B: d3_time_parseMonth,
          c: d3_time_parseLocaleFull,
          d: d3_time_parseDay,
          e: d3_time_parseDay,
          H: d3_time_parseHour24,
          I: d3_time_parseHour24,
          j: d3_time_parseDayOfYear,
          L: d3_time_parseMilliseconds,
          m: d3_time_parseMonthNumber,
          M: d3_time_parseMinutes,
          p: d3_time_parseAmPm,
          S: d3_time_parseSeconds,
          U: d3_time_parseWeekNumberSunday,
          w: d3_time_parseWeekdayNumber,
          W: d3_time_parseWeekNumberMonday,
          x: d3_time_parseLocaleDate,
          X: d3_time_parseLocaleTime,
          y: d3_time_parseYear,
          Y: d3_time_parseFullYear,
          Z: d3_time_parseZone,
          "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
          d3_time_dayAbbrevRe.lastIndex = 0;
          var n = d3_time_dayAbbrevRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
          d3_time_dayRe.lastIndex = 0;
          var n = d3_time_dayRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
          d3_time_monthAbbrevRe.lastIndex = 0;
          var n = d3_time_monthAbbrevRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
          d3_time_monthRe.lastIndex = 0;
          var n = d3_time_monthRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
          return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
          return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
          return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
          var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
          return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
      }
      var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
      },
          d3_time_numberRe = /^\s*\d+/,
          d3_time_percentRe = /^%/;
      function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : "",
            string = (sign ? -value : value) + "",
            length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
      }
      function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
      }
      function d3_time_formatLookup(names) {
        var map = new d3_Map(),
            i = -1,
            n = names.length;
        while (++i < n)
          map.set(names[i].toLowerCase(), i);
        return map;
      }
      function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
      }
      function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1;
      }
      function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
      }
      function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
      }
      function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
      }
      function d3_time_zone(d) {
        var z = d.getTimezoneOffset(),
            zs = z > 0 ? "-" : "+",
            zh = abs(z) / 60 | 0,
            zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
      }
      function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
      }
      function d3_time_formatMulti(formats) {
        var n = formats.length,
            i = -1;
        while (++i < n)
          formats[i][0] = this(formats[i][0]);
        return function(date) {
          var i = 0,
              f = formats[i];
          while (!f[1](date))
            f = formats[++i];
          return f[0](date);
        };
      }
      d3.locale = function(locale) {
        return {
          numberFormat: d3_locale_numberFormat(locale),
          timeFormat: d3_locale_timeFormat(locale)
        };
      };
      var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
      });
      d3.format = d3_locale_enUS.numberFormat;
      d3.geo = {};
      function d3_adder() {}
      d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function(y) {
          d3_adderSum(y, this.t, d3_adderTemp);
          d3_adderSum(d3_adderTemp.s, this.s, this);
          if (this.s)
            this.t += d3_adderTemp.t;
          else
            this.s = d3_adderTemp.t;
        },
        reset: function() {
          this.s = this.t = 0;
        },
        valueOf: function() {
          return this.s;
        }
      };
      var d3_adderTemp = new d3_adder();
      function d3_adderSum(a, b, o) {
        var x = o.s = a + b,
            bv = x - a,
            av = x - bv;
        o.t = a - av + (b - bv);
      }
      d3.geo.stream = function(object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
          d3_geo_streamObjectType[object.type](object, listener);
        } else {
          d3_geo_streamGeometry(object, listener);
        }
      };
      function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
          d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
      }
      var d3_geo_streamObjectType = {
        Feature: function(feature, listener) {
          d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function(object, listener) {
          var features = object.features,
              i = -1,
              n = features.length;
          while (++i < n)
            d3_geo_streamGeometry(features[i].geometry, listener);
        }
      };
      var d3_geo_streamGeometryType = {
        Sphere: function(object, listener) {
          listener.sphere();
        },
        Point: function(object, listener) {
          object = object.coordinates;
          listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function(object, listener) {
          d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function(object, listener) {
          d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function(object, listener) {
          var geometries = object.geometries,
              i = -1,
              n = geometries.length;
          while (++i < n)
            d3_geo_streamGeometry(geometries[i], listener);
        }
      };
      function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1,
            n = coordinates.length - closed,
            coordinate;
        listener.lineStart();
        while (++i < n)
          coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
      }
      function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1,
            n = coordinates.length;
        listener.polygonStart();
        while (++i < n)
          d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
      }
      d3.geo.area = function(object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
      };
      var d3_geo_areaSum,
          d3_geo_areaRingSum = new d3_adder();
      var d3_geo_area = {
        sphere: function() {
          d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
          d3_geo_areaRingSum.reset();
          d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function() {
          var area = 2 * d3_geo_areaRingSum;
          d3_geo_areaSum += area < 0 ? 4 * π + area : area;
          d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
      };
      function d3_geo_areaRingStart() {
        var λ00,
            φ00,
            λ0,
            cosφ0,
            sinφ0;
        d3_geo_area.point = function(λ, φ) {
          d3_geo_area.point = nextPoint;
          λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          φ = φ * d3_radians / 2 + π / 4;
          var dλ = λ - λ0,
              sdλ = dλ >= 0 ? 1 : -1,
              adλ = sdλ * dλ,
              cosφ = Math.cos(φ),
              sinφ = Math.sin(φ),
              k = sinφ0 * sinφ,
              u = cosφ0 * cosφ + k * Math.cos(adλ),
              v = k * sdλ * Math.sin(adλ);
          d3_geo_areaRingSum.add(Math.atan2(v, u));
          λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function() {
          nextPoint(λ00, φ00);
        };
      }
      function d3_geo_cartesian(spherical) {
        var λ = spherical[0],
            φ = spherical[1],
            cosφ = Math.cos(φ);
        return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];
      }
      function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }
      function d3_geo_cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }
      function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
      }
      function d3_geo_cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
      }
      function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
      }
      function d3_geo_spherical(cartesian) {
        return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])];
      }
      function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
      }
      d3.geo.bounds = function() {
        var λ0,
            φ0,
            λ1,
            φ1,
            λ_,
            λ__,
            φ__,
            p0,
            dλSum,
            ranges,
            range;
        var bound = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            bound.point = ringPoint;
            bound.lineStart = ringStart;
            bound.lineEnd = ringEnd;
            dλSum = 0;
            d3_geo_area.polygonStart();
          },
          polygonEnd: function() {
            d3_geo_area.polygonEnd();
            bound.point = point;
            bound.lineStart = lineStart;
            bound.lineEnd = lineEnd;
            if (d3_geo_areaRingSum < 0)
              λ0 = -(λ1 = 180), φ0 = -(φ1 = 90);
            else if (dλSum > ε)
              φ1 = 90;
            else if (dλSum < -ε)
              φ0 = -90;
            range[0] = λ0, range[1] = λ1;
          }
        };
        function point(λ, φ) {
          ranges.push(range = [λ0 = λ, λ1 = λ]);
          if (φ < φ0)
            φ0 = φ;
          if (φ > φ1)
            φ1 = φ;
        }
        function linePoint(λ, φ) {
          var p = d3_geo_cartesian([λ * d3_radians, φ * d3_radians]);
          if (p0) {
            var normal = d3_geo_cartesianCross(p0, p),
                equatorial = [normal[1], -normal[0], 0],
                inflection = d3_geo_cartesianCross(equatorial, normal);
            d3_geo_cartesianNormalize(inflection);
            inflection = d3_geo_spherical(inflection);
            var dλ = λ - λ_,
                s = dλ > 0 ? 1 : -1,
                λi = inflection[0] * d3_degrees * s,
                antimeridian = abs(dλ) > 180;
            if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = inflection[1] * d3_degrees;
              if (φi > φ1)
                φ1 = φi;
            } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = -inflection[1] * d3_degrees;
              if (φi < φ0)
                φ0 = φi;
            } else {
              if (φ < φ0)
                φ0 = φ;
              if (φ > φ1)
                φ1 = φ;
            }
            if (antimeridian) {
              if (λ < λ_) {
                if (angle(λ0, λ) > angle(λ0, λ1))
                  λ1 = λ;
              } else {
                if (angle(λ, λ1) > angle(λ0, λ1))
                  λ0 = λ;
              }
            } else {
              if (λ1 >= λ0) {
                if (λ < λ0)
                  λ0 = λ;
                if (λ > λ1)
                  λ1 = λ;
              } else {
                if (λ > λ_) {
                  if (angle(λ0, λ) > angle(λ0, λ1))
                    λ1 = λ;
                } else {
                  if (angle(λ, λ1) > angle(λ0, λ1))
                    λ0 = λ;
                }
              }
            }
          } else {
            point(λ, φ);
          }
          p0 = p, λ_ = λ;
        }
        function lineStart() {
          bound.point = linePoint;
        }
        function lineEnd() {
          range[0] = λ0, range[1] = λ1;
          bound.point = point;
          p0 = null;
        }
        function ringPoint(λ, φ) {
          if (p0) {
            var dλ = λ - λ_;
            dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
          } else
            λ__ = λ, φ__ = φ;
          d3_geo_area.point(λ, φ);
          linePoint(λ, φ);
        }
        function ringStart() {
          d3_geo_area.lineStart();
        }
        function ringEnd() {
          ringPoint(λ__, φ__);
          d3_geo_area.lineEnd();
          if (abs(dλSum) > ε)
            λ0 = -(λ1 = 180);
          range[0] = λ0, range[1] = λ1;
          p0 = null;
        }
        function angle(λ0, λ1) {
          return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
          return a[0] - b[0];
        }
        function withinRange(x, range) {
          return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function(feature) {
          φ1 = λ1 = -(λ0 = φ0 = Infinity);
          ranges = [];
          d3.geo.stream(feature, bound);
          var n = ranges.length;
          if (n) {
            ranges.sort(compareRanges);
            for (var i = 1,
                a = ranges[0],
                b,
                merged = [a]; i < n; ++i) {
              b = ranges[i];
              if (withinRange(b[0], a) || withinRange(b[1], a)) {
                if (angle(a[0], b[1]) > angle(a[0], a[1]))
                  a[1] = b[1];
                if (angle(b[0], a[1]) > angle(a[0], a[1]))
                  a[0] = b[0];
              } else {
                merged.push(a = b);
              }
            }
            var best = -Infinity,
                dλ;
            for (var n = merged.length - 1,
                i = 0,
                a = merged[n],
                b; i <= n; a = b, ++i) {
              b = merged[i];
              if ((dλ = angle(a[1], b[0])) > best)
                best = dλ, λ0 = b[0], λ1 = a[1];
            }
          }
          ranges = range = null;
          return λ0 === Infinity || φ0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[λ0, φ0], [λ1, φ1]];
        };
      }();
      d3.geo.centroid = function(object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2,
            y = d3_geo_centroidY2,
            z = d3_geo_centroidZ2,
            m = x * x + y * y + z * z;
        if (m < ε2) {
          x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
          if (d3_geo_centroidW1 < ε)
            x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
          m = x * x + y * y + z * z;
          if (m < ε2)
            return [NaN, NaN];
        }
        return [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees];
      };
      var d3_geo_centroidW0,
          d3_geo_centroidW1,
          d3_geo_centroidX0,
          d3_geo_centroidY0,
          d3_geo_centroidZ0,
          d3_geo_centroidX1,
          d3_geo_centroidY1,
          d3_geo_centroidZ1,
          d3_geo_centroidX2,
          d3_geo_centroidY2,
          d3_geo_centroidZ2;
      var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function() {
          d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function() {
          d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
      };
      function d3_geo_centroidPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
      }
      function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
      }
      function d3_geo_centroidLineStart() {
        var x0,
            y0,
            z0;
        d3_geo_centroid.point = function(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroid.point = nextPoint;
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
      }
      function d3_geo_centroidRingStart() {
        var λ00,
            φ00,
            x0,
            y0,
            z0;
        d3_geo_centroid.point = function(λ, φ) {
          λ00 = λ, φ00 = φ;
          d3_geo_centroid.point = nextPoint;
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function() {
          nextPoint(λ00, φ00);
          d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
          d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              cx = y0 * z - z0 * y,
              cy = z0 * x - x0 * z,
              cz = x0 * y - y0 * x,
              m = Math.sqrt(cx * cx + cy * cy + cz * cz),
              u = x0 * x + y0 * y + z0 * z,
              v = m && -d3_acos(u) / m,
              w = Math.atan2(m, u);
          d3_geo_centroidX2 += v * cx;
          d3_geo_centroidY2 += v * cy;
          d3_geo_centroidZ2 += v * cz;
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_compose(a, b) {
        function compose(x, y) {
          return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert)
          compose.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
          };
        return compose;
      }
      function d3_true() {
        return true;
      }
      function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [],
            clip = [];
        segments.forEach(function(segment) {
          if ((n = segment.length - 1) <= 0)
            return;
          var n,
              p0 = segment[0],
              p1 = segment[n];
          if (d3_geo_sphericalEqual(p0, p1)) {
            listener.lineStart();
            for (var i = 0; i < n; ++i)
              listener.point((p0 = segment[i])[0], p0[1]);
            listener.lineEnd();
            return;
          }
          var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true),
              b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
          a.o = b;
          subject.push(a);
          clip.push(b);
          a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
          b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
          a.o = b;
          subject.push(a);
          clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length)
          return;
        for (var i = 0,
            entry = clipStartInside,
            n = clip.length; i < n; ++i) {
          clip[i].e = entry = !entry;
        }
        var start = subject[0],
            points,
            point;
        while (1) {
          var current = start,
              isSubject = true;
          while (current.v)
            if ((current = current.n) === start)
              return;
          points = current.z;
          listener.lineStart();
          do {
            current.v = current.o.v = true;
            if (current.e) {
              if (isSubject) {
                for (var i = 0,
                    n = points.length; i < n; ++i)
                  listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.n.x, 1, listener);
              }
              current = current.n;
            } else {
              if (isSubject) {
                points = current.p.z;
                for (var i = points.length - 1; i >= 0; --i)
                  listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.p.x, -1, listener);
              }
              current = current.p;
            }
            current = current.o;
            points = current.z;
            isSubject = !isSubject;
          } while (!current.v);
          listener.lineEnd();
        }
      }
      function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length))
          return;
        var n,
            i = 0,
            a = array[0],
            b;
        while (++i < n) {
          a.n = b = array[i];
          b.p = a;
          a = b;
        }
        a.n = b = array[0];
        b.p = a;
      }
      function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
      }
      function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function(rotate, listener) {
          var line = clipLine(listener),
              rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              clip.point = pointRing;
              clip.lineStart = ringStart;
              clip.lineEnd = ringEnd;
              segments = [];
              polygon = [];
            },
            polygonEnd: function() {
              clip.point = point;
              clip.lineStart = lineStart;
              clip.lineEnd = lineEnd;
              segments = d3.merge(segments);
              var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
              if (segments.length) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
              } else if (clipStartInside) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                interpolate(null, null, 1, listener);
                listener.lineEnd();
              }
              if (polygonStarted)
                listener.polygonEnd(), polygonStarted = false;
              segments = polygon = null;
            },
            sphere: function() {
              listener.polygonStart();
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
              listener.polygonEnd();
            }
          };
          function point(λ, φ) {
            var point = rotate(λ, φ);
            if (pointVisible(λ = point[0], φ = point[1]))
              listener.point(λ, φ);
          }
          function pointLine(λ, φ) {
            var point = rotate(λ, φ);
            line.point(point[0], point[1]);
          }
          function lineStart() {
            clip.point = pointLine;
            line.lineStart();
          }
          function lineEnd() {
            clip.point = point;
            line.lineEnd();
          }
          var segments;
          var buffer = d3_geo_clipBufferListener(),
              ringListener = clipLine(buffer),
              polygonStarted = false,
              polygon,
              ring;
          function pointRing(λ, φ) {
            ring.push([λ, φ]);
            var point = rotate(λ, φ);
            ringListener.point(point[0], point[1]);
          }
          function ringStart() {
            ringListener.lineStart();
            ring = [];
          }
          function ringEnd() {
            pointRing(ring[0][0], ring[0][1]);
            ringListener.lineEnd();
            var clean = ringListener.clean(),
                ringSegments = buffer.buffer(),
                segment,
                n = ringSegments.length;
            ring.pop();
            polygon.push(ring);
            ring = null;
            if (!n)
              return;
            if (clean & 1) {
              segment = ringSegments[0];
              var n = segment.length - 1,
                  i = -1,
                  point;
              if (n > 0) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                while (++i < n)
                  listener.point((point = segment[i])[0], point[1]);
                listener.lineEnd();
              }
              return;
            }
            if (n > 1 && clean & 2)
              ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
            segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
          }
          return clip;
        };
      }
      function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
      }
      function d3_geo_clipBufferListener() {
        var lines = [],
            line;
        return {
          lineStart: function() {
            lines.push(line = []);
          },
          point: function(λ, φ) {
            line.push([λ, φ]);
          },
          lineEnd: d3_noop,
          buffer: function() {
            var buffer = lines;
            lines = [];
            line = null;
            return buffer;
          },
          rejoin: function() {
            if (lines.length > 1)
              lines.push(lines.pop().concat(lines.shift()));
          }
        };
      }
      function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
      }
      var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-π, -π / 2]);
      function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN,
            φ0 = NaN,
            sλ0 = NaN,
            clean;
        return {
          lineStart: function() {
            listener.lineStart();
            clean = 1;
          },
          point: function(λ1, φ1) {
            var sλ1 = λ1 > 0 ? π : -π,
                dλ = abs(λ1 - λ0);
            if (abs(dλ - π) < ε) {
              listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              listener.point(λ1, φ0);
              clean = 0;
            } else if (sλ0 !== sλ1 && dλ >= π) {
              if (abs(λ0 - sλ0) < ε)
                λ0 -= sλ0 * ε;
              if (abs(λ1 - sλ1) < ε)
                λ1 -= sλ1 * ε;
              φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              clean = 0;
            }
            listener.point(λ0 = λ1, φ0 = φ1);
            sλ0 = sλ1;
          },
          lineEnd: function() {
            listener.lineEnd();
            λ0 = φ0 = NaN;
          },
          clean: function() {
            return 2 - clean;
          }
        };
      }
      function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0,
            cosφ1,
            sinλ0_λ1 = Math.sin(λ0 - λ1);
        return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
      }
      function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
          φ = direction * halfπ;
          listener.point(-π, φ);
          listener.point(0, φ);
          listener.point(π, φ);
          listener.point(π, 0);
          listener.point(π, -φ);
          listener.point(0, -φ);
          listener.point(-π, -φ);
          listener.point(-π, 0);
          listener.point(-π, φ);
        } else if (abs(from[0] - to[0]) > ε) {
          var s = from[0] < to[0] ? π : -π;
          φ = direction * s / 2;
          listener.point(-s, φ);
          listener.point(0, φ);
          listener.point(s, φ);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0],
            parallel = point[1],
            meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0],
            polarAngle = 0,
            winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0,
            n = polygon.length; i < n; ++i) {
          var ring = polygon[i],
              m = ring.length;
          if (!m)
            continue;
          var point0 = ring[0],
              λ0 = point0[0],
              φ0 = point0[1] / 2 + π / 4,
              sinφ0 = Math.sin(φ0),
              cosφ0 = Math.cos(φ0),
              j = 1;
          while (true) {
            if (j === m)
              j = 0;
            point = ring[j];
            var λ = point[0],
                φ = point[1] / 2 + π / 4,
                sinφ = Math.sin(φ),
                cosφ = Math.cos(φ),
                dλ = λ - λ0,
                sdλ = dλ >= 0 ? 1 : -1,
                adλ = sdλ * dλ,
                antimeridian = adλ > π,
                k = sinφ0 * sinφ;
            d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
            polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
            if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
              var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
              d3_geo_cartesianNormalize(arc);
              var intersection = d3_geo_cartesianCross(meridianNormal, arc);
              d3_geo_cartesianNormalize(intersection);
              var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
              if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                winding += antimeridian ^ dλ >= 0 ? 1 : -1;
              }
            }
            if (!j++)
              break;
            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
          }
        }
        return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
      }
      function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius),
            smallRadius = cr > 0,
            notHemisphere = abs(cr) > ε,
            interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-π, radius - π]);
        function visible(λ, φ) {
          return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
          var point0,
              c0,
              v0,
              v00,
              clean;
          return {
            lineStart: function() {
              v00 = v0 = false;
              clean = 1;
            },
            point: function(λ, φ) {
              var point1 = [λ, φ],
                  point2,
                  v = visible(λ, φ),
                  c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
              if (!point0 && (v00 = v0 = v))
                listener.lineStart();
              if (v !== v0) {
                point2 = intersect(point0, point1);
                if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                  point1[0] += ε;
                  point1[1] += ε;
                  v = visible(point1[0], point1[1]);
                }
              }
              if (v !== v0) {
                clean = 0;
                if (v) {
                  listener.lineStart();
                  point2 = intersect(point1, point0);
                  listener.point(point2[0], point2[1]);
                } else {
                  point2 = intersect(point0, point1);
                  listener.point(point2[0], point2[1]);
                  listener.lineEnd();
                }
                point0 = point2;
              } else if (notHemisphere && point0 && smallRadius ^ v) {
                var t;
                if (!(c & c0) && (t = intersect(point1, point0, true))) {
                  clean = 0;
                  if (smallRadius) {
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                  } else {
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                  }
                }
              }
              if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                listener.point(point1[0], point1[1]);
              }
              point0 = point1, v0 = v, c0 = c;
            },
            lineEnd: function() {
              if (v0)
                listener.lineEnd();
              point0 = null;
            },
            clean: function() {
              return clean | (v00 && v0) << 1;
            }
          };
        }
        function intersect(a, b, two) {
          var pa = d3_geo_cartesian(a),
              pb = d3_geo_cartesian(b);
          var n1 = [1, 0, 0],
              n2 = d3_geo_cartesianCross(pa, pb),
              n2n2 = d3_geo_cartesianDot(n2, n2),
              n1n2 = n2[0],
              determinant = n2n2 - n1n2 * n1n2;
          if (!determinant)
            return !two && a;
          var c1 = cr * n2n2 / determinant,
              c2 = -cr * n1n2 / determinant,
              n1xn2 = d3_geo_cartesianCross(n1, n2),
              A = d3_geo_cartesianScale(n1, c1),
              B = d3_geo_cartesianScale(n2, c2);
          d3_geo_cartesianAdd(A, B);
          var u = n1xn2,
              w = d3_geo_cartesianDot(A, u),
              uu = d3_geo_cartesianDot(u, u),
              t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
          if (t2 < 0)
            return;
          var t = Math.sqrt(t2),
              q = d3_geo_cartesianScale(u, (-w - t) / uu);
          d3_geo_cartesianAdd(q, A);
          q = d3_geo_spherical(q);
          if (!two)
            return q;
          var λ0 = a[0],
              λ1 = b[0],
              φ0 = a[1],
              φ1 = b[1],
              z;
          if (λ1 < λ0)
            z = λ0, λ0 = λ1, λ1 = z;
          var δλ = λ1 - λ0,
              polar = abs(δλ - π) < ε,
              meridian = polar || δλ < ε;
          if (!polar && φ1 < φ0)
            z = φ0, φ0 = φ1, φ1 = z;
          if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
            var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
            d3_geo_cartesianAdd(q1, A);
            return [q, d3_geo_spherical(q1)];
          }
        }
        function code(λ, φ) {
          var r = smallRadius ? radius : π - radius,
              code = 0;
          if (λ < -r)
            code |= 1;
          else if (λ > r)
            code |= 2;
          if (φ < -r)
            code |= 4;
          else if (φ > r)
            code |= 8;
          return code;
        }
      }
      function d3_geom_clipLine(x0, y0, x1, y1) {
        return function(line) {
          var a = line.a,
              b = line.b,
              ax = a.x,
              ay = a.y,
              bx = b.x,
              by = b.y,
              t0 = 0,
              t1 = 1,
              dx = bx - ax,
              dy = by - ay,
              r;
          r = x0 - ax;
          if (!dx && r > 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dx > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = x1 - ax;
          if (!dx && r < 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dx > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          r = y0 - ay;
          if (!dy && r > 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dy > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = y1 - ay;
          if (!dy && r < 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dy > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          if (t0 > 0)
            line.a = {
              x: ax + t0 * dx,
              y: ay + t0 * dy
            };
          if (t1 < 1)
            line.b = {
              x: ax + t1 * dx,
              y: ay + t1 * dy
            };
          return line;
        };
      }
      var d3_geo_clipExtentMAX = 1e9;
      d3.geo.clipExtent = function() {
        var x0,
            y0,
            x1,
            y1,
            stream,
            clip,
            clipExtent = {
              stream: function(output) {
                if (stream)
                  stream.valid = false;
                stream = clip(output);
                stream.valid = true;
                return stream;
              },
              extent: function(_) {
                if (!arguments.length)
                  return [[x0, y0], [x1, y1]];
                clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                if (stream)
                  stream.valid = false, stream = null;
                return clipExtent;
              }
            };
        return clipExtent.extent([[0, 0], [960, 500]]);
      };
      function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function(listener) {
          var listener_ = listener,
              bufferListener = d3_geo_clipBufferListener(),
              clipLine = d3_geom_clipLine(x0, y0, x1, y1),
              segments,
              polygon,
              ring;
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              listener = bufferListener;
              segments = [];
              polygon = [];
              clean = true;
            },
            polygonEnd: function() {
              listener = listener_;
              segments = d3.merge(segments);
              var clipStartInside = insidePolygon([x0, y1]),
                  inside = clean && clipStartInside,
                  visible = segments.length;
              if (inside || visible) {
                listener.polygonStart();
                if (inside) {
                  listener.lineStart();
                  interpolate(null, null, 1, listener);
                  listener.lineEnd();
                }
                if (visible) {
                  d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                }
                listener.polygonEnd();
              }
              segments = polygon = ring = null;
            }
          };
          function insidePolygon(p) {
            var wn = 0,
                n = polygon.length,
                y = p[1];
            for (var i = 0; i < n; ++i) {
              for (var j = 1,
                  v = polygon[i],
                  m = v.length,
                  a = v[0],
                  b; j < m; ++j) {
                b = v[j];
                if (a[1] <= y) {
                  if (b[1] > y && d3_cross2d(a, b, p) > 0)
                    ++wn;
                } else {
                  if (b[1] <= y && d3_cross2d(a, b, p) < 0)
                    --wn;
                }
                a = b;
              }
            }
            return wn !== 0;
          }
          function interpolate(from, to, direction, listener) {
            var a = 0,
                a1 = 0;
            if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
              do {
                listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
              } while ((a = (a + direction + 4) % 4) !== a1);
            } else {
              listener.point(to[0], to[1]);
            }
          }
          function pointVisible(x, y) {
            return x0 <= x && x <= x1 && y0 <= y && y <= y1;
          }
          function point(x, y) {
            if (pointVisible(x, y))
              listener.point(x, y);
          }
          var x__,
              y__,
              v__,
              x_,
              y_,
              v_,
              first,
              clean;
          function lineStart() {
            clip.point = linePoint;
            if (polygon)
              polygon.push(ring = []);
            first = true;
            v_ = false;
            x_ = y_ = NaN;
          }
          function lineEnd() {
            if (segments) {
              linePoint(x__, y__);
              if (v__ && v_)
                bufferListener.rejoin();
              segments.push(bufferListener.buffer());
            }
            clip.point = point;
            if (v_)
              listener.lineEnd();
          }
          function linePoint(x, y) {
            x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
            y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
            var v = pointVisible(x, y);
            if (polygon)
              ring.push([x, y]);
            if (first) {
              x__ = x, y__ = y, v__ = v;
              first = false;
              if (v) {
                listener.lineStart();
                listener.point(x, y);
              }
            } else {
              if (v && v_)
                listener.point(x, y);
              else {
                var l = {
                  a: {
                    x: x_,
                    y: y_
                  },
                  b: {
                    x: x,
                    y: y
                  }
                };
                if (clipLine(l)) {
                  if (!v_) {
                    listener.lineStart();
                    listener.point(l.a.x, l.a.y);
                  }
                  listener.point(l.b.x, l.b.y);
                  if (!v)
                    listener.lineEnd();
                  clean = false;
                } else if (v) {
                  listener.lineStart();
                  listener.point(x, y);
                  clean = false;
                }
              }
            }
            x_ = x, y_ = y, v_ = v;
          }
          return clip;
        };
        function corner(p, direction) {
          return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
          return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
          var ca = corner(a, 1),
              cb = corner(b, 1);
          return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
      }
      function d3_geo_conic(projectAt) {
        var φ0 = 0,
            φ1 = π / 3,
            m = d3_geo_projectionMutator(projectAt),
            p = m(φ0, φ1);
        p.parallels = function(_) {
          if (!arguments.length)
            return [φ0 / π * 180, φ1 / π * 180];
          return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        };
        return p;
      }
      function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0),
            n = (sinφ0 + Math.sin(φ1)) / 2,
            C = 1 + sinφ0 * (2 * n - sinφ0),
            ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
          var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
          return [ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = ρ0 - y;
          return [Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))];
        };
        return forward;
      }
      (d3.geo.conicEqualArea = function() {
        return d3_geo_conic(d3_geo_conicEqualArea);
      }).raw = d3_geo_conicEqualArea;
      d3.geo.albers = function() {
        return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070);
      };
      d3.geo.albersUsa = function() {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]);
        var hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]);
        var point,
            pointStream = {point: function(x, y) {
                point = [x, y];
              }},
            lower48Point,
            alaskaPoint,
            hawaiiPoint;
        function albersUsa(coordinates) {
          var x = coordinates[0],
              y = coordinates[1];
          point = null;
          (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
          return point;
        }
        albersUsa.invert = function(coordinates) {
          var k = lower48.scale(),
              t = lower48.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k;
          return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function(stream) {
          var lower48Stream = lower48.stream(stream),
              alaskaStream = alaska.stream(stream),
              hawaiiStream = hawaii.stream(stream);
          return {
            point: function(x, y) {
              lower48Stream.point(x, y);
              alaskaStream.point(x, y);
              hawaiiStream.point(x, y);
            },
            sphere: function() {
              lower48Stream.sphere();
              alaskaStream.sphere();
              hawaiiStream.sphere();
            },
            lineStart: function() {
              lower48Stream.lineStart();
              alaskaStream.lineStart();
              hawaiiStream.lineStart();
            },
            lineEnd: function() {
              lower48Stream.lineEnd();
              alaskaStream.lineEnd();
              hawaiiStream.lineEnd();
            },
            polygonStart: function() {
              lower48Stream.polygonStart();
              alaskaStream.polygonStart();
              hawaiiStream.polygonStart();
            },
            polygonEnd: function() {
              lower48Stream.polygonEnd();
              alaskaStream.polygonEnd();
              hawaiiStream.polygonEnd();
            }
          };
        };
        albersUsa.precision = function(_) {
          if (!arguments.length)
            return lower48.precision();
          lower48.precision(_);
          alaska.precision(_);
          hawaii.precision(_);
          return albersUsa;
        };
        albersUsa.scale = function(_) {
          if (!arguments.length)
            return lower48.scale();
          lower48.scale(_);
          alaska.scale(_ * .35);
          hawaii.scale(_);
          return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function(_) {
          if (!arguments.length)
            return lower48.translate();
          var k = lower48.scale(),
              x = +_[0],
              y = +_[1];
          lower48Point = lower48.translate(_).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(pointStream).point;
          alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + ε, y + .12 * k + ε], [x - .214 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + ε, y + .166 * k + ε], [x - .115 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          return albersUsa;
        };
        return albersUsa.scale(1070);
      };
      var d3_geo_pathAreaSum,
          d3_geo_pathAreaPolygon,
          d3_geo_pathArea = {
            point: d3_noop,
            lineStart: d3_noop,
            lineEnd: d3_noop,
            polygonStart: function() {
              d3_geo_pathAreaPolygon = 0;
              d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
            },
            polygonEnd: function() {
              d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
              d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
            }
          };
      function d3_geo_pathAreaRingStart() {
        var x00,
            y00,
            x0,
            y0;
        d3_geo_pathArea.point = function(x, y) {
          d3_geo_pathArea.point = nextPoint;
          x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
          d3_geo_pathAreaPolygon += y0 * x - x0 * y;
          x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function() {
          nextPoint(x00, y00);
        };
      }
      var d3_geo_pathBoundsX0,
          d3_geo_pathBoundsY0,
          d3_geo_pathBoundsX1,
          d3_geo_pathBoundsY1;
      var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0)
          d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1)
          d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0)
          d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1)
          d3_geo_pathBoundsY1 = y;
      }
      function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5),
            buffer = [];
        var stream = {
          point: point,
          lineStart: function() {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function() {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function() {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function(_) {
            pointCircle = d3_geo_pathBufferCircle(_);
            return stream;
          },
          result: function() {
            if (buffer.length) {
              var result = buffer.join("");
              buffer = [];
              return result;
            }
          }
        };
        function point(x, y) {
          buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
          buffer.push("M", x, ",", y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          buffer.push("L", x, ",", y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          buffer.push("Z");
        }
        return stream;
      }
      function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
      }
      var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function() {
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function() {
          d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
          d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
      };
      function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
      }
      function d3_geo_pathCentroidLineStart() {
        var x0,
            y0;
        d3_geo_pathCentroid.point = function(x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
      }
      function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      }
      function d3_geo_pathCentroidRingStart() {
        var x00,
            y00,
            x0,
            y0;
        d3_geo_pathCentroid.point = function(x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          z = y0 * x - x0 * y;
          d3_geo_centroidX2 += z * (x0 + x);
          d3_geo_centroidY2 += z * (y0 + y);
          d3_geo_centroidZ2 += z * 3;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function() {
          nextPoint(x00, y00);
        };
      }
      function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
          point: point,
          lineStart: function() {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function() {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function() {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function(_) {
            pointRadius = _;
            return stream;
          },
          result: d3_noop
        };
        function point(x, y) {
          context.moveTo(x + pointRadius, y);
          context.arc(x, y, pointRadius, 0, τ);
        }
        function pointLineStart(x, y) {
          context.moveTo(x, y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          context.lineTo(x, y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          context.closePath();
        }
        return stream;
      }
      function d3_geo_resample(project) {
        var δ2 = .5,
            cosMinDistance = Math.cos(30 * d3_radians),
            maxDepth = 16;
        function resample(stream) {
          return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
          return d3_geo_transformPoint(stream, function(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          });
        }
        function resampleRecursive(stream) {
          var λ00,
              φ00,
              x00,
              y00,
              a00,
              b00,
              c00,
              λ0,
              x0,
              y0,
              a0,
              b0,
              c0;
          var resample = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              stream.polygonStart();
              resample.lineStart = ringStart;
            },
            polygonEnd: function() {
              stream.polygonEnd();
              resample.lineStart = lineStart;
            }
          };
          function point(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          }
          function lineStart() {
            x0 = NaN;
            resample.point = linePoint;
            stream.lineStart();
          }
          function linePoint(λ, φ) {
            var c = d3_geo_cartesian([λ, φ]),
                p = project(λ, φ);
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
            stream.point(x0, y0);
          }
          function lineEnd() {
            resample.point = point;
            stream.lineEnd();
          }
          function ringStart() {
            lineStart();
            resample.point = ringPoint;
            resample.lineEnd = ringEnd;
          }
          function ringPoint(λ, φ) {
            linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
            resample.point = linePoint;
          }
          function ringEnd() {
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
            resample.lineEnd = lineEnd;
            lineEnd();
          }
          return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
          var dx = x1 - x0,
              dy = y1 - y0,
              d2 = dx * dx + dy * dy;
          if (d2 > 4 * δ2 && depth--) {
            var a = a0 + a1,
                b = b0 + b1,
                c = c0 + c1,
                m = Math.sqrt(a * a + b * b + c * c),
                φ2 = Math.asin(c /= m),
                λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a),
                p = project(λ2, φ2),
                x2 = p[0],
                y2 = p[1],
                dx2 = x2 - x0,
                dy2 = y2 - y0,
                dz = dy * dx2 - dx * dy2;
            if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
              resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
              stream.point(x2, y2);
              resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
            }
          }
        }
        resample.precision = function(_) {
          if (!arguments.length)
            return Math.sqrt(δ2);
          maxDepth = (δ2 = _ * _) > 0 && 16;
          return resample;
        };
        return resample;
      }
      d3.geo.path = function() {
        var pointRadius = 4.5,
            projection,
            context,
            projectStream,
            contextStream,
            cacheStream;
        function path(object) {
          if (object) {
            if (typeof pointRadius === "function")
              contextStream.pointRadius(+pointRadius.apply(this, arguments));
            if (!cacheStream || !cacheStream.valid)
              cacheStream = projectStream(contextStream);
            d3.geo.stream(object, cacheStream);
          }
          return contextStream.result();
        }
        path.area = function(object) {
          d3_geo_pathAreaSum = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathArea));
          return d3_geo_pathAreaSum;
        };
        path.centroid = function(object) {
          d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
          return d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN];
        };
        path.bounds = function(object) {
          d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
          d3.geo.stream(object, projectStream(d3_geo_pathBounds));
          return [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]];
        };
        path.projection = function(_) {
          if (!arguments.length)
            return projection;
          projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
          return reset();
        };
        path.context = function(_) {
          if (!arguments.length)
            return context;
          contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
          if (typeof pointRadius !== "function")
            contextStream.pointRadius(pointRadius);
          return reset();
        };
        path.pointRadius = function(_) {
          if (!arguments.length)
            return pointRadius;
          pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
          return path;
        };
        function reset() {
          cacheStream = null;
          return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
      };
      function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function(x, y) {
          return project([x * d3_degrees, y * d3_degrees]);
        });
        return function(stream) {
          return d3_geo_projectionRadians(resample(stream));
        };
      }
      d3.geo.transform = function(methods) {
        return {stream: function(stream) {
            var transform = new d3_geo_transform(stream);
            for (var k in methods)
              transform[k] = methods[k];
            return transform;
          }};
      };
      function d3_geo_transform(stream) {
        this.stream = stream;
      }
      d3_geo_transform.prototype = {
        point: function(x, y) {
          this.stream.point(x, y);
        },
        sphere: function() {
          this.stream.sphere();
        },
        lineStart: function() {
          this.stream.lineStart();
        },
        lineEnd: function() {
          this.stream.lineEnd();
        },
        polygonStart: function() {
          this.stream.polygonStart();
        },
        polygonEnd: function() {
          this.stream.polygonEnd();
        }
      };
      function d3_geo_transformPoint(stream, point) {
        return {
          point: point,
          sphere: function() {
            stream.sphere();
          },
          lineStart: function() {
            stream.lineStart();
          },
          lineEnd: function() {
            stream.lineEnd();
          },
          polygonStart: function() {
            stream.polygonStart();
          },
          polygonEnd: function() {
            stream.polygonEnd();
          }
        };
      }
      d3.geo.projection = d3_geo_projection;
      d3.geo.projectionMutator = d3_geo_projectionMutator;
      function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function() {
          return project;
        })();
      }
      function d3_geo_projectionMutator(projectAt) {
        var project,
            rotate,
            projectRotate,
            projectResample = d3_geo_resample(function(x, y) {
              x = project(x, y);
              return [x[0] * k + δx, δy - x[1] * k];
            }),
            k = 150,
            x = 480,
            y = 250,
            λ = 0,
            φ = 0,
            δλ = 0,
            δφ = 0,
            δγ = 0,
            δx,
            δy,
            preclip = d3_geo_clipAntimeridian,
            postclip = d3_identity,
            clipAngle = null,
            clipExtent = null,
            stream;
        function projection(point) {
          point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
          return [point[0] * k + δx, δy - point[1] * k];
        }
        function invert(point) {
          point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
          return point && [point[0] * d3_degrees, point[1] * d3_degrees];
        }
        projection.stream = function(output) {
          if (stream)
            stream.valid = false;
          stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
          stream.valid = true;
          return stream;
        };
        projection.clipAngle = function(_) {
          if (!arguments.length)
            return clipAngle;
          preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
          return invalidate();
        };
        projection.clipExtent = function(_) {
          if (!arguments.length)
            return clipExtent;
          clipExtent = _;
          postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
          return invalidate();
        };
        projection.scale = function(_) {
          if (!arguments.length)
            return k;
          k = +_;
          return reset();
        };
        projection.translate = function(_) {
          if (!arguments.length)
            return [x, y];
          x = +_[0];
          y = +_[1];
          return reset();
        };
        projection.center = function(_) {
          if (!arguments.length)
            return [λ * d3_degrees, φ * d3_degrees];
          λ = _[0] % 360 * d3_radians;
          φ = _[1] % 360 * d3_radians;
          return reset();
        };
        projection.rotate = function(_) {
          if (!arguments.length)
            return [δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees];
          δλ = _[0] % 360 * d3_radians;
          δφ = _[1] % 360 * d3_radians;
          δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
          return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
          projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
          var center = project(λ, φ);
          δx = x - center[0] * k;
          δy = y + center[1] * k;
          return invalidate();
        }
        function invalidate() {
          if (stream)
            stream.valid = false, stream = null;
          return projection;
        }
        return function() {
          project = projectAt.apply(this, arguments);
          projection.invert = project.invert && invert;
          return reset();
        };
      }
      function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function(x, y) {
          stream.point(x * d3_radians, y * d3_radians);
        });
      }
      function d3_geo_equirectangular(λ, φ) {
        return [λ, φ];
      }
      (d3.geo.equirectangular = function() {
        return d3_geo_projection(d3_geo_equirectangular);
      }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
      d3.geo.rotation = function(rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
          coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function(coordinates) {
          coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
      };
      function d3_geo_identityRotation(λ, φ) {
        return [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
      }
      d3_geo_identityRotation.invert = d3_geo_equirectangular;
      function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
      }
      function d3_geo_forwardRotationλ(δλ) {
        return function(λ, φ) {
          return λ += δλ, [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
        };
      }
      function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
      }
      function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ),
            sinδφ = Math.sin(δφ),
            cosδγ = Math.cos(δγ),
            sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδφ + x * sinδφ;
          return [Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ)];
        }
        rotation.invert = function(λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδγ - y * sinδγ;
          return [Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ)];
        };
        return rotation;
      }
      d3.geo.circle = function() {
        var origin = [0, 0],
            angle,
            precision = 6,
            interpolate;
        function circle() {
          var center = typeof origin === "function" ? origin.apply(this, arguments) : origin,
              rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert,
              ring = [];
          interpolate(null, null, 1, {point: function(x, y) {
              ring.push(x = rotate(x, y));
              x[0] *= d3_degrees, x[1] *= d3_degrees;
            }});
          return {
            type: "Polygon",
            coordinates: [ring]
          };
        }
        circle.origin = function(x) {
          if (!arguments.length)
            return origin;
          origin = x;
          return circle;
        };
        circle.angle = function(x) {
          if (!arguments.length)
            return angle;
          interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
          return circle;
        };
        circle.precision = function(_) {
          if (!arguments.length)
            return precision;
          interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
          return circle;
        };
        return circle.angle(90);
      };
      function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius),
            sr = Math.sin(radius);
        return function(from, to, direction, listener) {
          var step = direction * precision;
          if (from != null) {
            from = d3_geo_circleAngle(cr, from);
            to = d3_geo_circleAngle(cr, to);
            if (direction > 0 ? from < to : from > to)
              from += direction * τ;
          } else {
            from = radius + direction * τ;
            to = radius - .5 * step;
          }
          for (var point,
              t = from; direction > 0 ? t > to : t < to; t -= step) {
            listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1]);
          }
        };
      }
      function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
      }
      d3.geo.distance = function(a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians,
            φ0 = a[1] * d3_radians,
            φ1 = b[1] * d3_radians,
            sinΔλ = Math.sin(Δλ),
            cosΔλ = Math.cos(Δλ),
            sinφ0 = Math.sin(φ0),
            cosφ0 = Math.cos(φ0),
            sinφ1 = Math.sin(φ1),
            cosφ1 = Math.cos(φ1),
            t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
      };
      d3.geo.graticule = function() {
        var x1,
            x0,
            X1,
            X0,
            y1,
            y0,
            Y1,
            Y0,
            dx = 10,
            dy = dx,
            DX = 90,
            DY = 360,
            x,
            y,
            X,
            Y,
            precision = 2.5;
        function graticule() {
          return {
            type: "MultiLineString",
            coordinates: lines()
          };
        }
        function lines() {
          return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
            return abs(x % DX) > ε;
          }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
            return abs(y % DY) > ε;
          }).map(y));
        }
        graticule.lines = function() {
          return lines().map(function(coordinates) {
            return {
              type: "LineString",
              coordinates: coordinates
            };
          });
        };
        graticule.outline = function() {
          return {
            type: "Polygon",
            coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
          };
        };
        graticule.extent = function(_) {
          if (!arguments.length)
            return graticule.minorExtent();
          return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function(_) {
          if (!arguments.length)
            return [[X0, Y0], [X1, Y1]];
          X0 = +_[0][0], X1 = +_[1][0];
          Y0 = +_[0][1], Y1 = +_[1][1];
          if (X0 > X1)
            _ = X0, X0 = X1, X1 = _;
          if (Y0 > Y1)
            _ = Y0, Y0 = Y1, Y1 = _;
          return graticule.precision(precision);
        };
        graticule.minorExtent = function(_) {
          if (!arguments.length)
            return [[x0, y0], [x1, y1]];
          x0 = +_[0][0], x1 = +_[1][0];
          y0 = +_[0][1], y1 = +_[1][1];
          if (x0 > x1)
            _ = x0, x0 = x1, x1 = _;
          if (y0 > y1)
            _ = y0, y0 = y1, y1 = _;
          return graticule.precision(precision);
        };
        graticule.step = function(_) {
          if (!arguments.length)
            return graticule.minorStep();
          return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function(_) {
          if (!arguments.length)
            return [DX, DY];
          DX = +_[0], DY = +_[1];
          return graticule;
        };
        graticule.minorStep = function(_) {
          if (!arguments.length)
            return [dx, dy];
          dx = +_[0], dy = +_[1];
          return graticule;
        };
        graticule.precision = function(_) {
          if (!arguments.length)
            return precision;
          precision = +_;
          x = d3_geo_graticuleX(y0, y1, 90);
          y = d3_geo_graticuleY(x0, x1, precision);
          X = d3_geo_graticuleX(Y0, Y1, 90);
          Y = d3_geo_graticuleY(X0, X1, precision);
          return graticule;
        };
        return graticule.majorExtent([[-180, -90 + ε], [180, 90 - ε]]).minorExtent([[-180, -80 - ε], [180, 80 + ε]]);
      };
      function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - ε, dy).concat(y1);
        return function(x) {
          return y.map(function(y) {
            return [x, y];
          });
        };
      }
      function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - ε, dx).concat(x1);
        return function(y) {
          return x.map(function(x) {
            return [x, y];
          });
        };
      }
      function d3_source(d) {
        return d.source;
      }
      function d3_target(d) {
        return d.target;
      }
      d3.geo.greatArc = function() {
        var source = d3_source,
            source_,
            target = d3_target,
            target_;
        function greatArc() {
          return {
            type: "LineString",
            coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]
          };
        }
        greatArc.distance = function() {
          return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function(_) {
          if (!arguments.length)
            return source;
          source = _, source_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.target = function(_) {
          if (!arguments.length)
            return target;
          target = _, target_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.precision = function() {
          return arguments.length ? greatArc : 0;
        };
        return greatArc;
      };
      d3.geo.interpolate = function(source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
      };
      function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0),
            sy0 = Math.sin(y0),
            cy1 = Math.cos(y1),
            sy1 = Math.sin(y1),
            kx0 = cy0 * Math.cos(x0),
            ky0 = cy0 * Math.sin(x0),
            kx1 = cy1 * Math.cos(x1),
            ky1 = cy1 * Math.sin(x1),
            d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))),
            k = 1 / Math.sin(d);
        var interpolate = d ? function(t) {
          var B = Math.sin(t *= d) * k,
              A = Math.sin(d - t) * k,
              x = A * kx0 + B * kx1,
              y = A * ky0 + B * ky1,
              z = A * sy0 + B * sy1;
          return [Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees];
        } : function() {
          return [x0 * d3_degrees, y0 * d3_degrees];
        };
        interpolate.distance = d;
        return interpolate;
      }
      d3.geo.length = function(object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
      };
      var d3_geo_lengthSum;
      var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_lengthLineStart() {
        var λ0,
            sinφ0,
            cosφ0;
        d3_geo_length.point = function(λ, φ) {
          λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
          d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function() {
          d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(λ, φ) {
          var sinφ = Math.sin(φ *= d3_radians),
              cosφ = Math.cos(φ),
              t = abs((λ *= d3_radians) - λ0),
              cosΔλ = Math.cos(t);
          d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
          λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
        }
      }
      function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
          var cosλ = Math.cos(λ),
              cosφ = Math.cos(φ),
              k = scale(cosλ * cosφ);
          return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];
        }
        azimuthal.invert = function(x, y) {
          var ρ = Math.sqrt(x * x + y * y),
              c = angle(ρ),
              sinc = Math.sin(c),
              cosc = Math.cos(c);
          return [Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ)];
        };
        return azimuthal;
      }
      var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
      }, function(ρ) {
        return 2 * Math.asin(ρ / 2);
      });
      (d3.geo.azimuthalEqualArea = function() {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
      }).raw = d3_geo_azimuthalEqualArea;
      var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
      }, d3_identity);
      (d3.geo.azimuthalEquidistant = function() {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
      }).raw = d3_geo_azimuthalEquidistant;
      function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            t = function(φ) {
              return Math.tan(π / 4 + φ / 2);
            },
            n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)),
            F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n)
          return d3_geo_mercator;
        function forward(λ, φ) {
          if (F > 0) {
            if (φ < -halfπ + ε)
              φ = -halfπ + ε;
          } else {
            if (φ > halfπ - ε)
              φ = halfπ - ε;
          }
          var ρ = F / Math.pow(t(φ), n);
          return [ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = F - y,
              ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
          return [Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ];
        };
        return forward;
      }
      (d3.geo.conicConformal = function() {
        return d3_geo_conic(d3_geo_conicConformal);
      }).raw = d3_geo_conicConformal;
      function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0),
            G = cosφ0 / n + φ0;
        if (abs(n) < ε)
          return d3_geo_equirectangular;
        function forward(λ, φ) {
          var ρ = G - φ;
          return [ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = G - y;
          return [Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)];
        };
        return forward;
      }
      (d3.geo.conicEquidistant = function() {
        return d3_geo_conic(d3_geo_conicEquidistant);
      }).raw = d3_geo_conicEquidistant;
      var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / cosλcosφ;
      }, Math.atan);
      (d3.geo.gnomonic = function() {
        return d3_geo_projection(d3_geo_gnomonic);
      }).raw = d3_geo_gnomonic;
      function d3_geo_mercator(λ, φ) {
        return [λ, Math.log(Math.tan(π / 4 + φ / 2))];
      }
      d3_geo_mercator.invert = function(x, y) {
        return [x, 2 * Math.atan(Math.exp(y)) - halfπ];
      };
      function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project),
            scale = m.scale,
            translate = m.translate,
            clipExtent = m.clipExtent,
            clipAuto;
        m.scale = function() {
          var v = scale.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function() {
          var v = translate.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function(_) {
          var v = clipExtent.apply(m, arguments);
          if (v === m) {
            if (clipAuto = _ == null) {
              var k = π * scale(),
                  t = translate();
              clipExtent([[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]]);
            }
          } else if (clipAuto) {
            v = null;
          }
          return v;
        };
        return m.clipExtent(null);
      }
      (d3.geo.mercator = function() {
        return d3_geo_mercatorProjection(d3_geo_mercator);
      }).raw = d3_geo_mercator;
      var d3_geo_orthographic = d3_geo_azimuthal(function() {
        return 1;
      }, Math.asin);
      (d3.geo.orthographic = function() {
        return d3_geo_projection(d3_geo_orthographic);
      }).raw = d3_geo_orthographic;
      var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / (1 + cosλcosφ);
      }, function(ρ) {
        return 2 * Math.atan(ρ);
      });
      (d3.geo.stereographic = function() {
        return d3_geo_projection(d3_geo_stereographic);
      }).raw = d3_geo_stereographic;
      function d3_geo_transverseMercator(λ, φ) {
        return [Math.log(Math.tan(π / 4 + φ / 2)), -λ];
      }
      d3_geo_transverseMercator.invert = function(x, y) {
        return [-y, 2 * Math.atan(Math.exp(x)) - halfπ];
      };
      (d3.geo.transverseMercator = function() {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator),
            center = projection.center,
            rotate = projection.rotate;
        projection.center = function(_) {
          return _ ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
        };
        projection.rotate = function(_) {
          return _ ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
        };
        return rotate([0, 0, 90]);
      }).raw = d3_geo_transverseMercator;
      d3.geom = {};
      function d3_geom_pointX(d) {
        return d[0];
      }
      function d3_geom_pointY(d) {
        return d[1];
      }
      d3.geom.hull = function(vertices) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY;
        if (arguments.length)
          return hull(vertices);
        function hull(data) {
          if (data.length < 3)
            return [];
          var fx = d3_functor(x),
              fy = d3_functor(y),
              i,
              n = data.length,
              points = [],
              flippedPoints = [];
          for (i = 0; i < n; i++) {
            points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
          }
          points.sort(d3_geom_hullOrder);
          for (i = 0; i < n; i++)
            flippedPoints.push([points[i][0], -points[i][1]]);
          var upper = d3_geom_hullUpper(points),
              lower = d3_geom_hullUpper(flippedPoints);
          var skipLeft = lower[0] === upper[0],
              skipRight = lower[lower.length - 1] === upper[upper.length - 1],
              polygon = [];
          for (i = upper.length - 1; i >= 0; --i)
            polygon.push(data[points[upper[i]][2]]);
          for (i = +skipLeft; i < lower.length - skipRight; ++i)
            polygon.push(data[points[lower[i]][2]]);
          return polygon;
        }
        hull.x = function(_) {
          return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function(_) {
          return arguments.length ? (y = _, hull) : y;
        };
        return hull;
      };
      function d3_geom_hullUpper(points) {
        var n = points.length,
            hull = [0, 1],
            hs = 2;
        for (var i = 2; i < n; i++) {
          while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0)
            --hs;
          hull[hs++] = i;
        }
        return hull.slice(0, hs);
      }
      function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
      }
      d3.geom.polygon = function(coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
      };
      var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
      d3_geom_polygonPrototype.area = function() {
        var i = -1,
            n = this.length,
            a,
            b = this[n - 1],
            area = 0;
        while (++i < n) {
          a = b;
          b = this[i];
          area += a[1] * b[0] - a[0] * b[1];
        }
        return area * .5;
      };
      d3_geom_polygonPrototype.centroid = function(k) {
        var i = -1,
            n = this.length,
            x = 0,
            y = 0,
            a,
            b = this[n - 1],
            c;
        if (!arguments.length)
          k = -1 / (6 * this.area());
        while (++i < n) {
          a = b;
          b = this[i];
          c = a[0] * b[1] - b[0] * a[1];
          x += (a[0] + b[0]) * c;
          y += (a[1] + b[1]) * c;
        }
        return [x * k, y * k];
      };
      d3_geom_polygonPrototype.clip = function(subject) {
        var input,
            closed = d3_geom_polygonClosed(subject),
            i = -1,
            n = this.length - d3_geom_polygonClosed(this),
            j,
            m,
            a = this[n - 1],
            b,
            c,
            d;
        while (++i < n) {
          input = subject.slice();
          subject.length = 0;
          b = this[i];
          c = input[(m = input.length - closed) - 1];
          j = -1;
          while (++j < m) {
            d = input[j];
            if (d3_geom_polygonInside(d, a, b)) {
              if (!d3_geom_polygonInside(c, a, b)) {
                subject.push(d3_geom_polygonIntersect(c, d, a, b));
              }
              subject.push(d);
            } else if (d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            c = d;
          }
          if (closed)
            subject.push(subject[0]);
          a = b;
        }
        return subject;
      };
      function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
      }
      function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0],
            x3 = a[0],
            x21 = d[0] - x1,
            x43 = b[0] - x3,
            y1 = c[1],
            y3 = a[1],
            y21 = d[1] - y1,
            y43 = b[1] - y3,
            ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [x1 + ua * x21, y1 + ua * y21];
      }
      function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0],
            b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
      }
      var d3_geom_voronoiEdges,
          d3_geom_voronoiCells,
          d3_geom_voronoiBeaches,
          d3_geom_voronoiBeachPool = [],
          d3_geom_voronoiFirstCircle,
          d3_geom_voronoiCircles,
          d3_geom_voronoiCirclePool = [];
      function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
      }
      function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
      }
      function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
      }
      function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle,
            x = circle.x,
            y = circle.cy,
            vertex = {
              x: x,
              y: y
            },
            previous = beach.P,
            next = beach.N,
            disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
          previous = lArc.P;
          disappearing.unshift(lArc);
          d3_geom_voronoiDetachBeach(lArc);
          lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
          next = rArc.N;
          disappearing.push(rArc);
          d3_geom_voronoiDetachBeach(rArc);
          rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length,
            iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
          rArc = disappearing[iArc];
          lArc = disappearing[iArc - 1];
          d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiAddBeach(site) {
        var x = site.x,
            directrix = site.y,
            lArc,
            rArc,
            dxl,
            dxr,
            node = d3_geom_voronoiBeaches._;
        while (node) {
          dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
          if (dxl > ε)
            node = node.L;
          else {
            dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
            if (dxr > ε) {
              if (!node.R) {
                lArc = node;
                break;
              }
              node = node.R;
            } else {
              if (dxl > -ε) {
                lArc = node.P;
                rArc = node;
              } else if (dxr > -ε) {
                lArc = node;
                rArc = node.N;
              } else {
                lArc = rArc = node;
              }
              break;
            }
          }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc)
          return;
        if (lArc === rArc) {
          d3_geom_voronoiDetachCircle(lArc);
          rArc = d3_geom_voronoiCreateBeach(lArc.site);
          d3_geom_voronoiBeaches.insert(newArc, rArc);
          newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
          return;
        }
        if (!rArc) {
          newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site,
            ax = lSite.x,
            ay = lSite.y,
            bx = site.x - ax,
            by = site.y - ay,
            rSite = rArc.site,
            cx = rSite.x - ax,
            cy = rSite.y - ay,
            d = 2 * (bx * cy - by * cx),
            hb = bx * bx + by * by,
            hc = cx * cx + cy * cy,
            vertex = {
              x: (cy * hb - by * hc) / d + ax,
              y: (bx * hc - cx * hb) / d + ay
            };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site,
            rfocx = site.x,
            rfocy = site.y,
            pby2 = rfocy - directrix;
        if (!pby2)
          return rfocx;
        var lArc = arc.P;
        if (!lArc)
          return -Infinity;
        site = lArc.site;
        var lfocx = site.x,
            lfocy = site.y,
            plby2 = lfocy - directrix;
        if (!plby2)
          return lfocx;
        var hl = lfocx - rfocx,
            aby2 = 1 / pby2 - 1 / plby2,
            b = hl / plby2;
        if (aby2)
          return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
      }
      function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc)
          return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
      }
      function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
      }
      d3_geom_voronoiCell.prototype.prepare = function() {
        var halfEdges = this.edges,
            iHalfEdge = halfEdges.length,
            edge;
        while (iHalfEdge--) {
          edge = halfEdges[iHalfEdge].edge;
          if (!edge.b || !edge.a)
            halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
      };
      function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            x2,
            y2,
            x3,
            y3,
            cells = d3_geom_voronoiCells,
            iCell = cells.length,
            cell,
            iHalfEdge,
            halfEdges,
            nHalfEdges,
            start,
            end;
        while (iCell--) {
          cell = cells[iCell];
          if (!cell || !cell.prepare())
            continue;
          halfEdges = cell.edges;
          nHalfEdges = halfEdges.length;
          iHalfEdge = 0;
          while (iHalfEdge < nHalfEdges) {
            end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
            start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
            if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
              halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                x: x0,
                y: abs(x2 - x0) < ε ? y2 : y1
              } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                x: abs(y2 - y1) < ε ? x2 : x1,
                y: y1
              } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                x: x1,
                y: abs(x2 - x1) < ε ? y2 : y0
              } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                x: abs(y2 - y0) < ε ? x2 : x0,
                y: y0
              } : null), cell.site, null));
              ++nHalfEdges;
            }
          }
        }
      }
      function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
      }
      function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
      }
      function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P,
            rArc = arc.N;
        if (!lArc || !rArc)
          return;
        var lSite = lArc.site,
            cSite = arc.site,
            rSite = rArc.site;
        if (lSite === rSite)
          return;
        var bx = cSite.x,
            by = cSite.y,
            ax = lSite.x - bx,
            ay = lSite.y - by,
            cx = rSite.x - bx,
            cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -ε2)
          return;
        var ha = ax * ax + ay * ay,
            hc = cx * cx + cy * cy,
            x = (cy * ha - ay * hc) / d,
            y = (ax * hc - cx * ha) / d,
            cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null,
            node = d3_geom_voronoiCircles._;
        while (node) {
          if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
            if (node.L)
              node = node.L;
            else {
              before = node.P;
              break;
            }
          } else {
            if (node.R)
              node = node.R;
            else {
              before = node;
              break;
            }
          }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before)
          d3_geom_voronoiFirstCircle = circle;
      }
      function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
          if (!circle.P)
            d3_geom_voronoiFirstCircle = circle.N;
          d3_geom_voronoiCircles.remove(circle);
          d3_geom_voronoiCirclePool.push(circle);
          d3_geom_voronoiRedBlackNode(circle);
          arc.circle = null;
        }
      }
      function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges,
            clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]),
            i = edges.length,
            e;
        while (i--) {
          e = edges[i];
          if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
            e.a = e.b = null;
            edges.splice(i, 1);
          }
        }
      }
      function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb)
          return true;
        var va = edge.a,
            x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            lSite = edge.l,
            rSite = edge.r,
            lx = lSite.x,
            ly = lSite.y,
            rx = rSite.x,
            ry = rSite.y,
            fx = (lx + rx) / 2,
            fy = (ly + ry) / 2,
            fm,
            fb;
        if (ry === ly) {
          if (fx < x0 || fx >= x1)
            return;
          if (lx > rx) {
            if (!va)
              va = {
                x: fx,
                y: y0
              };
            else if (va.y >= y1)
              return;
            vb = {
              x: fx,
              y: y1
            };
          } else {
            if (!va)
              va = {
                x: fx,
                y: y1
              };
            else if (va.y < y0)
              return;
            vb = {
              x: fx,
              y: y0
            };
          }
        } else {
          fm = (lx - rx) / (ry - ly);
          fb = fy - fm * fx;
          if (fm < -1 || fm > 1) {
            if (lx > rx) {
              if (!va)
                va = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
              else if (va.y >= y1)
                return;
              vb = {
                x: (y1 - fb) / fm,
                y: y1
              };
            } else {
              if (!va)
                va = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
              else if (va.y < y0)
                return;
              vb = {
                x: (y0 - fb) / fm,
                y: y0
              };
            }
          } else {
            if (ly < ry) {
              if (!va)
                va = {
                  x: x0,
                  y: fm * x0 + fb
                };
              else if (va.x >= x1)
                return;
              vb = {
                x: x1,
                y: fm * x1 + fb
              };
            } else {
              if (!va)
                va = {
                  x: x1,
                  y: fm * x1 + fb
                };
              else if (va.x < x0)
                return;
              vb = {
                x: x0,
                y: fm * x0 + fb
              };
            }
          }
        }
        edge.a = va;
        edge.b = vb;
        return true;
      }
      function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
      }
      function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va)
          d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb)
          d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
      }
      function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
      }
      function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
          edge.a = vertex;
          edge.l = lSite;
          edge.r = rSite;
        } else if (edge.l === rSite) {
          edge.b = vertex;
        } else {
          edge.a = vertex;
        }
      }
      function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a,
            vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
      }
      d3_geom_voronoiHalfEdge.prototype = {
        start: function() {
          return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function() {
          return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
      };
      function d3_geom_voronoiRedBlackTree() {
        this._ = null;
      }
      function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
      }
      d3_geom_voronoiRedBlackTree.prototype = {
        insert: function(after, node) {
          var parent,
              grandpa,
              uncle;
          if (after) {
            node.P = after;
            node.N = after.N;
            if (after.N)
              after.N.P = node;
            after.N = node;
            if (after.R) {
              after = after.R;
              while (after.L)
                after = after.L;
              after.L = node;
            } else {
              after.R = node;
            }
            parent = after;
          } else if (this._) {
            after = d3_geom_voronoiRedBlackFirst(this._);
            node.P = null;
            node.N = after;
            after.P = after.L = node;
            parent = after;
          } else {
            node.P = node.N = null;
            this._ = node;
            parent = null;
          }
          node.L = node.R = null;
          node.U = parent;
          node.C = true;
          after = node;
          while (parent && parent.C) {
            grandpa = parent.U;
            if (parent === grandpa.L) {
              uncle = grandpa.R;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.R) {
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, grandpa);
              }
            } else {
              uncle = grandpa.L;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.L) {
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
              }
            }
            parent = after.U;
          }
          this._.C = false;
        },
        remove: function(node) {
          if (node.N)
            node.N.P = node.P;
          if (node.P)
            node.P.N = node.N;
          node.N = node.P = null;
          var parent = node.U,
              sibling,
              left = node.L,
              right = node.R,
              next,
              red;
          if (!left)
            next = right;
          else if (!right)
            next = left;
          else
            next = d3_geom_voronoiRedBlackFirst(right);
          if (parent) {
            if (parent.L === node)
              parent.L = next;
            else
              parent.R = next;
          } else {
            this._ = next;
          }
          if (left && right) {
            red = next.C;
            next.C = node.C;
            next.L = left;
            left.U = next;
            if (next !== right) {
              parent = next.U;
              next.U = node.U;
              node = next.R;
              parent.L = node;
              next.R = right;
              right.U = next;
            } else {
              next.U = parent;
              parent = next;
              node = next.R;
            }
          } else {
            red = node.C;
            node = next;
          }
          if (node)
            node.U = parent;
          if (red)
            return;
          if (node && node.C) {
            node.C = false;
            return;
          }
          do {
            if (node === this._)
              break;
            if (node === parent.L) {
              sibling = parent.R;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                sibling = parent.R;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.R || !sibling.R.C) {
                  sibling.L.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, sibling);
                  sibling = parent.R;
                }
                sibling.C = parent.C;
                parent.C = sibling.R.C = false;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                node = this._;
                break;
              }
            } else {
              sibling = parent.L;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                sibling = parent.L;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.L || !sibling.L.C) {
                  sibling.R.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                  sibling = parent.L;
                }
                sibling.C = parent.C;
                parent.C = sibling.L.C = false;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                node = this._;
                break;
              }
            }
            sibling.C = true;
            node = parent;
            parent = parent.U;
          } while (!node.C);
          if (node)
            node.C = false;
        }
      };
      function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node,
            q = node.R,
            parent = p.U;
        if (parent) {
          if (parent.L === p)
            parent.L = q;
          else
            parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R)
          p.R.U = p;
        q.L = p;
      }
      function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node,
            q = node.L,
            parent = p.U;
        if (parent) {
          if (parent.L === p)
            parent.L = q;
          else
            parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L)
          p.L.U = p;
        q.R = p;
      }
      function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L)
          node = node.L;
        return node;
      }
      function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(),
            x0,
            y0,
            circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
          circle = d3_geom_voronoiFirstCircle;
          if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
            if (site.x !== x0 || site.y !== y0) {
              d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
              d3_geom_voronoiAddBeach(site);
              x0 = site.x, y0 = site.y;
            }
            site = sites.pop();
          } else if (circle) {
            d3_geom_voronoiRemoveBeach(circle.arc);
          } else {
            break;
          }
        }
        if (bbox)
          d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
          cells: d3_geom_voronoiCells,
          edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
      }
      function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
      }
      d3.geom.voronoi = function(points) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            fx = x,
            fy = y,
            clipExtent = d3_geom_voronoiClipExtent;
        if (points)
          return voronoi(points);
        function voronoi(data) {
          var polygons = new Array(data.length),
              x0 = clipExtent[0][0],
              y0 = clipExtent[0][1],
              x1 = clipExtent[1][0],
              y1 = clipExtent[1][1];
          d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
            var edges = cell.edges,
                site = cell.site,
                polygon = polygons[i] = edges.length ? edges.map(function(e) {
                  var s = e.start();
                  return [s.x, s.y];
                }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
            polygon.point = data[i];
          });
          return polygons;
        }
        function sites(data) {
          return data.map(function(d, i) {
            return {
              x: Math.round(fx(d, i) / ε) * ε,
              y: Math.round(fy(d, i) / ε) * ε,
              i: i
            };
          });
        }
        voronoi.links = function(data) {
          return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
            return edge.l && edge.r;
          }).map(function(edge) {
            return {
              source: data[edge.l.i],
              target: data[edge.r.i]
            };
          });
        };
        voronoi.triangles = function(data) {
          var triangles = [];
          d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
            var site = cell.site,
                edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),
                j = -1,
                m = edges.length,
                e0,
                s0,
                e1 = edges[m - 1].edge,
                s1 = e1.l === site ? e1.r : e1.l;
            while (++j < m) {
              e0 = e1;
              s0 = s1;
              e1 = edges[j].edge;
              s1 = e1.l === site ? e1.r : e1.l;
              if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                triangles.push([data[i], data[s0.i], data[s1.i]]);
              }
            }
          });
          return triangles;
        };
        voronoi.x = function(_) {
          return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function(_) {
          return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function(_) {
          if (!arguments.length)
            return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
          clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
          return voronoi;
        };
        voronoi.size = function(_) {
          if (!arguments.length)
            return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
          return voronoi.clipExtent(_ && [[0, 0], _]);
        };
        return voronoi;
      };
      var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
      function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
      }
      d3.geom.delaunay = function(vertices) {
        return d3.geom.voronoi().triangles(vertices);
      };
      d3.geom.quadtree = function(points, x1, y1, x2, y2) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            compat;
        if (compat = arguments.length) {
          x = d3_geom_quadtreeCompatX;
          y = d3_geom_quadtreeCompatY;
          if (compat === 3) {
            y2 = y1;
            x2 = x1;
            y1 = x1 = 0;
          }
          return quadtree(points);
        }
        function quadtree(data) {
          var d,
              fx = d3_functor(x),
              fy = d3_functor(y),
              xs,
              ys,
              i,
              n,
              x1_,
              y1_,
              x2_,
              y2_;
          if (x1 != null) {
            x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
          } else {
            x2_ = y2_ = -(x1_ = y1_ = Infinity);
            xs = [], ys = [];
            n = data.length;
            if (compat)
              for (i = 0; i < n; ++i) {
                d = data[i];
                if (d.x < x1_)
                  x1_ = d.x;
                if (d.y < y1_)
                  y1_ = d.y;
                if (d.x > x2_)
                  x2_ = d.x;
                if (d.y > y2_)
                  y2_ = d.y;
                xs.push(d.x);
                ys.push(d.y);
              }
            else
              for (i = 0; i < n; ++i) {
                var x_ = +fx(d = data[i], i),
                    y_ = +fy(d, i);
                if (x_ < x1_)
                  x1_ = x_;
                if (y_ < y1_)
                  y1_ = y_;
                if (x_ > x2_)
                  x2_ = x_;
                if (y_ > y2_)
                  y2_ = y_;
                xs.push(x_);
                ys.push(y_);
              }
          }
          var dx = x2_ - x1_,
              dy = y2_ - y1_;
          if (dx > dy)
            y2_ = y1_ + dx;
          else
            x2_ = x1_ + dy;
          function insert(n, d, x, y, x1, y1, x2, y2) {
            if (isNaN(x) || isNaN(y))
              return;
            if (n.leaf) {
              var nx = n.x,
                  ny = n.y;
              if (nx != null) {
                if (abs(nx - x) + abs(ny - y) < .01) {
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                } else {
                  var nPoint = n.point;
                  n.x = n.y = n.point = null;
                  insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                }
              } else {
                n.x = x, n.y = y, n.point = d;
              }
            } else {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          }
          function insertChild(n, d, x, y, x1, y1, x2, y2) {
            var xm = (x1 + x2) * .5,
                ym = (y1 + y2) * .5,
                right = x >= xm,
                below = y >= ym,
                i = below << 1 | right;
            n.leaf = false;
            n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
            if (right)
              x1 = xm;
            else
              x2 = xm;
            if (below)
              y1 = ym;
            else
              y2 = ym;
            insert(n, d, x, y, x1, y1, x2, y2);
          }
          var root = d3_geom_quadtreeNode();
          root.add = function(d) {
            insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
          };
          root.visit = function(f) {
            d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
          };
          root.find = function(point) {
            return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
          };
          i = -1;
          if (x1 == null) {
            while (++i < n) {
              insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
            }
            --i;
          } else
            data.forEach(root.add);
          xs = ys = data = d = null;
          return root;
        }
        quadtree.x = function(_) {
          return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function(_) {
          return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function(_) {
          if (!arguments.length)
            return x1 == null ? null : [[x1, y1], [x2, y2]];
          if (_ == null)
            x1 = y1 = x2 = y2 = null;
          else
            x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
          return quadtree;
        };
        quadtree.size = function(_) {
          if (!arguments.length)
            return x1 == null ? null : [x2 - x1, y2 - y1];
          if (_ == null)
            x1 = y1 = x2 = y2 = null;
          else
            x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
          return quadtree;
        };
        return quadtree;
      };
      function d3_geom_quadtreeCompatX(d) {
        return d.x;
      }
      function d3_geom_quadtreeCompatY(d) {
        return d.y;
      }
      function d3_geom_quadtreeNode() {
        return {
          leaf: true,
          nodes: [],
          point: null,
          x: null,
          y: null
        };
      }
      function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
          var sx = (x1 + x2) * .5,
              sy = (y1 + y2) * .5,
              children = node.nodes;
          if (children[0])
            d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
          if (children[1])
            d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
          if (children[2])
            d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
          if (children[3])
            d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
      }
      function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity,
            closestPoint;
        (function find(node, x1, y1, x2, y2) {
          if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0)
            return;
          if (point = node.point) {
            var point,
                dx = x - node.x,
                dy = y - node.y,
                distance2 = dx * dx + dy * dy;
            if (distance2 < minDistance2) {
              var distance = Math.sqrt(minDistance2 = distance2);
              x0 = x - distance, y0 = y - distance;
              x3 = x + distance, y3 = y + distance;
              closestPoint = point;
            }
          }
          var children = node.nodes,
              xm = (x1 + x2) * .5,
              ym = (y1 + y2) * .5,
              right = x >= xm,
              below = y >= ym;
          for (var i = below << 1 | right,
              j = i + 4; i < j; ++i) {
            if (node = children[i & 3])
              switch (i & 3) {
                case 0:
                  find(node, x1, y1, xm, ym);
                  break;
                case 1:
                  find(node, xm, y1, x2, ym);
                  break;
                case 2:
                  find(node, x1, ym, xm, y2);
                  break;
                case 3:
                  find(node, xm, ym, x2, y2);
                  break;
              }
          }
        })(root, x0, y0, x3, y3);
        return closestPoint;
      }
      d3.interpolateRgb = d3_interpolateRgb;
      function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r,
            ag = a.g,
            ab = a.b,
            br = b.r - ar,
            bg = b.g - ag,
            bb = b.b - ab;
        return function(t) {
          return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
      }
      d3.interpolateObject = d3_interpolateObject;
      function d3_interpolateObject(a, b) {
        var i = {},
            c = {},
            k;
        for (k in a) {
          if (k in b) {
            i[k] = d3_interpolate(a[k], b[k]);
          } else {
            c[k] = a[k];
          }
        }
        for (k in b) {
          if (!(k in a)) {
            c[k] = b[k];
          }
        }
        return function(t) {
          for (k in i)
            c[k] = i[k](t);
          return c;
        };
      }
      d3.interpolateNumber = d3_interpolateNumber;
      function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function(t) {
          return a * (1 - t) + b * t;
        };
      }
      d3.interpolateString = d3_interpolateString;
      function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0,
            am,
            bm,
            bs,
            i = -1,
            s = [],
            q = [];
        a = a + "", b = b + "";
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
          if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s[i])
              s[i] += bs;
            else
              s[++i] = bs;
          }
          if ((am = am[0]) === (bm = bm[0])) {
            if (s[i])
              s[i] += bm;
            else
              s[++i] = bm;
          } else {
            s[++i] = null;
            q.push({
              i: i,
              x: d3_interpolateNumber(am, bm)
            });
          }
          bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
          bs = b.slice(bi);
          if (s[i])
            s[i] += bs;
          else
            s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
          return b(t) + "";
        }) : function() {
          return b;
        } : (b = q.length, function(t) {
          for (var i = 0,
              o; i < b; ++i)
            s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
      }
      var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
          d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
      d3.interpolate = d3_interpolate;
      function d3_interpolate(a, b) {
        var i = d3.interpolators.length,
            f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b)))
          ;
        return f;
      }
      d3.interpolators = [function(a, b) {
        var t = typeof b;
        return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
      }];
      d3.interpolateArray = d3_interpolateArray;
      function d3_interpolateArray(a, b) {
        var x = [],
            c = [],
            na = a.length,
            nb = b.length,
            n0 = Math.min(a.length, b.length),
            i;
        for (i = 0; i < n0; ++i)
          x.push(d3_interpolate(a[i], b[i]));
        for (; i < na; ++i)
          c[i] = a[i];
        for (; i < nb; ++i)
          c[i] = b[i];
        return function(t) {
          for (i = 0; i < n0; ++i)
            c[i] = x[i](t);
          return c;
        };
      }
      var d3_ease_default = function() {
        return d3_identity;
      };
      var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
          return d3_ease_quad;
        },
        cubic: function() {
          return d3_ease_cubic;
        },
        sin: function() {
          return d3_ease_sin;
        },
        exp: function() {
          return d3_ease_exp;
        },
        circle: function() {
          return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
          return d3_ease_bounce;
        }
      });
      var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
          return d3_ease_reflect(d3_ease_reverse(f));
        }
      });
      d3.ease = function(name) {
        var i = name.indexOf("-"),
            t = i >= 0 ? name.slice(0, i) : name,
            m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
      };
      function d3_ease_clamp(f) {
        return function(t) {
          return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
      }
      function d3_ease_reverse(f) {
        return function(t) {
          return 1 - f(1 - t);
        };
      }
      function d3_ease_reflect(f) {
        return function(t) {
          return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
      }
      function d3_ease_quad(t) {
        return t * t;
      }
      function d3_ease_cubic(t) {
        return t * t * t;
      }
      function d3_ease_cubicInOut(t) {
        if (t <= 0)
          return 0;
        if (t >= 1)
          return 1;
        var t2 = t * t,
            t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
      }
      function d3_ease_poly(e) {
        return function(t) {
          return Math.pow(t, e);
        };
      }
      function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
      }
      function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
      }
      function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
      function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2)
          p = .45;
        if (arguments.length)
          s = p / τ * Math.asin(1 / a);
        else
          a = 1, s = p / 4;
        return function(t) {
          return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        };
      }
      function d3_ease_back(s) {
        if (!s)
          s = 1.70158;
        return function(t) {
          return t * t * ((s + 1) * t - s);
        };
      }
      function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
      }
      d3.interpolateHcl = d3_interpolateHcl;
      function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h,
            ac = a.c,
            al = a.l,
            bh = b.h - ah,
            bc = b.c - ac,
            bl = b.l - al;
        if (isNaN(bc))
          bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh))
          bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
          bh -= 360;
        else if (bh < -180)
          bh += 360;
        return function(t) {
          return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
      }
      d3.interpolateHsl = d3_interpolateHsl;
      function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h,
            as = a.s,
            al = a.l,
            bh = b.h - ah,
            bs = b.s - as,
            bl = b.l - al;
        if (isNaN(bs))
          bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh))
          bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
          bh -= 360;
        else if (bh < -180)
          bh += 360;
        return function(t) {
          return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
      }
      d3.interpolateLab = d3_interpolateLab;
      function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l,
            aa = a.a,
            ab = a.b,
            bl = b.l - al,
            ba = b.a - aa,
            bb = b.b - ab;
        return function(t) {
          return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
      }
      d3.interpolateRound = d3_interpolateRound;
      function d3_interpolateRound(a, b) {
        b -= a;
        return function(t) {
          return Math.round(a + b * t);
        };
      }
      d3.transform = function(string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function(string) {
          if (string != null) {
            g.setAttribute("transform", string);
            var t = g.transform.baseVal.consolidate();
          }
          return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
      };
      function d3_transform(m) {
        var r0 = [m.a, m.b],
            r1 = [m.c, m.d],
            kx = d3_transformNormalize(r0),
            kz = d3_transformDot(r0, r1),
            ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
          r0[0] *= -1;
          r0[1] *= -1;
          kx *= -1;
          kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [m.e, m.f];
        this.scale = [kx, ky];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
      }
      d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
      };
      function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      }
      function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
          a[0] /= k;
          a[1] /= k;
        }
        return k;
      }
      function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
      }
      var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
      };
      d3.interpolateTransform = d3_interpolateTransform;
      function d3_interpolateTransform(a, b) {
        var s = [],
            q = [],
            n,
            A = d3.transform(a),
            B = d3.transform(b),
            ta = A.translate,
            tb = B.translate,
            ra = A.rotate,
            rb = B.rotate,
            wa = A.skew,
            wb = B.skew,
            ka = A.scale,
            kb = B.scale;
        if (ta[0] != tb[0] || ta[1] != tb[1]) {
          s.push("translate(", null, ",", null, ")");
          q.push({
            i: 1,
            x: d3_interpolateNumber(ta[0], tb[0])
          }, {
            i: 3,
            x: d3_interpolateNumber(ta[1], tb[1])
          });
        } else if (tb[0] || tb[1]) {
          s.push("translate(" + tb + ")");
        } else {
          s.push("");
        }
        if (ra != rb) {
          if (ra - rb > 180)
            rb += 360;
          else if (rb - ra > 180)
            ra += 360;
          q.push({
            i: s.push(s.pop() + "rotate(", null, ")") - 2,
            x: d3_interpolateNumber(ra, rb)
          });
        } else if (rb) {
          s.push(s.pop() + "rotate(" + rb + ")");
        }
        if (wa != wb) {
          q.push({
            i: s.push(s.pop() + "skewX(", null, ")") - 2,
            x: d3_interpolateNumber(wa, wb)
          });
        } else if (wb) {
          s.push(s.pop() + "skewX(" + wb + ")");
        }
        if (ka[0] != kb[0] || ka[1] != kb[1]) {
          n = s.push(s.pop() + "scale(", null, ",", null, ")");
          q.push({
            i: n - 4,
            x: d3_interpolateNumber(ka[0], kb[0])
          }, {
            i: n - 2,
            x: d3_interpolateNumber(ka[1], kb[1])
          });
        } else if (kb[0] != 1 || kb[1] != 1) {
          s.push(s.pop() + "scale(" + kb + ")");
        }
        n = q.length;
        return function(t) {
          var i = -1,
              o;
          while (++i < n)
            s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      }
      function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
          return (x - a) / b;
        };
      }
      function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
          return Math.max(0, Math.min(1, (x - a) / b));
        };
      }
      d3.layout = {};
      d3.layout.bundle = function() {
        return function(links) {
          var paths = [],
              i = -1,
              n = links.length;
          while (++i < n)
            paths.push(d3_layout_bundlePath(links[i]));
          return paths;
        };
      };
      function d3_layout_bundlePath(link) {
        var start = link.source,
            end = link.target,
            lca = d3_layout_bundleLeastCommonAncestor(start, end),
            points = [start];
        while (start !== lca) {
          start = start.parent;
          points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
          points.splice(k, 0, end);
          end = end.parent;
        }
        return points;
      }
      function d3_layout_bundleAncestors(node) {
        var ancestors = [],
            parent = node.parent;
        while (parent != null) {
          ancestors.push(node);
          node = parent;
          parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
      }
      function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b)
          return a;
        var aNodes = d3_layout_bundleAncestors(a),
            bNodes = d3_layout_bundleAncestors(b),
            aNode = aNodes.pop(),
            bNode = bNodes.pop(),
            sharedNode = null;
        while (aNode === bNode) {
          sharedNode = aNode;
          aNode = aNodes.pop();
          bNode = bNodes.pop();
        }
        return sharedNode;
      }
      d3.layout.chord = function() {
        var chord = {},
            chords,
            groups,
            matrix,
            n,
            padding = 0,
            sortGroups,
            sortSubgroups,
            sortChords;
        function relayout() {
          var subgroups = {},
              groupSums = [],
              groupIndex = d3.range(n),
              subgroupIndex = [],
              k,
              x,
              x0,
              i,
              j;
          chords = [];
          groups = [];
          k = 0, i = -1;
          while (++i < n) {
            x = 0, j = -1;
            while (++j < n) {
              x += matrix[i][j];
            }
            groupSums.push(x);
            subgroupIndex.push(d3.range(n));
            k += x;
          }
          if (sortGroups) {
            groupIndex.sort(function(a, b) {
              return sortGroups(groupSums[a], groupSums[b]);
            });
          }
          if (sortSubgroups) {
            subgroupIndex.forEach(function(d, i) {
              d.sort(function(a, b) {
                return sortSubgroups(matrix[i][a], matrix[i][b]);
              });
            });
          }
          k = (τ - padding * n) / k;
          x = 0, i = -1;
          while (++i < n) {
            x0 = x, j = -1;
            while (++j < n) {
              var di = groupIndex[i],
                  dj = subgroupIndex[di][j],
                  v = matrix[di][dj],
                  a0 = x,
                  a1 = x += v * k;
              subgroups[di + "-" + dj] = {
                index: di,
                subindex: dj,
                startAngle: a0,
                endAngle: a1,
                value: v
              };
            }
            groups[di] = {
              index: di,
              startAngle: x0,
              endAngle: x,
              value: (x - x0) / k
            };
            x += padding;
          }
          i = -1;
          while (++i < n) {
            j = i - 1;
            while (++j < n) {
              var source = subgroups[i + "-" + j],
                  target = subgroups[j + "-" + i];
              if (source.value || target.value) {
                chords.push(source.value < target.value ? {
                  source: target,
                  target: source
                } : {
                  source: source,
                  target: target
                });
              }
            }
          }
          if (sortChords)
            resort();
        }
        function resort() {
          chords.sort(function(a, b) {
            return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
          });
        }
        chord.matrix = function(x) {
          if (!arguments.length)
            return matrix;
          n = (matrix = x) && matrix.length;
          chords = groups = null;
          return chord;
        };
        chord.padding = function(x) {
          if (!arguments.length)
            return padding;
          padding = x;
          chords = groups = null;
          return chord;
        };
        chord.sortGroups = function(x) {
          if (!arguments.length)
            return sortGroups;
          sortGroups = x;
          chords = groups = null;
          return chord;
        };
        chord.sortSubgroups = function(x) {
          if (!arguments.length)
            return sortSubgroups;
          sortSubgroups = x;
          chords = null;
          return chord;
        };
        chord.sortChords = function(x) {
          if (!arguments.length)
            return sortChords;
          sortChords = x;
          if (chords)
            resort();
          return chord;
        };
        chord.chords = function() {
          if (!chords)
            relayout();
          return chords;
        };
        chord.groups = function() {
          if (!groups)
            relayout();
          return groups;
        };
        return chord;
      };
      d3.layout.force = function() {
        var force = {},
            event = d3.dispatch("start", "tick", "end"),
            size = [1, 1],
            drag,
            alpha,
            friction = .9,
            linkDistance = d3_layout_forceLinkDistance,
            linkStrength = d3_layout_forceLinkStrength,
            charge = -30,
            chargeDistance2 = d3_layout_forceChargeDistance2,
            gravity = .1,
            theta2 = .64,
            nodes = [],
            links = [],
            distances,
            strengths,
            charges;
        function repulse(node) {
          return function(quad, x1, _, x2) {
            if (quad.point !== node) {
              var dx = quad.cx - node.x,
                  dy = quad.cy - node.y,
                  dw = x2 - x1,
                  dn = dx * dx + dy * dy;
              if (dw * dw / theta2 < dn) {
                if (dn < chargeDistance2) {
                  var k = quad.charge / dn;
                  node.px -= dx * k;
                  node.py -= dy * k;
                }
                return true;
              }
              if (quad.point && dn && dn < chargeDistance2) {
                var k = quad.pointCharge / dn;
                node.px -= dx * k;
                node.py -= dy * k;
              }
            }
            return !quad.charge;
          };
        }
        force.tick = function() {
          if ((alpha *= .99) < .005) {
            event.end({
              type: "end",
              alpha: alpha = 0
            });
            return true;
          }
          var n = nodes.length,
              m = links.length,
              q,
              i,
              o,
              s,
              t,
              l,
              k,
              x,
              y;
          for (i = 0; i < m; ++i) {
            o = links[i];
            s = o.source;
            t = o.target;
            x = t.x - s.x;
            y = t.y - s.y;
            if (l = x * x + y * y) {
              l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
              x *= l;
              y *= l;
              t.x -= x * (k = s.weight / (t.weight + s.weight));
              t.y -= y * k;
              s.x += x * (k = 1 - k);
              s.y += y * k;
            }
          }
          if (k = alpha * gravity) {
            x = size[0] / 2;
            y = size[1] / 2;
            i = -1;
            if (k)
              while (++i < n) {
                o = nodes[i];
                o.x += (x - o.x) * k;
                o.y += (y - o.y) * k;
              }
          }
          if (charge) {
            d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
            i = -1;
            while (++i < n) {
              if (!(o = nodes[i]).fixed) {
                q.visit(repulse(o));
              }
            }
          }
          i = -1;
          while (++i < n) {
            o = nodes[i];
            if (o.fixed) {
              o.x = o.px;
              o.y = o.py;
            } else {
              o.x -= (o.px - (o.px = o.x)) * friction;
              o.y -= (o.py - (o.py = o.y)) * friction;
            }
          }
          event.tick({
            type: "tick",
            alpha: alpha
          });
        };
        force.nodes = function(x) {
          if (!arguments.length)
            return nodes;
          nodes = x;
          return force;
        };
        force.links = function(x) {
          if (!arguments.length)
            return links;
          links = x;
          return force;
        };
        force.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return force;
        };
        force.linkDistance = function(x) {
          if (!arguments.length)
            return linkDistance;
          linkDistance = typeof x === "function" ? x : +x;
          return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
          if (!arguments.length)
            return linkStrength;
          linkStrength = typeof x === "function" ? x : +x;
          return force;
        };
        force.friction = function(x) {
          if (!arguments.length)
            return friction;
          friction = +x;
          return force;
        };
        force.charge = function(x) {
          if (!arguments.length)
            return charge;
          charge = typeof x === "function" ? x : +x;
          return force;
        };
        force.chargeDistance = function(x) {
          if (!arguments.length)
            return Math.sqrt(chargeDistance2);
          chargeDistance2 = x * x;
          return force;
        };
        force.gravity = function(x) {
          if (!arguments.length)
            return gravity;
          gravity = +x;
          return force;
        };
        force.theta = function(x) {
          if (!arguments.length)
            return Math.sqrt(theta2);
          theta2 = x * x;
          return force;
        };
        force.alpha = function(x) {
          if (!arguments.length)
            return alpha;
          x = +x;
          if (alpha) {
            if (x > 0)
              alpha = x;
            else
              alpha = 0;
          } else if (x > 0) {
            event.start({
              type: "start",
              alpha: alpha = x
            });
            d3.timer(force.tick);
          }
          return force;
        };
        force.start = function() {
          var i,
              n = nodes.length,
              m = links.length,
              w = size[0],
              h = size[1],
              neighbors,
              o;
          for (i = 0; i < n; ++i) {
            (o = nodes[i]).index = i;
            o.weight = 0;
          }
          for (i = 0; i < m; ++i) {
            o = links[i];
            if (typeof o.source == "number")
              o.source = nodes[o.source];
            if (typeof o.target == "number")
              o.target = nodes[o.target];
            ++o.source.weight;
            ++o.target.weight;
          }
          for (i = 0; i < n; ++i) {
            o = nodes[i];
            if (isNaN(o.x))
              o.x = position("x", w);
            if (isNaN(o.y))
              o.y = position("y", h);
            if (isNaN(o.px))
              o.px = o.x;
            if (isNaN(o.py))
              o.py = o.y;
          }
          distances = [];
          if (typeof linkDistance === "function")
            for (i = 0; i < m; ++i)
              distances[i] = +linkDistance.call(this, links[i], i);
          else
            for (i = 0; i < m; ++i)
              distances[i] = linkDistance;
          strengths = [];
          if (typeof linkStrength === "function")
            for (i = 0; i < m; ++i)
              strengths[i] = +linkStrength.call(this, links[i], i);
          else
            for (i = 0; i < m; ++i)
              strengths[i] = linkStrength;
          charges = [];
          if (typeof charge === "function")
            for (i = 0; i < n; ++i)
              charges[i] = +charge.call(this, nodes[i], i);
          else
            for (i = 0; i < n; ++i)
              charges[i] = charge;
          function position(dimension, size) {
            if (!neighbors) {
              neighbors = new Array(n);
              for (j = 0; j < n; ++j) {
                neighbors[j] = [];
              }
              for (j = 0; j < m; ++j) {
                var o = links[j];
                neighbors[o.source.index].push(o.target);
                neighbors[o.target.index].push(o.source);
              }
            }
            var candidates = neighbors[i],
                j = -1,
                l = candidates.length,
                x;
            while (++j < l)
              if (!isNaN(x = candidates[j][dimension]))
                return x;
            return Math.random() * size;
          }
          return force.resume();
        };
        force.resume = function() {
          return force.alpha(.1);
        };
        force.stop = function() {
          return force.alpha(0);
        };
        force.drag = function() {
          if (!drag)
            drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
          if (!arguments.length)
            return drag;
          this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
          d.px = d3.event.x, d.py = d3.event.y;
          force.resume();
        }
        return d3.rebind(force, event, "on");
      };
      function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
      }
      function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
      }
      function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
      }
      function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
      }
      function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0,
            cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
          var nodes = quad.nodes,
              n = nodes.length,
              i = -1,
              c;
          while (++i < n) {
            c = nodes[i];
            if (c == null)
              continue;
            d3_layout_forceAccumulate(c, alpha, charges);
            quad.charge += c.charge;
            cx += c.charge * c.cx;
            cy += c.charge * c.cy;
          }
        }
        if (quad.point) {
          if (!quad.leaf) {
            quad.point.x += Math.random() - .5;
            quad.point.y += Math.random() - .5;
          }
          var k = alpha * charges[quad.point.index];
          quad.charge += quad.pointCharge = k;
          cx += k * quad.point.x;
          cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
      }
      var d3_layout_forceLinkDistance = 20,
          d3_layout_forceLinkStrength = 1,
          d3_layout_forceChargeDistance2 = Infinity;
      d3.layout.hierarchy = function() {
        var sort = d3_layout_hierarchySort,
            children = d3_layout_hierarchyChildren,
            value = d3_layout_hierarchyValue;
        function hierarchy(root) {
          var stack = [root],
              nodes = [],
              node;
          root.depth = 0;
          while ((node = stack.pop()) != null) {
            nodes.push(node);
            if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
              var n,
                  childs,
                  child;
              while (--n >= 0) {
                stack.push(child = childs[n]);
                child.parent = node;
                child.depth = node.depth + 1;
              }
              if (value)
                node.value = 0;
              node.children = childs;
            } else {
              if (value)
                node.value = +value.call(hierarchy, node, node.depth) || 0;
              delete node.children;
            }
          }
          d3_layout_hierarchyVisitAfter(root, function(node) {
            var childs,
                parent;
            if (sort && (childs = node.children))
              childs.sort(sort);
            if (value && (parent = node.parent))
              parent.value += node.value;
          });
          return nodes;
        }
        hierarchy.sort = function(x) {
          if (!arguments.length)
            return sort;
          sort = x;
          return hierarchy;
        };
        hierarchy.children = function(x) {
          if (!arguments.length)
            return children;
          children = x;
          return hierarchy;
        };
        hierarchy.value = function(x) {
          if (!arguments.length)
            return value;
          value = x;
          return hierarchy;
        };
        hierarchy.revalue = function(root) {
          if (value) {
            d3_layout_hierarchyVisitBefore(root, function(node) {
              if (node.children)
                node.value = 0;
            });
            d3_layout_hierarchyVisitAfter(root, function(node) {
              var parent;
              if (!node.children)
                node.value = +value.call(hierarchy, node, node.depth) || 0;
              if (parent = node.parent)
                parent.value += node.value;
            });
          }
          return root;
        };
        return hierarchy;
      };
      function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
      }
      function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [node];
        while ((node = nodes.pop()) != null) {
          callback(node);
          if ((children = node.children) && (n = children.length)) {
            var n,
                children;
            while (--n >= 0)
              nodes.push(children[n]);
          }
        }
      }
      function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [node],
            nodes2 = [];
        while ((node = nodes.pop()) != null) {
          nodes2.push(node);
          if ((children = node.children) && (n = children.length)) {
            var i = -1,
                n,
                children;
            while (++i < n)
              nodes.push(children[i]);
          }
        }
        while ((node = nodes2.pop()) != null) {
          callback(node);
        }
      }
      function d3_layout_hierarchyChildren(d) {
        return d.children;
      }
      function d3_layout_hierarchyValue(d) {
        return d.value;
      }
      function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
      }
      function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
          return (parent.children || []).map(function(child) {
            return {
              source: parent,
              target: child
            };
          });
        }));
      }
      d3.layout.partition = function() {
        var hierarchy = d3.layout.hierarchy(),
            size = [1, 1];
        function position(node, x, dx, dy) {
          var children = node.children;
          node.x = x;
          node.y = node.depth * dy;
          node.dx = dx;
          node.dy = dy;
          if (children && (n = children.length)) {
            var i = -1,
                n,
                c,
                d;
            dx = node.value ? dx / node.value : 0;
            while (++i < n) {
              position(c = children[i], x, d = c.value * dx, dy);
              x += d;
            }
          }
        }
        function depth(node) {
          var children = node.children,
              d = 0;
          if (children && (n = children.length)) {
            var i = -1,
                n;
            while (++i < n)
              d = Math.max(d, depth(children[i]));
          }
          return 1 + d;
        }
        function partition(d, i) {
          var nodes = hierarchy.call(this, d, i);
          position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
          return nodes;
        }
        partition.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
      };
      d3.layout.pie = function() {
        var value = Number,
            sort = d3_layout_pieSortByValue,
            startAngle = 0,
            endAngle = τ,
            padAngle = 0;
        function pie(data) {
          var n = data.length,
              values = data.map(function(d, i) {
                return +value.call(pie, d, i);
              }),
              a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle),
              da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a,
              p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)),
              pa = p * (da < 0 ? -1 : 1),
              k = (da - n * pa) / d3.sum(values),
              index = d3.range(n),
              arcs = [],
              v;
          if (sort != null)
            index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
              return values[j] - values[i];
            } : function(i, j) {
              return sort(data[i], data[j]);
            });
          index.forEach(function(i) {
            arcs[i] = {
              data: data[i],
              value: v = values[i],
              startAngle: a,
              endAngle: a += v * k + pa,
              padAngle: p
            };
          });
          return arcs;
        }
        pie.value = function(_) {
          if (!arguments.length)
            return value;
          value = _;
          return pie;
        };
        pie.sort = function(_) {
          if (!arguments.length)
            return sort;
          sort = _;
          return pie;
        };
        pie.startAngle = function(_) {
          if (!arguments.length)
            return startAngle;
          startAngle = _;
          return pie;
        };
        pie.endAngle = function(_) {
          if (!arguments.length)
            return endAngle;
          endAngle = _;
          return pie;
        };
        pie.padAngle = function(_) {
          if (!arguments.length)
            return padAngle;
          padAngle = _;
          return pie;
        };
        return pie;
      };
      var d3_layout_pieSortByValue = {};
      d3.layout.stack = function() {
        var values = d3_identity,
            order = d3_layout_stackOrderDefault,
            offset = d3_layout_stackOffsetZero,
            out = d3_layout_stackOut,
            x = d3_layout_stackX,
            y = d3_layout_stackY;
        function stack(data, index) {
          if (!(n = data.length))
            return data;
          var series = data.map(function(d, i) {
            return values.call(stack, d, i);
          });
          var points = series.map(function(d) {
            return d.map(function(v, i) {
              return [x.call(stack, v, i), y.call(stack, v, i)];
            });
          });
          var orders = order.call(stack, points, index);
          series = d3.permute(series, orders);
          points = d3.permute(points, orders);
          var offsets = offset.call(stack, points, index);
          var m = series[0].length,
              n,
              i,
              j,
              o;
          for (j = 0; j < m; ++j) {
            out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
            for (i = 1; i < n; ++i) {
              out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
            }
          }
          return data;
        }
        stack.values = function(x) {
          if (!arguments.length)
            return values;
          values = x;
          return stack;
        };
        stack.order = function(x) {
          if (!arguments.length)
            return order;
          order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
          return stack;
        };
        stack.offset = function(x) {
          if (!arguments.length)
            return offset;
          offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
          return stack;
        };
        stack.x = function(z) {
          if (!arguments.length)
            return x;
          x = z;
          return stack;
        };
        stack.y = function(z) {
          if (!arguments.length)
            return y;
          y = z;
          return stack;
        };
        stack.out = function(z) {
          if (!arguments.length)
            return out;
          out = z;
          return stack;
        };
        return stack;
      };
      function d3_layout_stackX(d) {
        return d.x;
      }
      function d3_layout_stackY(d) {
        return d.y;
      }
      function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
      }
      var d3_layout_stackOrders = d3.map({
        "inside-out": function(data) {
          var n = data.length,
              i,
              j,
              max = data.map(d3_layout_stackMaxIndex),
              sums = data.map(d3_layout_stackReduceSum),
              index = d3.range(n).sort(function(a, b) {
                return max[a] - max[b];
              }),
              top = 0,
              bottom = 0,
              tops = [],
              bottoms = [];
          for (i = 0; i < n; ++i) {
            j = index[i];
            if (top < bottom) {
              top += sums[j];
              tops.push(j);
            } else {
              bottom += sums[j];
              bottoms.push(j);
            }
          }
          return bottoms.reverse().concat(tops);
        },
        reverse: function(data) {
          return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
      });
      var d3_layout_stackOffsets = d3.map({
        silhouette: function(data) {
          var n = data.length,
              m = data[0].length,
              sums = [],
              max = 0,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++)
              o += data[i][j][1];
            if (o > max)
              max = o;
            sums.push(o);
          }
          for (j = 0; j < m; ++j) {
            y0[j] = (max - sums[j]) / 2;
          }
          return y0;
        },
        wiggle: function(data) {
          var n = data.length,
              x = data[0],
              m = x.length,
              i,
              j,
              k,
              s1,
              s2,
              s3,
              dx,
              o,
              o0,
              y0 = [];
          y0[0] = o = o0 = 0;
          for (j = 1; j < m; ++j) {
            for (i = 0, s1 = 0; i < n; ++i)
              s1 += data[i][j][1];
            for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
              for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
              }
              s2 += s3 * data[i][j][1];
            }
            y0[j] = o -= s1 ? s2 / s1 * dx : 0;
            if (o < o0)
              o0 = o;
          }
          for (j = 0; j < m; ++j)
            y0[j] -= o0;
          return y0;
        },
        expand: function(data) {
          var n = data.length,
              m = data[0].length,
              k = 1 / n,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++)
              o += data[i][j][1];
            if (o)
              for (i = 0; i < n; i++)
                data[i][j][1] /= o;
            else
              for (i = 0; i < n; i++)
                data[i][j][1] = k;
          }
          for (j = 0; j < m; ++j)
            y0[j] = 0;
          return y0;
        },
        zero: d3_layout_stackOffsetZero
      });
      function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
      }
      function d3_layout_stackOffsetZero(data) {
        var j = -1,
            m = data[0].length,
            y0 = [];
        while (++j < m)
          y0[j] = 0;
        return y0;
      }
      function d3_layout_stackMaxIndex(array) {
        var i = 1,
            j = 0,
            v = array[0][1],
            k,
            n = array.length;
        for (; i < n; ++i) {
          if ((k = array[i][1]) > v) {
            j = i;
            v = k;
          }
        }
        return j;
      }
      function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
      }
      function d3_layout_stackSum(p, d) {
        return p + d[1];
      }
      d3.layout.histogram = function() {
        var frequency = true,
            valuer = Number,
            ranger = d3_layout_histogramRange,
            binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
          var bins = [],
              values = data.map(valuer, this),
              range = ranger.call(this, values, i),
              thresholds = binner.call(this, range, values, i),
              bin,
              i = -1,
              n = values.length,
              m = thresholds.length - 1,
              k = frequency ? 1 : 1 / n,
              x;
          while (++i < m) {
            bin = bins[i] = [];
            bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
            bin.y = 0;
          }
          if (m > 0) {
            i = -1;
            while (++i < n) {
              x = values[i];
              if (x >= range[0] && x <= range[1]) {
                bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                bin.y += k;
                bin.push(data[i]);
              }
            }
          }
          return bins;
        }
        histogram.value = function(x) {
          if (!arguments.length)
            return valuer;
          valuer = x;
          return histogram;
        };
        histogram.range = function(x) {
          if (!arguments.length)
            return ranger;
          ranger = d3_functor(x);
          return histogram;
        };
        histogram.bins = function(x) {
          if (!arguments.length)
            return binner;
          binner = typeof x === "number" ? function(range) {
            return d3_layout_histogramBinFixed(range, x);
          } : d3_functor(x);
          return histogram;
        };
        histogram.frequency = function(x) {
          if (!arguments.length)
            return frequency;
          frequency = !!x;
          return histogram;
        };
        return histogram;
      };
      function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
      }
      function d3_layout_histogramBinFixed(range, n) {
        var x = -1,
            b = +range[0],
            m = (range[1] - b) / n,
            f = [];
        while (++x <= n)
          f[x] = m * x + b;
        return f;
      }
      function d3_layout_histogramRange(values) {
        return [d3.min(values), d3.max(values)];
      }
      d3.layout.pack = function() {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),
            padding = 0,
            size = [1, 1],
            radius;
        function pack(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              w = size[0],
              h = size[1],
              r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                return radius;
              };
          root.x = root.y = 0;
          d3_layout_hierarchyVisitAfter(root, function(d) {
            d.r = +r(d.value);
          });
          d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
          if (padding) {
            var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
            d3_layout_hierarchyVisitAfter(root, function(d) {
              d.r += dr;
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            d3_layout_hierarchyVisitAfter(root, function(d) {
              d.r -= dr;
            });
          }
          d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
          return nodes;
        }
        pack.size = function(_) {
          if (!arguments.length)
            return size;
          size = _;
          return pack;
        };
        pack.radius = function(_) {
          if (!arguments.length)
            return radius;
          radius = _ == null || typeof _ === "function" ? _ : +_;
          return pack;
        };
        pack.padding = function(_) {
          if (!arguments.length)
            return padding;
          padding = +_;
          return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
      };
      function d3_layout_packSort(a, b) {
        return a.value - b.value;
      }
      function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
      }
      function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
      }
      function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x,
            dy = b.y - a.y,
            dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy;
      }
      function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length))
          return;
        var nodes,
            xMin = Infinity,
            xMax = -Infinity,
            yMin = Infinity,
            yMax = -Infinity,
            a,
            b,
            c,
            i,
            j,
            k,
            n;
        function bound(node) {
          xMin = Math.min(node.x - node.r, xMin);
          xMax = Math.max(node.x + node.r, xMax);
          yMin = Math.min(node.y - node.r, yMin);
          yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
          b = nodes[1];
          b.x = b.r;
          b.y = 0;
          bound(b);
          if (n > 2) {
            c = nodes[2];
            d3_layout_packPlace(a, b, c);
            bound(c);
            d3_layout_packInsert(a, c);
            a._pack_prev = c;
            d3_layout_packInsert(c, b);
            b = a._pack_next;
            for (i = 3; i < n; i++) {
              d3_layout_packPlace(a, b, c = nodes[i]);
              var isect = 0,
                  s1 = 1,
                  s2 = 1;
              for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                if (d3_layout_packIntersects(j, c)) {
                  isect = 1;
                  break;
                }
              }
              if (isect == 1) {
                for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                  if (d3_layout_packIntersects(k, c)) {
                    break;
                  }
                }
              }
              if (isect) {
                if (s1 < s2 || s1 == s2 && b.r < a.r)
                  d3_layout_packSplice(a, b = j);
                else
                  d3_layout_packSplice(a = k, b);
                i--;
              } else {
                d3_layout_packInsert(a, c);
                b = c;
                bound(c);
              }
            }
          }
        }
        var cx = (xMin + xMax) / 2,
            cy = (yMin + yMax) / 2,
            cr = 0;
        for (i = 0; i < n; i++) {
          c = nodes[i];
          c.x -= cx;
          c.y -= cy;
          cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
      }
      function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
      }
      function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
      }
      function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
          var i = -1,
              n = children.length;
          while (++i < n)
            d3_layout_packTransform(children[i], x, y, k);
        }
      }
      function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r,
            dx = b.x - a.x,
            dy = b.y - a.y;
        if (db && (dx || dy)) {
          var da = b.r + c.r,
              dc = dx * dx + dy * dy;
          da *= da;
          db *= db;
          var x = .5 + (db - da) / (2 * dc),
              y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
          c.x = a.x + x * dx + y * dy;
          c.y = a.y + x * dy - y * dx;
        } else {
          c.x = a.x + db;
          c.y = a.y;
        }
      }
      d3.layout.tree = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = null;
        function tree(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root0 = nodes[0],
              root1 = wrapTree(root0);
          d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
          d3_layout_hierarchyVisitBefore(root1, secondWalk);
          if (nodeSize)
            d3_layout_hierarchyVisitBefore(root0, sizeNode);
          else {
            var left = root0,
                right = root0,
                bottom = root0;
            d3_layout_hierarchyVisitBefore(root0, function(node) {
              if (node.x < left.x)
                left = node;
              if (node.x > right.x)
                right = node;
              if (node.depth > bottom.depth)
                bottom = node;
            });
            var tx = separation(left, right) / 2 - left.x,
                kx = size[0] / (right.x + separation(right, left) / 2 + tx),
                ky = size[1] / (bottom.depth || 1);
            d3_layout_hierarchyVisitBefore(root0, function(node) {
              node.x = (node.x + tx) * kx;
              node.y = node.depth * ky;
            });
          }
          return nodes;
        }
        function wrapTree(root0) {
          var root1 = {
            A: null,
            children: [root0]
          },
              queue = [root1],
              node1;
          while ((node1 = queue.pop()) != null) {
            for (var children = node1.children,
                child,
                i = 0,
                n = children.length; i < n; ++i) {
              queue.push((children[i] = child = {
                _: children[i],
                parent: node1,
                children: (child = children[i].children) && child.slice() || [],
                A: null,
                a: null,
                z: 0,
                m: 0,
                c: 0,
                s: 0,
                t: null,
                i: i
              }).a = child);
            }
          }
          return root1.children[0];
        }
        function firstWalk(v) {
          var children = v.children,
              siblings = v.parent.children,
              w = v.i ? siblings[v.i - 1] : null;
          if (children.length) {
            d3_layout_treeShift(v);
            var midpoint = (children[0].z + children[children.length - 1].z) / 2;
            if (w) {
              v.z = w.z + separation(v._, w._);
              v.m = v.z - midpoint;
            } else {
              v.z = midpoint;
            }
          } else if (w) {
            v.z = w.z + separation(v._, w._);
          }
          v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
          v._.x = v.z + v.parent.m;
          v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
          if (w) {
            var vip = v,
                vop = v,
                vim = w,
                vom = vip.parent.children[0],
                sip = vip.m,
                sop = vop.m,
                sim = vim.m,
                som = vom.m,
                shift;
            while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
              vom = d3_layout_treeLeft(vom);
              vop = d3_layout_treeRight(vop);
              vop.a = v;
              shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
              if (shift > 0) {
                d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                sip += shift;
                sop += shift;
              }
              sim += vim.m;
              sip += vip.m;
              som += vom.m;
              sop += vop.m;
            }
            if (vim && !d3_layout_treeRight(vop)) {
              vop.t = vim;
              vop.m += sim - sop;
            }
            if (vip && !d3_layout_treeLeft(vom)) {
              vom.t = vip;
              vom.m += sip - som;
              ancestor = v;
            }
          }
          return ancestor;
        }
        function sizeNode(node) {
          node.x *= size[0];
          node.y = node.depth * size[1];
        }
        tree.separation = function(x) {
          if (!arguments.length)
            return separation;
          separation = x;
          return tree;
        };
        tree.size = function(x) {
          if (!arguments.length)
            return nodeSize ? null : size;
          nodeSize = (size = x) == null ? sizeNode : null;
          return tree;
        };
        tree.nodeSize = function(x) {
          if (!arguments.length)
            return nodeSize ? size : null;
          nodeSize = (size = x) == null ? null : sizeNode;
          return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
      };
      function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
      }
      function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
      }
      function d3_layout_treeRight(v) {
        var children = v.children,
            n;
        return (n = children.length) ? children[n - 1] : v.t;
      }
      function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
      }
      function d3_layout_treeShift(v) {
        var shift = 0,
            change = 0,
            children = v.children,
            i = children.length,
            w;
        while (--i >= 0) {
          w = children[i];
          w.z += shift;
          w.m += shift;
          shift += w.s + (change += w.c);
        }
      }
      function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
      }
      d3.layout.cluster = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = false;
        function cluster(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              previousNode,
              x = 0;
          d3_layout_hierarchyVisitAfter(root, function(node) {
            var children = node.children;
            if (children && children.length) {
              node.x = d3_layout_clusterX(children);
              node.y = d3_layout_clusterY(children);
            } else {
              node.x = previousNode ? x += separation(node, previousNode) : 0;
              node.y = 0;
              previousNode = node;
            }
          });
          var left = d3_layout_clusterLeft(root),
              right = d3_layout_clusterRight(root),
              x0 = left.x - separation(left, right) / 2,
              x1 = right.x + separation(right, left) / 2;
          d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
            node.x = (node.x - root.x) * size[0];
            node.y = (root.y - node.y) * size[1];
          } : function(node) {
            node.x = (node.x - x0) / (x1 - x0) * size[0];
            node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
          });
          return nodes;
        }
        cluster.separation = function(x) {
          if (!arguments.length)
            return separation;
          separation = x;
          return cluster;
        };
        cluster.size = function(x) {
          if (!arguments.length)
            return nodeSize ? null : size;
          nodeSize = (size = x) == null;
          return cluster;
        };
        cluster.nodeSize = function(x) {
          if (!arguments.length)
            return nodeSize ? size : null;
          nodeSize = (size = x) != null;
          return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
      };
      function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function(child) {
          return child.y;
        });
      }
      function d3_layout_clusterX(children) {
        return children.reduce(function(x, child) {
          return x + child.x;
        }, 0) / children.length;
      }
      function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
      }
      function d3_layout_clusterRight(node) {
        var children = node.children,
            n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
      }
      d3.layout.treemap = function() {
        var hierarchy = d3.layout.hierarchy(),
            round = Math.round,
            size = [1, 1],
            padding = null,
            pad = d3_layout_treemapPadNull,
            sticky = false,
            stickies,
            mode = "squarify",
            ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
          var i = -1,
              n = children.length,
              child,
              area;
          while (++i < n) {
            area = (child = children[i]).value * (k < 0 ? 0 : k);
            child.area = isNaN(area) || area <= 0 ? 0 : area;
          }
        }
        function squarify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                row = [],
                remaining = children.slice(),
                child,
                best = Infinity,
                score,
                u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy),
                n;
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while ((n = remaining.length) > 0) {
              row.push(child = remaining[n - 1]);
              row.area += child.area;
              if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                remaining.pop();
                best = score;
              } else {
                row.area -= row.pop().area;
                position(row, u, rect, false);
                u = Math.min(rect.dx, rect.dy);
                row.length = row.area = 0;
                best = Infinity;
              }
            }
            if (row.length) {
              position(row, u, rect, true);
              row.length = row.area = 0;
            }
            children.forEach(squarify);
          }
        }
        function stickify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                remaining = children.slice(),
                child,
                row = [];
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while (child = remaining.pop()) {
              row.push(child);
              row.area += child.area;
              if (child.z != null) {
                position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                row.length = row.area = 0;
              }
            }
            children.forEach(stickify);
          }
        }
        function worst(row, u) {
          var s = row.area,
              r,
              rmax = 0,
              rmin = Infinity,
              i = -1,
              n = row.length;
          while (++i < n) {
            if (!(r = row[i].area))
              continue;
            if (r < rmin)
              rmin = r;
            if (r > rmax)
              rmax = r;
          }
          s *= s;
          u *= u;
          return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
          var i = -1,
              n = row.length,
              x = rect.x,
              y = rect.y,
              v = u ? round(row.area / u) : 0,
              o;
          if (u == rect.dx) {
            if (flush || v > rect.dy)
              v = rect.dy;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dy = v;
              x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
            }
            o.z = true;
            o.dx += rect.x + rect.dx - x;
            rect.y += v;
            rect.dy -= v;
          } else {
            if (flush || v > rect.dx)
              v = rect.dx;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dx = v;
              y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
            }
            o.z = false;
            o.dy += rect.y + rect.dy - y;
            rect.x += v;
            rect.dx -= v;
          }
        }
        function treemap(d) {
          var nodes = stickies || hierarchy(d),
              root = nodes[0];
          root.x = 0;
          root.y = 0;
          root.dx = size[0];
          root.dy = size[1];
          if (stickies)
            hierarchy.revalue(root);
          scale([root], root.dx * root.dy / root.value);
          (stickies ? stickify : squarify)(root);
          if (sticky)
            stickies = nodes;
          return nodes;
        }
        treemap.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return treemap;
        };
        treemap.padding = function(x) {
          if (!arguments.length)
            return padding;
          function padFunction(node) {
            var p = x.call(treemap, node, node.depth);
            return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
          }
          function padConstant(node) {
            return d3_layout_treemapPad(node, x);
          }
          var type;
          pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [x, x, x, x], padConstant) : padConstant;
          return treemap;
        };
        treemap.round = function(x) {
          if (!arguments.length)
            return round != Number;
          round = x ? Math.round : Number;
          return treemap;
        };
        treemap.sticky = function(x) {
          if (!arguments.length)
            return sticky;
          sticky = x;
          stickies = null;
          return treemap;
        };
        treemap.ratio = function(x) {
          if (!arguments.length)
            return ratio;
          ratio = x;
          return treemap;
        };
        treemap.mode = function(x) {
          if (!arguments.length)
            return mode;
          mode = x + "";
          return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
      };
      function d3_layout_treemapPadNull(node) {
        return {
          x: node.x,
          y: node.y,
          dx: node.dx,
          dy: node.dy
        };
      }
      function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3],
            y = node.y + padding[0],
            dx = node.dx - padding[1] - padding[3],
            dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
          x += dx / 2;
          dx = 0;
        }
        if (dy < 0) {
          y += dy / 2;
          dy = 0;
        }
        return {
          x: x,
          y: y,
          dx: dx,
          dy: dy
        };
      }
      d3.random = {
        normal: function(µ, σ) {
          var n = arguments.length;
          if (n < 2)
            σ = 1;
          if (n < 1)
            µ = 0;
          return function() {
            var x,
                y,
                r;
            do {
              x = Math.random() * 2 - 1;
              y = Math.random() * 2 - 1;
              r = x * x + y * y;
            } while (!r || r > 1);
            return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
          };
        },
        logNormal: function() {
          var random = d3.random.normal.apply(d3, arguments);
          return function() {
            return Math.exp(random());
          };
        },
        bates: function(m) {
          var random = d3.random.irwinHall(m);
          return function() {
            return random() / m;
          };
        },
        irwinHall: function(m) {
          return function() {
            for (var s = 0,
                j = 0; j < m; j++)
              s += Math.random();
            return s;
          };
        }
      };
      d3.scale = {};
      function d3_scaleExtent(domain) {
        var start = domain[0],
            stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
      }
      function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
      }
      function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]),
            i = interpolate(range[0], range[1]);
        return function(x) {
          return i(u(x));
        };
      }
      function d3_scale_nice(domain, nice) {
        var i0 = 0,
            i1 = domain.length - 1,
            x0 = domain[i0],
            x1 = domain[i1],
            dx;
        if (x1 < x0) {
          dx = i0, i0 = i1, i1 = dx;
          dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
      }
      function d3_scale_niceStep(step) {
        return step ? {
          floor: function(x) {
            return Math.floor(x / step) * step;
          },
          ceil: function(x) {
            return Math.ceil(x / step) * step;
          }
        } : d3_scale_niceIdentity;
      }
      var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
      };
      function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [],
            i = [],
            j = 0,
            k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
          domain = domain.slice().reverse();
          range = range.slice().reverse();
        }
        while (++j <= k) {
          u.push(uninterpolate(domain[j - 1], domain[j]));
          i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
          var j = d3.bisect(domain, x, 1, k) - 1;
          return i[j](u[j](x));
        };
      }
      d3.scale.linear = function() {
        return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
      };
      function d3_scale_linear(domain, range, interpolate, clamp) {
        var output,
            input;
        function rescale() {
          var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,
              uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
          output = linear(domain, range, uninterpolate, interpolate);
          input = linear(range, domain, uninterpolate, d3_interpolate);
          return scale;
        }
        function scale(x) {
          return output(x);
        }
        scale.invert = function(y) {
          return input(y);
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(Number);
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.rangeRound = function(x) {
          return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function(x) {
          if (!arguments.length)
            return clamp;
          clamp = x;
          return rescale();
        };
        scale.interpolate = function(x) {
          if (!arguments.length)
            return interpolate;
          interpolate = x;
          return rescale();
        };
        scale.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
          d3_scale_linearNice(domain, m);
          return rescale();
        };
        scale.copy = function() {
          return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
      }
      function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
      }
      function d3_scale_linearNice(domain, m) {
        return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
      }
      function d3_scale_linearTickRange(domain, m) {
        if (m == null)
          m = 10;
        var extent = d3_scaleExtent(domain),
            span = extent[1] - extent[0],
            step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),
            err = m / span * step;
        if (err <= .15)
          step *= 10;
        else if (err <= .35)
          step *= 5;
        else if (err <= .75)
          step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
      }
      function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
      }
      function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
          var match = d3_format_re.exec(format);
          match.shift();
          if (match[8] === "s") {
            var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
            if (!match[7])
              match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
            match[8] = "f";
            format = d3.format(match.join(""));
            return function(d) {
              return format(prefix.scale(d)) + prefix.symbol;
            };
          }
          if (!match[7])
            match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
          format = match.join("");
        } else {
          format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        }
        return d3.format(format);
      }
      var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
      };
      function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + .01);
      }
      function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
      }
      d3.scale.log = function() {
        return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);
      };
      function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
          return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
          return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
          return linear(log(x));
        }
        scale.invert = function(x) {
          return pow(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          positive = x[0] >= 0;
          linear.domain((domain = x.map(Number)).map(log));
          return scale;
        };
        scale.base = function(_) {
          if (!arguments.length)
            return base;
          base = +_;
          linear.domain(domain.map(log));
          return scale;
        };
        scale.nice = function() {
          var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
          linear.domain(niced);
          domain = niced.map(pow);
          return scale;
        };
        scale.ticks = function() {
          var extent = d3_scaleExtent(domain),
              ticks = [],
              u = extent[0],
              v = extent[1],
              i = Math.floor(log(u)),
              j = Math.ceil(log(v)),
              n = base % 1 ? 2 : base;
          if (isFinite(j - i)) {
            if (positive) {
              for (; i < j; i++)
                for (var k = 1; k < n; k++)
                  ticks.push(pow(i) * k);
              ticks.push(pow(i));
            } else {
              ticks.push(pow(i));
              for (; i++ < j; )
                for (var k = n - 1; k > 0; k--)
                  ticks.push(pow(i) * k);
            }
            for (i = 0; ticks[i] < u; i++) {}
            for (j = ticks.length; ticks[j - 1] > v; j--) {}
            ticks = ticks.slice(i, j);
          }
          return ticks;
        };
        scale.tickFormat = function(n, format) {
          if (!arguments.length)
            return d3_scale_logFormat;
          if (arguments.length < 2)
            format = d3_scale_logFormat;
          else if (typeof format !== "function")
            format = d3.format(format);
          var k = Math.max(.1, n / scale.ticks().length),
              f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor),
              e;
          return function(d) {
            return d / pow(f(log(d) + e)) <= k ? format(d) : "";
          };
        };
        scale.copy = function() {
          return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      var d3_scale_logFormat = d3.format(".0e"),
          d3_scale_logNiceNegative = {
            floor: function(x) {
              return -Math.ceil(-x);
            },
            ceil: function(x) {
              return -Math.floor(-x);
            }
          };
      d3.scale.pow = function() {
        return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);
      };
      function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent),
            powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
          return linear(powp(x));
        }
        scale.invert = function(x) {
          return powb(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          linear.domain((domain = x.map(Number)).map(powp));
          return scale;
        };
        scale.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
          return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function(x) {
          if (!arguments.length)
            return exponent;
          powp = d3_scale_powPow(exponent = x);
          powb = d3_scale_powPow(1 / exponent);
          linear.domain(domain.map(powp));
          return scale;
        };
        scale.copy = function() {
          return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_scale_powPow(e) {
        return function(x) {
          return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
      }
      d3.scale.sqrt = function() {
        return d3.scale.pow().exponent(.5);
      };
      d3.scale.ordinal = function() {
        return d3_scale_ordinal([], {
          t: "range",
          a: [[]]
        });
      };
      function d3_scale_ordinal(domain, ranger) {
        var index,
            range,
            rangeBand;
        function scale(x) {
          return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
          return d3.range(domain.length).map(function(i) {
            return start + step * i;
          });
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = [];
          index = new d3_Map();
          var i = -1,
              n = x.length,
              xi;
          while (++i < n)
            if (!index.has(xi = x[i]))
              index.set(xi, domain.push(xi));
          return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          rangeBand = 0;
          ranger = {
            t: "range",
            a: arguments
          };
          return scale;
        };
        scale.rangePoints = function(x, padding) {
          if (arguments.length < 2)
            padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
          range = steps(start + step * padding / 2, step);
          rangeBand = 0;
          ranger = {
            t: "rangePoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundPoints = function(x, padding) {
          if (arguments.length < 2)
            padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
          range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
          rangeBand = 0;
          ranger = {
            t: "rangeRoundPoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeBands = function(x, padding, outerPadding) {
          if (arguments.length < 2)
            padding = 0;
          if (arguments.length < 3)
            outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = (stop - start) / (domain.length - padding + 2 * outerPadding);
          range = steps(start + step * outerPadding, step);
          if (reverse)
            range.reverse();
          rangeBand = step * (1 - padding);
          ranger = {
            t: "rangeBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundBands = function(x, padding, outerPadding) {
          if (arguments.length < 2)
            padding = 0;
          if (arguments.length < 3)
            outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
          range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
          if (reverse)
            range.reverse();
          rangeBand = Math.round(step * (1 - padding));
          ranger = {
            t: "rangeRoundBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeBand = function() {
          return rangeBand;
        };
        scale.rangeExtent = function() {
          return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function() {
          return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
      }
      d3.scale.category10 = function() {
        return d3.scale.ordinal().range(d3_category10);
      };
      d3.scale.category20 = function() {
        return d3.scale.ordinal().range(d3_category20);
      };
      d3.scale.category20b = function() {
        return d3.scale.ordinal().range(d3_category20b);
      };
      d3.scale.category20c = function() {
        return d3.scale.ordinal().range(d3_category20c);
      };
      var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
      var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
      var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
      var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
      d3.scale.quantile = function() {
        return d3_scale_quantile([], []);
      };
      function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
          var k = 0,
              q = range.length;
          thresholds = [];
          while (++k < q)
            thresholds[k - 1] = d3.quantile(domain, k / q);
          return scale;
        }
        function scale(x) {
          if (!isNaN(x = +x))
            return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.quantiles = function() {
          return thresholds;
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];
        };
        scale.copy = function() {
          return d3_scale_quantile(domain, range);
        };
        return rescale();
      }
      d3.scale.quantize = function() {
        return d3_scale_quantize(0, 1, [0, 1]);
      };
      function d3_scale_quantize(x0, x1, range) {
        var kx,
            i;
        function scale(x) {
          return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
          kx = range.length / (x1 - x0);
          i = range.length - 1;
          return scale;
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return [x0, x1];
          x0 = +x[0];
          x1 = +x[x.length - 1];
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          y = y < 0 ? NaN : y / kx + x0;
          return [y, y + 1 / kx];
        };
        scale.copy = function() {
          return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
      }
      d3.scale.threshold = function() {
        return d3_scale_threshold([.5], [0, 1]);
      };
      function d3_scale_threshold(domain, range) {
        function scale(x) {
          if (x <= x)
            return range[d3.bisect(domain, x)];
        }
        scale.domain = function(_) {
          if (!arguments.length)
            return domain;
          domain = _;
          return scale;
        };
        scale.range = function(_) {
          if (!arguments.length)
            return range;
          range = _;
          return scale;
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          return [domain[y - 1], domain[y]];
        };
        scale.copy = function() {
          return d3_scale_threshold(domain, range);
        };
        return scale;
      }
      d3.scale.identity = function() {
        return d3_scale_identity([0, 1]);
      };
      function d3_scale_identity(domain) {
        function identity(x) {
          return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(identity);
          return identity;
        };
        identity.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function() {
          return d3_scale_identity(domain);
        };
        return identity;
      }
      d3.svg = {};
      function d3_zero() {
        return 0;
      }
      d3.svg.arc = function() {
        var innerRadius = d3_svg_arcInnerRadius,
            outerRadius = d3_svg_arcOuterRadius,
            cornerRadius = d3_zero,
            padRadius = d3_svg_arcAuto,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle,
            padAngle = d3_svg_arcPadAngle;
        function arc() {
          var r0 = Math.max(0, +innerRadius.apply(this, arguments)),
              r1 = Math.max(0, +outerRadius.apply(this, arguments)),
              a0 = startAngle.apply(this, arguments) - halfπ,
              a1 = endAngle.apply(this, arguments) - halfπ,
              da = Math.abs(a1 - a0),
              cw = a0 > a1 ? 0 : 1;
          if (r1 < r0)
            rc = r1, r1 = r0, r0 = rc;
          if (da >= τε)
            return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
          var rc,
              cr,
              rp,
              ap,
              p0 = 0,
              p1 = 0,
              x0,
              y0,
              x1,
              y1,
              x2,
              y2,
              x3,
              y3,
              path = [];
          if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
            rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
            if (!cw)
              p1 *= -1;
            if (r1)
              p1 = d3_asin(rp / r1 * Math.sin(ap));
            if (r0)
              p0 = d3_asin(rp / r0 * Math.sin(ap));
          }
          if (r1) {
            x0 = r1 * Math.cos(a0 + p1);
            y0 = r1 * Math.sin(a0 + p1);
            x1 = r1 * Math.cos(a1 - p1);
            y1 = r1 * Math.sin(a1 - p1);
            var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
            if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
              var h1 = (a0 + a1) / 2;
              x0 = r1 * Math.cos(h1);
              y0 = r1 * Math.sin(h1);
              x1 = y1 = null;
            }
          } else {
            x0 = y0 = 0;
          }
          if (r0) {
            x2 = r0 * Math.cos(a1 - p0);
            y2 = r0 * Math.sin(a1 - p0);
            x3 = r0 * Math.cos(a0 + p0);
            y3 = r0 * Math.sin(a0 + p0);
            var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
            if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
              var h0 = (a0 + a1) / 2;
              x2 = r0 * Math.cos(h0);
              y2 = r0 * Math.sin(h0);
              x3 = y3 = null;
            }
          } else {
            x2 = y2 = 0;
          }
          if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
            cr = r0 < r1 ^ cw ? 0 : 1;
            var oc = x3 == null ? [x2, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]),
                ax = x0 - oc[0],
                ay = y0 - oc[1],
                bx = x1 - oc[0],
                by = y1 - oc[1],
                kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
                lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            if (x1 != null) {
              var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)),
                  t30 = d3_svg_arcCornerTangents(x3 == null ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw),
                  t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
              if (rc === rc1) {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
              } else {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
              }
            } else {
              path.push("M", x0, ",", y0);
            }
            if (x3 != null) {
              var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)),
                  t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw),
                  t21 = d3_svg_arcCornerTangents([x2, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);
              if (rc === rc0) {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              } else {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              }
            } else {
              path.push("L", x2, ",", y2);
            }
          } else {
            path.push("M", x0, ",", y0);
            if (x1 != null)
              path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
            path.push("L", x2, ",", y2);
            if (x3 != null)
              path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
          }
          path.push("Z");
          return path.join("");
        }
        function circleSegment(r1, cw) {
          return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }
        arc.innerRadius = function(v) {
          if (!arguments.length)
            return innerRadius;
          innerRadius = d3_functor(v);
          return arc;
        };
        arc.outerRadius = function(v) {
          if (!arguments.length)
            return outerRadius;
          outerRadius = d3_functor(v);
          return arc;
        };
        arc.cornerRadius = function(v) {
          if (!arguments.length)
            return cornerRadius;
          cornerRadius = d3_functor(v);
          return arc;
        };
        arc.padRadius = function(v) {
          if (!arguments.length)
            return padRadius;
          padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
          return arc;
        };
        arc.startAngle = function(v) {
          if (!arguments.length)
            return startAngle;
          startAngle = d3_functor(v);
          return arc;
        };
        arc.endAngle = function(v) {
          if (!arguments.length)
            return endAngle;
          endAngle = d3_functor(v);
          return arc;
        };
        arc.padAngle = function(v) {
          if (!arguments.length)
            return padAngle;
          padAngle = d3_functor(v);
          return arc;
        };
        arc.centroid = function() {
          var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
              a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
          return [Math.cos(a) * r, Math.sin(a) * r];
        };
        return arc;
      };
      var d3_svg_arcAuto = "auto";
      function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
      }
      function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
      }
      function d3_svg_arcStartAngle(d) {
        return d.startAngle;
      }
      function d3_svg_arcEndAngle(d) {
        return d.endAngle;
      }
      function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
      }
      function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
      }
      function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0],
            y01 = p0[1] - p1[1],
            lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
            ox = lo * y01,
            oy = -lo * x01,
            x1 = p0[0] + ox,
            y1 = p0[1] + oy,
            x2 = p1[0] + ox,
            y2 = p1[1] + oy,
            x3 = (x1 + x2) / 2,
            y3 = (y1 + y2) / 2,
            dx = x2 - x1,
            dy = y2 - y1,
            d2 = dx * dx + dy * dy,
            r = r1 - rc,
            D = x1 * y2 - x2 * y1,
            d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D),
            cx0 = (D * dy - dx * d) / d2,
            cy0 = (-D * dx - dy * d) / d2,
            cx1 = (D * dy + dx * d) / d2,
            cy1 = (-D * dx + dy * d) / d2,
            dx0 = cx0 - x3,
            dy0 = cy0 - y3,
            dx1 = cx1 - x3,
            dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
          cx0 = cx1, cy0 = cy1;
        return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];
      }
      function d3_svg_line(projection) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            tension = .7;
        function line(data) {
          var segments = [],
              points = [],
              i = -1,
              n = data.length,
              d,
              fx = d3_functor(x),
              fy = d3_functor(y);
          function segment() {
            segments.push("M", interpolate(projection(points), tension));
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
            } else if (points.length) {
              segment();
              points = [];
            }
          }
          if (points.length)
            segment();
          return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
          if (!arguments.length)
            return x;
          x = _;
          return line;
        };
        line.y = function(_) {
          if (!arguments.length)
            return y;
          y = _;
          return line;
        };
        line.defined = function(_) {
          if (!arguments.length)
            return defined;
          defined = _;
          return line;
        };
        line.interpolate = function(_) {
          if (!arguments.length)
            return interpolateKey;
          if (typeof _ === "function")
            interpolateKey = interpolate = _;
          else
            interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          return line;
        };
        line.tension = function(_) {
          if (!arguments.length)
            return tension;
          tension = _;
          return line;
        };
        return line;
      }
      d3.svg.line = function() {
        return d3_svg_line(d3_identity);
      };
      var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
      });
      d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
      });
      function d3_svg_lineLinear(points) {
        return points.join("L");
      }
      function d3_svg_lineLinearClosed(points) {
        return d3_svg_lineLinear(points) + "Z";
      }
      function d3_svg_lineStep(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1)
          path.push("H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepBefore(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepAfter(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
      }
      function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
      }
      function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
          return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length,
            path = "",
            p0 = points[0],
            p = points[1],
            t0 = tangents[0],
            t = t0,
            pi = 1;
        if (quad) {
          path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
          p0 = points[1];
          pi = 2;
        }
        if (tangents.length > 1) {
          t = tangents[1];
          p = points[pi];
          pi++;
          path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          for (var i = 2; i < tangents.length; i++, pi++) {
            p = points[pi];
            t = tangents[i];
            path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          }
        }
        if (quad) {
          var lp = points[pi];
          path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
      }
      function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [],
            a = (1 - tension) / 2,
            p0,
            p1 = points[0],
            p2 = points[1],
            i = 1,
            n = points.length;
        while (++i < n) {
          p0 = p1;
          p1 = p2;
          p2 = points[i];
          tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
        }
        return tangents;
      }
      function d3_svg_lineBasis(points) {
        if (points.length < 3)
          return d3_svg_lineLinear(points);
        var i = 1,
            n = points.length,
            pi = points[0],
            x0 = pi[0],
            y0 = pi[1],
            px = [x0, x0, x0, (pi = points[1])[0]],
            py = [y0, y0, y0, pi[1]],
            path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        points.push(points[n - 1]);
        while (++i <= n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
      }
      function d3_svg_lineBasisOpen(points) {
        if (points.length < 4)
          return d3_svg_lineLinear(points);
        var path = [],
            i = -1,
            n = points.length,
            pi,
            px = [0],
            py = [0];
        while (++i < 3) {
          pi = points[i];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBasisClosed(points) {
        var path,
            i = -1,
            n = points.length,
            m = n + 4,
            pi,
            px = [],
            py = [];
        while (++i < 4) {
          pi = points[i % n];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        --i;
        while (++i < m) {
          pi = points[i % n];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
          var x0 = points[0][0],
              y0 = points[0][1],
              dx = points[n][0] - x0,
              dy = points[n][1] - y0,
              i = -1,
              p,
              t;
          while (++i <= n) {
            p = points[i];
            t = i / n;
            p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
            p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
          }
        }
        return d3_svg_lineBasis(points);
      }
      function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
      }
      var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0],
          d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0],
          d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
      function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
      }
      function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
      }
      function d3_svg_lineFiniteDifferences(points) {
        var i = 0,
            j = points.length - 1,
            m = [],
            p0 = points[0],
            p1 = points[1],
            d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
          m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
      }
      function d3_svg_lineMonotoneTangents(points) {
        var tangents = [],
            d,
            a,
            b,
            s,
            m = d3_svg_lineFiniteDifferences(points),
            i = -1,
            j = points.length - 1;
        while (++i < j) {
          d = d3_svg_lineSlope(points[i], points[i + 1]);
          if (abs(d) < ε) {
            m[i] = m[i + 1] = 0;
          } else {
            a = m[i] / d;
            b = m[i + 1] / d;
            s = a * a + b * b;
            if (s > 9) {
              s = d * 3 / Math.sqrt(s);
              m[i] = s * a;
              m[i + 1] = s * b;
            }
          }
        }
        i = -1;
        while (++i <= j) {
          s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
          tangents.push([s || 0, m[i] * s || 0]);
        }
        return tangents;
      }
      function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
      }
      d3.svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
      };
      function d3_svg_lineRadial(points) {
        var point,
            i = -1,
            n = points.length,
            r,
            a;
        while (++i < n) {
          point = points[i];
          r = point[0];
          a = point[1] - halfπ;
          point[0] = r * Math.cos(a);
          point[1] = r * Math.sin(a);
        }
        return points;
      }
      function d3_svg_area(projection) {
        var x0 = d3_geom_pointX,
            x1 = d3_geom_pointX,
            y0 = 0,
            y1 = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            interpolateReverse = interpolate,
            L = "L",
            tension = .7;
        function area(data) {
          var segments = [],
              points0 = [],
              points1 = [],
              i = -1,
              n = data.length,
              d,
              fx0 = d3_functor(x0),
              fy0 = d3_functor(y0),
              fx1 = x0 === x1 ? function() {
                return x;
              } : d3_functor(x1),
              fy1 = y0 === y1 ? function() {
                return y;
              } : d3_functor(y1),
              x,
              y;
          function segment() {
            segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
              points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
            } else if (points0.length) {
              segment();
              points0 = [];
              points1 = [];
            }
          }
          if (points0.length)
            segment();
          return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
          if (!arguments.length)
            return x1;
          x0 = x1 = _;
          return area;
        };
        area.x0 = function(_) {
          if (!arguments.length)
            return x0;
          x0 = _;
          return area;
        };
        area.x1 = function(_) {
          if (!arguments.length)
            return x1;
          x1 = _;
          return area;
        };
        area.y = function(_) {
          if (!arguments.length)
            return y1;
          y0 = y1 = _;
          return area;
        };
        area.y0 = function(_) {
          if (!arguments.length)
            return y0;
          y0 = _;
          return area;
        };
        area.y1 = function(_) {
          if (!arguments.length)
            return y1;
          y1 = _;
          return area;
        };
        area.defined = function(_) {
          if (!arguments.length)
            return defined;
          defined = _;
          return area;
        };
        area.interpolate = function(_) {
          if (!arguments.length)
            return interpolateKey;
          if (typeof _ === "function")
            interpolateKey = interpolate = _;
          else
            interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          interpolateReverse = interpolate.reverse || interpolate;
          L = interpolate.closed ? "M" : "L";
          return area;
        };
        area.tension = function(_) {
          if (!arguments.length)
            return tension;
          tension = _;
          return area;
        };
        return area;
      }
      d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
      d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
      d3.svg.area = function() {
        return d3_svg_area(d3_identity);
      };
      d3.svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
      };
      d3.svg.chord = function() {
        var source = d3_source,
            target = d3_target,
            radius = d3_svg_chordRadius,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
          var s = subgroup(this, source, d, i),
              t = subgroup(this, target, d, i);
          return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
          var subgroup = f.call(self, d, i),
              r = radius.call(self, subgroup, i),
              a0 = startAngle.call(self, subgroup, i) - halfπ,
              a1 = endAngle.call(self, subgroup, i) - halfπ;
          return {
            r: r,
            a0: a0,
            a1: a1,
            p0: [r * Math.cos(a0), r * Math.sin(a0)],
            p1: [r * Math.cos(a1), r * Math.sin(a1)]
          };
        }
        function equals(a, b) {
          return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
          return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
          return "Q 0,0 " + p1;
        }
        chord.radius = function(v) {
          if (!arguments.length)
            return radius;
          radius = d3_functor(v);
          return chord;
        };
        chord.source = function(v) {
          if (!arguments.length)
            return source;
          source = d3_functor(v);
          return chord;
        };
        chord.target = function(v) {
          if (!arguments.length)
            return target;
          target = d3_functor(v);
          return chord;
        };
        chord.startAngle = function(v) {
          if (!arguments.length)
            return startAngle;
          startAngle = d3_functor(v);
          return chord;
        };
        chord.endAngle = function(v) {
          if (!arguments.length)
            return endAngle;
          endAngle = d3_functor(v);
          return chord;
        };
        return chord;
      };
      function d3_svg_chordRadius(d) {
        return d.radius;
      }
      d3.svg.diagonal = function() {
        var source = d3_source,
            target = d3_target,
            projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
          var p0 = source.call(this, d, i),
              p3 = target.call(this, d, i),
              m = (p0.y + p3.y) / 2,
              p = [p0, {
                x: p0.x,
                y: m
              }, {
                x: p3.x,
                y: m
              }, p3];
          p = p.map(projection);
          return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
          if (!arguments.length)
            return source;
          source = d3_functor(x);
          return diagonal;
        };
        diagonal.target = function(x) {
          if (!arguments.length)
            return target;
          target = d3_functor(x);
          return diagonal;
        };
        diagonal.projection = function(x) {
          if (!arguments.length)
            return projection;
          projection = x;
          return diagonal;
        };
        return diagonal;
      };
      function d3_svg_diagonalProjection(d) {
        return [d.x, d.y];
      }
      d3.svg.diagonal.radial = function() {
        var diagonal = d3.svg.diagonal(),
            projection = d3_svg_diagonalProjection,
            projection_ = diagonal.projection;
        diagonal.projection = function(x) {
          return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
      };
      function d3_svg_diagonalRadialProjection(projection) {
        return function() {
          var d = projection.apply(this, arguments),
              r = d[0],
              a = d[1] - halfπ;
          return [r * Math.cos(a), r * Math.sin(a)];
        };
      }
      d3.svg.symbol = function() {
        var type = d3_svg_symbolType,
            size = d3_svg_symbolSize;
        function symbol(d, i) {
          return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function(x) {
          if (!arguments.length)
            return type;
          type = d3_functor(x);
          return symbol;
        };
        symbol.size = function(x) {
          if (!arguments.length)
            return size;
          size = d3_functor(x);
          return symbol;
        };
        return symbol;
      };
      function d3_svg_symbolSize() {
        return 64;
      }
      function d3_svg_symbolType() {
        return "circle";
      }
      function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
      }
      var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function(size) {
          var r = Math.sqrt(size / 5) / 2;
          return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function(size) {
          var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
              rx = ry * d3_svg_symbolTan30;
          return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function(size) {
          var r = Math.sqrt(size) / 2;
          return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function(size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function(size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
      });
      d3.svg.symbolTypes = d3_svg_symbols.keys();
      var d3_svg_symbolSqrt3 = Math.sqrt(3),
          d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
      d3_selectionPrototype.transition = function(name) {
        var id = d3_transitionInheritId || ++d3_transitionId,
            ns = d3_transitionNamespace(name),
            subgroups = [],
            subgroup,
            node,
            transition = d3_transitionInherit || {
              time: Date.now(),
              ease: d3_ease_cubicInOut,
              delay: 0,
              duration: 250
            };
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i])
              d3_transitionNode(node, i, ns, id, transition);
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_selectionPrototype.interrupt = function(name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
      };
      var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
      function d3_selection_interruptNS(ns) {
        return function() {
          var lock,
              active;
          if ((lock = this[ns]) && (active = lock[lock.active])) {
            if (--lock.count)
              delete lock[lock.active];
            else
              delete this[ns];
            lock.active += .5;
            active.event && active.event.interrupt.call(this, this.__data__, active.index);
          }
        };
      }
      function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
      }
      var d3_transitionPrototype = [],
          d3_transitionId = 0,
          d3_transitionInheritId,
          d3_transitionInherit;
      d3_transitionPrototype.call = d3_selectionPrototype.call;
      d3_transitionPrototype.empty = d3_selectionPrototype.empty;
      d3_transitionPrototype.node = d3_selectionPrototype.node;
      d3_transitionPrototype.size = d3_selectionPrototype.size;
      d3.transition = function(selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
      };
      d3.transition.prototype = d3_transitionPrototype;
      d3_transitionPrototype.select = function(selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnode,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
              if ("__data__" in node)
                subnode.__data__ = node.__data__;
              d3_transitionNode(subnode, i, ns, id, node[ns][id]);
              subgroup.push(subnode);
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.selectAll = function(selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnodes,
            node,
            subnode,
            transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              transition = node[ns][id];
              subnodes = selector.call(node, node.__data__, i, j);
              subgroups.push(subgroup = []);
              for (var k = -1,
                  o = subnodes.length; ++k < o; ) {
                if (subnode = subnodes[k])
                  d3_transitionNode(subnode, k, ns, id, transition);
                subgroup.push(subnode);
              }
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.filter = function(filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function")
          filter = d3_selection_filter(filter);
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_transition(subgroups, this.namespace, this.id);
      };
      d3_transitionPrototype.tween = function(name, tween) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2)
          return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function(node) {
          node[ns][id].tween.remove(name);
        } : function(node) {
          node[ns][id].tween.set(name, tween);
        });
      };
      function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id,
            ns = groups.namespace;
        return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
          node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function(node) {
          node[ns][id].tween.set(name, value);
        }));
      }
      d3_transitionPrototype.attr = function(nameNS, value) {
        if (arguments.length < 2) {
          for (value in nameNS)
            this.attr(value, nameNS[value]);
          return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate,
            name = d3.ns.qualify(nameNS);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
          return b == null ? attrNull : (b += "", function() {
            var a = this.getAttribute(name),
                i;
            return a !== b && (i = interpolate(a, b), function(t) {
              this.setAttribute(name, i(t));
            });
          });
        }
        function attrTweenNS(b) {
          return b == null ? attrNullNS : (b += "", function() {
            var a = this.getAttributeNS(name.space, name.local),
                i;
            return a !== b && (i = interpolate(a, b), function(t) {
              this.setAttributeNS(name.space, name.local, i(t));
            });
          });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.attrTween = function(nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
          var f = tween.call(this, d, i, this.getAttribute(name));
          return f && function(t) {
            this.setAttribute(name, f(t));
          };
        }
        function attrTweenNS(d, i) {
          var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
          return f && function(t) {
            this.setAttributeNS(name.space, name.local, f(t));
          };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2)
              value = "";
            for (priority in name)
              this.style(priority, name[priority], value);
            return this;
          }
          priority = "";
        }
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleString(b) {
          return b == null ? styleNull : (b += "", function() {
            var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name),
                i;
            return a !== b && (i = d3_interpolate(a, b), function(t) {
              this.style.setProperty(name, i(t), priority);
            });
          });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
      };
      d3_transitionPrototype.styleTween = function(name, tween, priority) {
        if (arguments.length < 3)
          priority = "";
        function styleTween(d, i) {
          var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
          return f && function(t) {
            this.style.setProperty(name, f(t), priority);
          };
        }
        return this.tween("style." + name, styleTween);
      };
      d3_transitionPrototype.text = function(value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
      };
      function d3_transition_text(b) {
        if (b == null)
          b = "";
        return function() {
          this.textContent = b;
        };
      }
      d3_transitionPrototype.remove = function() {
        var ns = this.namespace;
        return this.each("end.transition", function() {
          var p;
          if (this[ns].count < 2 && (p = this.parentNode))
            p.removeChild(this);
        });
      };
      d3_transitionPrototype.ease = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].ease;
        if (typeof value !== "function")
          value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function(node) {
          node[ns][id].ease = value;
        });
      };
      d3_transitionPrototype.delay = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
          node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function(node) {
          node[ns][id].delay = value;
        }));
      };
      d3_transitionPrototype.duration = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
          node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function(node) {
          node[ns][id].duration = value;
        }));
      };
      d3_transitionPrototype.each = function(type, listener) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2) {
          var inherit = d3_transitionInherit,
              inheritId = d3_transitionInheritId;
          try {
            d3_transitionInheritId = id;
            d3_selection_each(this, function(node, i, j) {
              d3_transitionInherit = node[ns][id];
              type.call(node, node.__data__, i, j);
            });
          } finally {
            d3_transitionInherit = inherit;
            d3_transitionInheritId = inheritId;
          }
        } else {
          d3_selection_each(this, function(node) {
            var transition = node[ns][id];
            (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
          });
        }
        return this;
      };
      d3_transitionPrototype.transition = function() {
        var id0 = this.id,
            id1 = ++d3_transitionId,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            group,
            node,
            transition;
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            if (node = group[i]) {
              transition = node[ns][id0];
              d3_transitionNode(node, i, ns, id1, {
                time: transition.time,
                ease: transition.ease,
                delay: transition.delay + transition.duration,
                duration: transition.duration
              });
            }
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id1);
      };
      function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
      }
      function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
          active: 0,
          count: 0
        }),
            transition = lock[id];
        if (!transition) {
          var time = inherit.time;
          transition = lock[id] = {
            tween: new d3_Map(),
            time: time,
            delay: inherit.delay,
            duration: inherit.duration,
            ease: inherit.ease,
            index: i
          };
          inherit = null;
          ++lock.count;
          d3.timer(function(elapsed) {
            var delay = transition.delay,
                duration,
                ease,
                timer = d3_timer_active,
                tweened = [];
            timer.t = delay + time;
            if (delay <= elapsed)
              return start(elapsed - delay);
            timer.c = start;
            function start(elapsed) {
              if (lock.active > id)
                return stop();
              var active = lock[lock.active];
              if (active) {
                --lock.count;
                delete lock[lock.active];
                active.event && active.event.interrupt.call(node, node.__data__, active.index);
              }
              lock.active = id;
              transition.event && transition.event.start.call(node, node.__data__, i);
              transition.tween.forEach(function(key, value) {
                if (value = value.call(node, node.__data__, i)) {
                  tweened.push(value);
                }
              });
              ease = transition.ease;
              duration = transition.duration;
              d3.timer(function() {
                timer.c = tick(elapsed || 1) ? d3_true : tick;
                return 1;
              }, 0, time);
            }
            function tick(elapsed) {
              if (lock.active !== id)
                return 1;
              var t = elapsed / duration,
                  e = ease(t),
                  n = tweened.length;
              while (n > 0) {
                tweened[--n].call(node, e);
              }
              if (t >= 1) {
                transition.event && transition.event.end.call(node, node.__data__, i);
                return stop();
              }
            }
            function stop() {
              if (--lock.count)
                delete lock[id];
              else
                delete node[ns];
              return 1;
            }
          }, 0, time);
        }
      }
      d3.svg.axis = function() {
        var scale = d3.scale.linear(),
            orient = d3_svg_axisDefaultOrient,
            innerTickSize = 6,
            outerTickSize = 6,
            tickPadding = 3,
            tickArguments_ = [10],
            tickValues = null,
            tickFormat_;
        function axis(g) {
          g.each(function() {
            var g = d3.select(this);
            var scale0 = this.__chart__ || scale,
                scale1 = this.__chart__ = scale.copy();
            var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues,
                tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_,
                tick = g.selectAll(".tick").data(ticks, scale1),
                tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε),
                tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(),
                tickUpdate = d3.transition(tick.order()).style("opacity", 1),
                tickSpacing = Math.max(innerTickSize, 0) + tickPadding,
                tickTransform;
            var range = d3_scaleRange(scale1),
                path = g.selectAll(".domain").data([0]),
                pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path));
            tickEnter.append("line");
            tickEnter.append("text");
            var lineEnter = tickEnter.select("line"),
                lineUpdate = tickUpdate.select("line"),
                text = tick.select("text").text(tickFormat),
                textEnter = tickEnter.select("text"),
                textUpdate = tickUpdate.select("text"),
                sign = orient === "top" || orient === "left" ? -1 : 1,
                x1,
                x2,
                y1,
                y2;
            if (orient === "bottom" || orient === "top") {
              tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
              text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
              pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
            } else {
              tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
              text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
              pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
            }
            lineEnter.attr(y2, sign * innerTickSize);
            textEnter.attr(y1, sign * tickSpacing);
            lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
            textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
            if (scale1.rangeBand) {
              var x = scale1,
                  dx = x.rangeBand() / 2;
              scale0 = scale1 = function(d) {
                return x(d) + dx;
              };
            } else if (scale0.rangeBand) {
              scale0 = scale1;
            } else {
              tickExit.call(tickTransform, scale1, scale0);
            }
            tickEnter.call(tickTransform, scale0, scale1);
            tickUpdate.call(tickTransform, scale1, scale1);
          });
        }
        axis.scale = function(x) {
          if (!arguments.length)
            return scale;
          scale = x;
          return axis;
        };
        axis.orient = function(x) {
          if (!arguments.length)
            return orient;
          orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
          return axis;
        };
        axis.ticks = function() {
          if (!arguments.length)
            return tickArguments_;
          tickArguments_ = arguments;
          return axis;
        };
        axis.tickValues = function(x) {
          if (!arguments.length)
            return tickValues;
          tickValues = x;
          return axis;
        };
        axis.tickFormat = function(x) {
          if (!arguments.length)
            return tickFormat_;
          tickFormat_ = x;
          return axis;
        };
        axis.tickSize = function(x) {
          var n = arguments.length;
          if (!n)
            return innerTickSize;
          innerTickSize = +x;
          outerTickSize = +arguments[n - 1];
          return axis;
        };
        axis.innerTickSize = function(x) {
          if (!arguments.length)
            return innerTickSize;
          innerTickSize = +x;
          return axis;
        };
        axis.outerTickSize = function(x) {
          if (!arguments.length)
            return outerTickSize;
          outerTickSize = +x;
          return axis;
        };
        axis.tickPadding = function(x) {
          if (!arguments.length)
            return tickPadding;
          tickPadding = +x;
          return axis;
        };
        axis.tickSubdivide = function() {
          return arguments.length && axis;
        };
        return axis;
      };
      var d3_svg_axisDefaultOrient = "bottom",
          d3_svg_axisOrients = {
            top: 1,
            right: 1,
            bottom: 1,
            left: 1
          };
      function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function(d) {
          var v0 = x0(d);
          return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
        });
      }
      function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function(d) {
          var v0 = y0(d);
          return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
        });
      }
      d3.svg.brush = function() {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"),
            x = null,
            y = null,
            xExtent = [0, 0],
            yExtent = [0, 0],
            xExtentDomain,
            yExtentDomain,
            xClamp = true,
            yClamp = true,
            resizes = d3_svg_brushResizes[0];
        function brush(g) {
          g.each(function() {
            var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
            var background = g.selectAll(".background").data([0]);
            background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
            g.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
            var resize = g.selectAll(".resize").data(resizes, d3_identity);
            resize.exit().remove();
            resize.enter().append("g").attr("class", function(d) {
              return "resize " + d;
            }).style("cursor", function(d) {
              return d3_svg_brushCursor[d];
            }).append("rect").attr("x", function(d) {
              return /[ew]$/.test(d) ? -3 : null;
            }).attr("y", function(d) {
              return /^[ns]/.test(d) ? -3 : null;
            }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
            resize.style("display", brush.empty() ? "none" : null);
            var gUpdate = d3.transition(g),
                backgroundUpdate = d3.transition(background),
                range;
            if (x) {
              range = d3_scaleRange(x);
              backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
              redrawX(gUpdate);
            }
            if (y) {
              range = d3_scaleRange(y);
              backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
              redrawY(gUpdate);
            }
            redraw(gUpdate);
          });
        }
        brush.event = function(g) {
          g.each(function() {
            var event_ = event.of(this, arguments),
                extent1 = {
                  x: xExtent,
                  y: yExtent,
                  i: xExtentDomain,
                  j: yExtentDomain
                },
                extent0 = this.__chart__ || extent1;
            this.__chart__ = extent1;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.brush", function() {
                xExtentDomain = extent0.i;
                yExtentDomain = extent0.j;
                xExtent = extent0.x;
                yExtent = extent0.y;
                event_({type: "brushstart"});
              }).tween("brush:brush", function() {
                var xi = d3_interpolateArray(xExtent, extent1.x),
                    yi = d3_interpolateArray(yExtent, extent1.y);
                xExtentDomain = yExtentDomain = null;
                return function(t) {
                  xExtent = extent1.x = xi(t);
                  yExtent = extent1.y = yi(t);
                  event_({
                    type: "brush",
                    mode: "resize"
                  });
                };
              }).each("end.brush", function() {
                xExtentDomain = extent1.i;
                yExtentDomain = extent1.j;
                event_({
                  type: "brush",
                  mode: "resize"
                });
                event_({type: "brushend"});
              });
            } else {
              event_({type: "brushstart"});
              event_({
                type: "brush",
                mode: "resize"
              });
              event_({type: "brushend"});
            }
          });
        };
        function redraw(g) {
          g.selectAll(".resize").attr("transform", function(d) {
            return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
          });
        }
        function redrawX(g) {
          g.select(".extent").attr("x", xExtent[0]);
          g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
          g.select(".extent").attr("y", yExtent[0]);
          g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
          var target = this,
              eventTarget = d3.select(d3.event.target),
              event_ = event.of(target, arguments),
              g = d3.select(target),
              resizing = eventTarget.datum(),
              resizingX = !/^(n|s)$/.test(resizing) && x,
              resizingY = !/^(e|w)$/.test(resizing) && y,
              dragging = eventTarget.classed("extent"),
              dragRestore = d3_event_dragSuppress(target),
              center,
              origin = d3.mouse(target),
              offset;
          var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
          if (d3.event.changedTouches) {
            w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
          } else {
            w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
          }
          g.interrupt().selectAll("*").interrupt();
          if (dragging) {
            origin[0] = xExtent[0] - origin[0];
            origin[1] = yExtent[0] - origin[1];
          } else if (resizing) {
            var ex = +/w$/.test(resizing),
                ey = +/^n/.test(resizing);
            offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
            origin[0] = xExtent[ex];
            origin[1] = yExtent[ey];
          } else if (d3.event.altKey)
            center = origin.slice();
          g.style("pointer-events", "none").selectAll(".resize").style("display", null);
          d3.select("body").style("cursor", eventTarget.style("cursor"));
          event_({type: "brushstart"});
          brushmove();
          function keydown() {
            if (d3.event.keyCode == 32) {
              if (!dragging) {
                center = null;
                origin[0] -= xExtent[1];
                origin[1] -= yExtent[1];
                dragging = 2;
              }
              d3_eventPreventDefault();
            }
          }
          function keyup() {
            if (d3.event.keyCode == 32 && dragging == 2) {
              origin[0] += xExtent[1];
              origin[1] += yExtent[1];
              dragging = 0;
              d3_eventPreventDefault();
            }
          }
          function brushmove() {
            var point = d3.mouse(target),
                moved = false;
            if (offset) {
              point[0] += offset[0];
              point[1] += offset[1];
            }
            if (!dragging) {
              if (d3.event.altKey) {
                if (!center)
                  center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                origin[0] = xExtent[+(point[0] < center[0])];
                origin[1] = yExtent[+(point[1] < center[1])];
              } else
                center = null;
            }
            if (resizingX && move1(point, x, 0)) {
              redrawX(g);
              moved = true;
            }
            if (resizingY && move1(point, y, 1)) {
              redrawY(g);
              moved = true;
            }
            if (moved) {
              redraw(g);
              event_({
                type: "brush",
                mode: dragging ? "move" : "resize"
              });
            }
          }
          function move1(point, scale, i) {
            var range = d3_scaleRange(scale),
                r0 = range[0],
                r1 = range[1],
                position = origin[i],
                extent = i ? yExtent : xExtent,
                size = extent[1] - extent[0],
                min,
                max;
            if (dragging) {
              r0 -= position;
              r1 -= size + position;
            }
            min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
            if (dragging) {
              max = (min += position) + size;
            } else {
              if (center)
                position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
              if (position < min) {
                max = min;
                min = position;
              } else {
                max = position;
              }
            }
            if (extent[0] != min || extent[1] != max) {
              if (i)
                yExtentDomain = null;
              else
                xExtentDomain = null;
              extent[0] = min;
              extent[1] = max;
              return true;
            }
          }
          function brushend() {
            brushmove();
            g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
            d3.select("body").style("cursor", null);
            w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
            dragRestore();
            event_({type: "brushend"});
          }
        }
        brush.x = function(z) {
          if (!arguments.length)
            return x;
          x = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.y = function(z) {
          if (!arguments.length)
            return y;
          y = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.clamp = function(z) {
          if (!arguments.length)
            return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;
          if (x && y)
            xClamp = !!z[0], yClamp = !!z[1];
          else if (x)
            xClamp = !!z;
          else if (y)
            yClamp = !!z;
          return brush;
        };
        brush.extent = function(z) {
          var x0,
              x1,
              y0,
              y1,
              t;
          if (!arguments.length) {
            if (x) {
              if (xExtentDomain) {
                x0 = xExtentDomain[0], x1 = xExtentDomain[1];
              } else {
                x0 = xExtent[0], x1 = xExtent[1];
                if (x.invert)
                  x0 = x.invert(x0), x1 = x.invert(x1);
                if (x1 < x0)
                  t = x0, x0 = x1, x1 = t;
              }
            }
            if (y) {
              if (yExtentDomain) {
                y0 = yExtentDomain[0], y1 = yExtentDomain[1];
              } else {
                y0 = yExtent[0], y1 = yExtent[1];
                if (y.invert)
                  y0 = y.invert(y0), y1 = y.invert(y1);
                if (y1 < y0)
                  t = y0, y0 = y1, y1 = t;
              }
            }
            return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
          }
          if (x) {
            x0 = z[0], x1 = z[1];
            if (y)
              x0 = x0[0], x1 = x1[0];
            xExtentDomain = [x0, x1];
            if (x.invert)
              x0 = x(x0), x1 = x(x1);
            if (x1 < x0)
              t = x0, x0 = x1, x1 = t;
            if (x0 != xExtent[0] || x1 != xExtent[1])
              xExtent = [x0, x1];
          }
          if (y) {
            y0 = z[0], y1 = z[1];
            if (x)
              y0 = y0[1], y1 = y1[1];
            yExtentDomain = [y0, y1];
            if (y.invert)
              y0 = y(y0), y1 = y(y1);
            if (y1 < y0)
              t = y0, y0 = y1, y1 = t;
            if (y0 != yExtent[0] || y1 != yExtent[1])
              yExtent = [y0, y1];
          }
          return brush;
        };
        brush.clear = function() {
          if (!brush.empty()) {
            xExtent = [0, 0], yExtent = [0, 0];
            xExtentDomain = yExtentDomain = null;
          }
          return brush;
        };
        brush.empty = function() {
          return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, "on");
      };
      var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
      };
      var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
      var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
      var d3_time_formatUtc = d3_time_format.utc;
      var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
      d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
      function d3_time_formatIsoNative(date) {
        return date.toISOString();
      }
      d3_time_formatIsoNative.parse = function(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
      };
      d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
      d3_time.second = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 1e3) * 1e3);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
      }, function(date) {
        return date.getSeconds();
      });
      d3_time.seconds = d3_time.second.range;
      d3_time.seconds.utc = d3_time.second.utc.range;
      d3_time.minute = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 6e4) * 6e4);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
      }, function(date) {
        return date.getMinutes();
      });
      d3_time.minutes = d3_time.minute.range;
      d3_time.minutes.utc = d3_time.minute.utc.range;
      d3_time.hour = d3_time_interval(function(date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
      }, function(date) {
        return date.getHours();
      });
      d3_time.hours = d3_time.hour.range;
      d3_time.hours.utc = d3_time.hour.utc.range;
      d3_time.month = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
      }, function(date, offset) {
        date.setMonth(date.getMonth() + offset);
      }, function(date) {
        return date.getMonth();
      });
      d3_time.months = d3_time.month.range;
      d3_time.months.utc = d3_time.month.utc.range;
      function d3_time_scale(linear, methods, format) {
        function scale(x) {
          return linear(x);
        }
        scale.invert = function(x) {
          return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return linear.domain().map(d3_time_scaleDate);
          linear.domain(x);
          return scale;
        };
        function tickMethod(extent, count) {
          var span = extent[1] - extent[0],
              target = span / count,
              i = d3.bisect(d3_time_scaleSteps, target);
          return i == d3_time_scaleSteps.length ? [methods.year, d3_scale_linearTickRange(extent.map(function(d) {
            return d / 31536e6;
          }), count)[2]] : !i ? [d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2]] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function(interval, skip) {
          var domain = scale.domain(),
              extent = d3_scaleExtent(domain),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
          if (method)
            interval = method[0], skip = method[1];
          function skipped(date) {
            return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
          }
          return scale.domain(d3_scale_nice(domain, skip > 1 ? {
            floor: function(date) {
              while (skipped(date = interval.floor(date)))
                date = d3_time_scaleDate(date - 1);
              return date;
            },
            ceil: function(date) {
              while (skipped(date = interval.ceil(date)))
                date = d3_time_scaleDate(+date + 1);
              return date;
            }
          } : interval));
        };
        scale.ticks = function(interval, skip) {
          var extent = d3_scaleExtent(scale.domain()),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [{range: interval}, skip];
          if (method)
            interval = method[0], skip = method[1];
          return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function() {
          return format;
        };
        scale.copy = function() {
          return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_time_scaleDate(t) {
        return new Date(t);
      }
      var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];
      var d3_time_scaleLocalMethods = [[d3_time.second, 1], [d3_time.second, 5], [d3_time.second, 15], [d3_time.second, 30], [d3_time.minute, 1], [d3_time.minute, 5], [d3_time.minute, 15], [d3_time.minute, 30], [d3_time.hour, 1], [d3_time.hour, 3], [d3_time.hour, 6], [d3_time.hour, 12], [d3_time.day, 1], [d3_time.day, 2], [d3_time.week, 1], [d3_time.month, 1], [d3_time.month, 3], [d3_time.year, 1]];
      var d3_time_scaleLocalFormat = d3_time_format.multi([[".%L", function(d) {
        return d.getMilliseconds();
      }], [":%S", function(d) {
        return d.getSeconds();
      }], ["%I:%M", function(d) {
        return d.getMinutes();
      }], ["%I %p", function(d) {
        return d.getHours();
      }], ["%a %d", function(d) {
        return d.getDay() && d.getDate() != 1;
      }], ["%b %d", function(d) {
        return d.getDate() != 1;
      }], ["%B", function(d) {
        return d.getMonth();
      }], ["%Y", d3_true]]);
      var d3_time_scaleMilliseconds = {
        range: function(start, stop, step) {
          return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
      };
      d3_time_scaleLocalMethods.year = d3_time.year;
      d3_time.scale = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
      };
      var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
        return [m[0].utc, m[1]];
      });
      var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([[".%L", function(d) {
        return d.getUTCMilliseconds();
      }], [":%S", function(d) {
        return d.getUTCSeconds();
      }], ["%I:%M", function(d) {
        return d.getUTCMinutes();
      }], ["%I %p", function(d) {
        return d.getUTCHours();
      }], ["%a %d", function(d) {
        return d.getUTCDay() && d.getUTCDate() != 1;
      }], ["%b %d", function(d) {
        return d.getUTCDate() != 1;
      }], ["%B", function(d) {
        return d.getUTCMonth();
      }], ["%Y", d3_true]]);
      d3_time_scaleUtcMethods.year = d3_time.year.utc;
      d3_time.scale.utc = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
      };
      d3.text = d3_xhrType(function(request) {
        return request.responseText;
      });
      d3.json = function(url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
      };
      function d3_json(request) {
        return JSON.parse(request.responseText);
      }
      d3.html = function(url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
      };
      function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
      }
      d3.xml = d3_xhrType(function(request) {
        return request.responseXML;
      });
      if (typeof define === "function" && define.amd)
        define(d3);
      else if (typeof module === "object" && module.exports)
        module.exports = d3;
      this.d3 = d3;
    }();
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, "d3");
});



System.register("npm:react-d3@0.3.1/barchart/Bar", ["react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  module.exports = React.createClass({
    displayName: "exports",
    propTypes: {
      fill: React.PropTypes.string,
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      offset: React.PropTypes.number
    },
    getDefaultProps: function() {
      return {offset: 0};
    },
    render: function() {
      return (React.createElement("rect", {
        fill: this.props.fill,
        width: this.props.width,
        height: this.props.height,
        x: this.props.offset,
        y: this.props.availableHeight - this.props.height,
        className: "rd3-barchart-bar"
      }));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/axes/AxisTicks", ["react", "d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  var d3 = require('d3');
  module.exports = React.createClass({
    displayName: 'AxisTick',
    propTypes: {
      scale: React.PropTypes.func.isRequired,
      orient: React.PropTypes.oneOf(['top', 'bottom', 'left', 'right']).isRequired,
      tickArguments: React.PropTypes.array,
      tickValues: React.PropTypes.array,
      innerTickSize: React.PropTypes.number,
      outerTickSize: React.PropTypes.number,
      tickPadding: React.PropTypes.number,
      tickFormat: React.PropTypes.func,
      tickStroke: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        innerTickSize: 6,
        outerTickSize: 6,
        tickStroke: '#000',
        tickPadding: 3,
        tickArguments: [10],
        tickValues: null
      };
    },
    render: function() {
      var props = this.props;
      var tr,
          ticks,
          scale,
          adjustedScale,
          textAnchor,
          tickFormat,
          y0,
          y1,
          y2,
          dy,
          x0,
          x1,
          x2,
          dx;
      var sign = props.orient === 'top' || props.orient === 'right' ? -1 : 1;
      var tickSpacing = Math.max(props.innerTickSize, 0) + props.tickPadding;
      scale = props.scale;
      if (props.tickValues) {
        ticks = props.tickValues;
      } else if (scale.ticks) {
        ticks = scale.ticks.apply(scale, props.tickArguments);
      } else {
        ticks = scale.domain();
      }
      if (props.tickFormatting) {
        tickFormat = props.tickFormatting;
      } else if (scale.tickFormat) {
        tickFormat = scale.tickFormat.apply(scale, props.tickArguments);
      } else {
        tickFormat = function(d) {
          return d;
        };
      }
      adjustedScale = scale.rangeBand ? function(d) {
        return scale(d) + scale.rangeBand() / 2;
      } : scale;
      switch (props.orient) {
        case 'top':
          tr = function(tick) {
            return ("translate(" + adjustedScale(tick) + ",0)");
          };
          textAnchor = "middle";
          y2 = props.innerTickSize * sign;
          y1 = tickSpacing * sign;
          dy = sign < 0 ? "0em" : ".71em";
          break;
        case 'bottom':
          tr = function(tick) {
            return ("translate(" + adjustedScale(tick) + ",0)");
          };
          textAnchor = "middle";
          y2 = props.innerTickSize * sign;
          y1 = tickSpacing * sign;
          dy = sign < 0 ? "0em" : ".71em";
          break;
        case 'left':
          tr = function(tick) {
            return ("translate(0," + adjustedScale(tick) + ")");
          };
          textAnchor = "end";
          x2 = props.innerTickSize * -sign;
          x1 = tickSpacing * -sign;
          dy = ".32em";
          break;
        case 'right':
          tr = function(tick) {
            return ("translate(0," + adjustedScale(tick) + ")");
          };
          textAnchor = "start";
          x2 = props.innerTickSize * -sign;
          x1 = tickSpacing * -sign;
          dy = ".32em";
          break;
      }
      return (React.createElement("g", null, ticks.map(function(tick, i) {
        return (React.createElement("g", {
          key: i,
          className: "tick",
          transform: tr(tick)
        }, React.createElement("line", {
          style: {
            shapeRendering: 'crispEdges',
            opacity: '1',
            stroke: props.tickStroke
          },
          x2: x2,
          y2: y2
        }), React.createElement("text", {
          strokeWidth: "0.01",
          dy: dy,
          x: x1,
          y: y1,
          style: {
            stroke: props.tickTextStroke,
            fill: props.tickTextStroke
          },
          textAnchor: textAnchor
        }, tickFormat(tick))));
      })));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/axes/AxisLine", ["react", "d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  var d3 = require('d3');
  module.exports = React.createClass({
    displayName: 'AxisLine',
    propTypes: {
      scale: React.PropTypes.func.isRequired,
      innerTickSize: React.PropTypes.number,
      outerTickSize: React.PropTypes.number,
      tickPadding: React.PropTypes.number,
      tickArguments: React.PropTypes.array,
      fill: React.PropTypes.string,
      stroke: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        innerTickSize: 6,
        outerTickSize: 6,
        tickPadding: 3,
        fill: 'none',
        tickArguments: [10],
        tickValues: null,
        tickFormat: null
      };
    },
    _d3_scaleExtent: function(domain) {
      var start = domain[0],
          stop = domain[domain.length - 1];
      return start < stop ? [start, stop] : [stop, start];
    },
    _d3_scaleRange: function(scale) {
      return scale.rangeExtent ? scale.rangeExtent() : this._d3_scaleExtent(scale.range());
    },
    render: function() {
      var props = this.props;
      var sign = props.orient === "top" || props.orient === "left" ? -1 : 1;
      var range = this._d3_scaleRange(props.scale);
      var d;
      if (props.orient === "bottom" || props.orient === "top") {
        d = "M" + range[0] + "," + sign * props.outerTickSize + "V0H" + range[1] + "V" + sign * props.outerTickSize;
      } else {
        d = "M" + sign * props.outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * props.outerTickSize;
      }
      return (React.createElement("path", {
        className: "domain",
        d: d,
        style: {'shapeRendering': 'crispEdges'},
        fill: props.fill,
        stroke: props.stroke,
        strokeWidth: props.strokeWidth
      }));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/axes/Label", ["react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  module.exports = React.createClass({
    displayName: 'Label',
    render: function() {
      var props = this.props;
      var strokeWidth = '0.01';
      if (props.label) {
        switch (props.orient) {
          case 'top':
            return (React.createElement("text", {
              className: "axis-label",
              strokeWidth: strokeWidth,
              y: props.offset,
              x: props.width / 2,
              textAnchor: "middle"
            }, props.label));
          case 'bottom':
            return (React.createElement("text", {
              className: "axis-label",
              strokeWidth: strokeWidth,
              y: props.offset,
              x: props.width / 2,
              textAnchor: "middle"
            }, props.label));
          case 'left':
            return (React.createElement("text", {
              className: "axis-label",
              strokeWidth: strokeWidth,
              y: -props.offset,
              x: -props.height / 2,
              textAnchor: "middle",
              transform: "rotate(270)"
            }, props.label));
          case 'right':
            return (React.createElement("text", {
              className: "axis-label",
              strokeWidth: strokeWidth,
              y: props.offset,
              x: -props.height / 2,
              textAnchor: "middle",
              transform: "rotate(270)"
            }, props.label));
        }
      }
      return React.createElement("text", null);
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/axes/YAxis", ["react", "d3", "./AxisTicks", "./AxisLine", "./Label"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var AxisTicks = require("./AxisTicks");
  var AxisLine = require("./AxisLine");
  var Label = require("./Label");
  module.exports = React.createClass({
    displayName: 'YAxis',
    propTypes: {
      yAxisClassName: React.PropTypes.string,
      yOrient: React.PropTypes.oneOf(['left', 'right']),
      yScale: React.PropTypes.func.isRequired,
      fill: React.PropTypes.string,
      stroke: React.PropTypes.string,
      tickStroke: React.PropTypes.string,
      strokeWidth: React.PropTypes.string,
      yAxisOffset: React.PropTypes.number
    },
    getDefaultProps: function() {
      return {
        yAxisClassName: 'y axis',
        yOrient: 'left',
        fill: 'none',
        stroke: '#000',
        tickStroke: '#000',
        strokeWidth: '1',
        yAxisOffset: 0
      };
    },
    render: function() {
      var props = this.props;
      var t;
      if (props.yOrient === 'right') {
        t = ("translate(" + (props.yAxisOffset + props.width) + ",0)");
      } else {
        t = ("translate(" + props.yAxisOffset + ",0)");
      }
      var tickArguments;
      if (props.yAxisTickCount) {
        tickArguments = [props.yAxisTickCount];
      }
      if (props.yAxisTickInterval) {
        tickArguments = [d3.time[props.yAxisTickInterval.unit], props.yAxisTickInterval.interval];
      }
      return (React.createElement("g", {
        className: props.yAxisClassName,
        transform: t
      }, React.createElement(AxisTicks, {
        tickFormatting: props.tickFormatting,
        tickArguments: tickArguments,
        tickStroke: props.tickStroke,
        tickTextStroke: props.tickTextStroke,
        innerTickSize: props.tickSize,
        scale: props.yScale,
        orient: props.yOrient
      }), React.createElement(AxisLine, React.__spread({
        scale: props.yScale,
        stroke: props.stroke,
        orient: props.yOrient,
        outerTickSize: props.tickSize
      }, props)), React.createElement(Label, {
        label: props.yAxisLabel,
        offset: props.yAxisLabelOffset,
        orient: props.yOrient,
        margins: props.margins,
        height: props.height,
        width: props.width
      })));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/charts/BasicChart", ["react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  module.exports = React.createClass({
    displayName: 'BasicChart',
    render: function() {
      return (React.createElement("div", null, React.createElement("h4", null, this.props.title), React.createElement("svg", {
        viewBox: this.props.viewBox,
        width: this.props.width,
        height: this.props.height
      }, this.props.children)));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/Legend", ["react", "d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  var d3 = require('d3');
  module.exports = React.createClass({
    displayName: 'Legend',
    propTypes: {
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      margins: React.PropTypes.object,
      text: React.PropTypes.string,
      colors: React.PropTypes.func
    },
    getDefaultProps: function() {
      return {
        text: "#000",
        colors: d3.scale.category20c()
      };
    },
    render: function() {
      var props = this.props;
      var textStyle = {
        'color': 'black',
        'fontSize': '50%',
        'verticalAlign': 'top'
      };
      var legendItems = [];
      props.data.forEach(function(series, idx) {
        var itemStyle = {
          'color': props.colors(idx),
          'lineHeight': '60%',
          'fontSize': '200%'
        };
        legendItems.push(React.createElement("li", {
          style: itemStyle,
          key: idx
        }, React.createElement("span", {style: textStyle}, series.name)));
      });
      var legendFloat = 'right';
      var topMargin = props.margins.top;
      var legendBlockStyle = {
        'wordWrap': 'break-word',
        'width': props.sideOffset,
        'paddingLeft': '0',
        'marginBottom': '0',
        'marginTop': topMargin,
        'float': legendFloat
      };
      return React.createElement("ul", {style: legendBlockStyle}, legendItems);
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/Voronoi", ["react", "d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  var d3 = require('d3');
  var Polygon = React.createClass({
    displayName: "Polygon",
    _animateCircle: function() {
      this.props.structure.cursor('voronoi').cursor(this.props.id).update(function() {
        return 'active';
      });
    },
    _restoreCircle: function() {
      this.props.structure.cursor('voronoi').cursor(this.props.id).update(function() {
        return 'inactive';
      });
    },
    _drawPath: function(d) {
      if (d === undefined) {
        return;
      }
      return 'M' + d.join(',') + 'Z';
    },
    render: function() {
      return React.createElement("path", {
        onMouseOver: this._animateCircle,
        onMouseOut: this._restoreCircle,
        fill: "white",
        opacity: "0",
        d: this._drawPath(this.props.vnode)
      });
    }
  });
  module.exports = React.createClass({
    displayName: 'Voronoi',
    render: function() {
      var xScale = this.props.xScale;
      var yScale = this.props.yScale;
      var voronoi = d3.geom.voronoi().x(function(d) {
        return xScale(d.coord.x);
      }).y(function(d) {
        return yScale(d.coord.y);
      }).clipExtent([[0, 0], [this.props.width, this.props.height]]);
      var regions = voronoi(this.props.data).map(function(vnode, idx) {
        return React.createElement(Polygon, {
          structure: this.props.structure,
          key: idx,
          id: vnode.point.id,
          vnode: vnode
        });
      }.bind(this));
      return (React.createElement("g", null, regions));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/mixins/CartesianChartPropsMixin", ["react", "d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  var d3 = require('d3');
  module.exports = {
    propTypes: {
      axesColor: React.PropTypes.string,
      colors: React.PropTypes.func,
      data: React.PropTypes.oneOfType([React.PropTypes.array, React.PropTypes.object]).isRequired,
      xOrient: React.PropTypes.oneOf(['top', 'bottom']),
      yOrient: React.PropTypes.oneOf(['left', 'right']),
      yAxisTickCount: React.PropTypes.number,
      yAxisLabel: React.PropTypes.string,
      yAxisLabelOffset: React.PropTypes.number,
      yAxisFormatter: React.PropTypes.func,
      xAxisTickInterval: React.PropTypes.object,
      xAxisLabel: React.PropTypes.string,
      xAxisLabelOffset: React.PropTypes.number,
      xAxisFormatter: React.PropTypes.func,
      legend: React.PropTypes.bool,
      legendOffset: React.PropTypes.number,
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      xAccessor: React.PropTypes.func,
      yAccessor: React.PropTypes.func,
      title: React.PropTypes.string,
      viewBox: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        data: [],
        xOrient: 'bottom',
        xAxisLabel: '',
        xAxisLabelOffset: 38,
        yOrient: 'left',
        yAxisLabel: '',
        yAxisLabelOffset: 35,
        legend: false,
        legendOffset: 120,
        width: 400,
        height: 200,
        axesColor: '#000',
        title: '',
        colors: d3.scale.category20c(),
        xAccessor: function(d) {
          return d.x;
        },
        yAccessor: function(d) {
          return d.y;
        }
      };
    }
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/utils/index", ["d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var d3 = require('d3');
  exports.calculateScales = function(chartWidth, chartHeight, xValues, yValues) {
    var xScale,
        yScale;
    if (xValues.length > 0 && Object.prototype.toString.call(xValues[0]) === '[object Date]') {
      xScale = d3.time.scale().range([0, chartWidth]);
    } else {
      xScale = d3.scale.linear().range([0, chartWidth]);
    }
    xScale.domain(d3.extent(xValues));
    if (yValues.length > 0 && Object.prototype.toString.call(yValues[0]) === '[object Date]') {
      yScale = d3.time.scale().range([chartHeight, 0]);
    } else {
      yScale = d3.scale.linear().range([chartHeight, 0]);
    }
    yScale.domain(d3.extent(yValues));
    return {
      xScale: xScale,
      yScale: yScale
    };
  };
  exports.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this,
          args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow)
        func.apply(context, args);
    };
  };
  exports.flattenData = function(data, xAccessor, yAccessor) {
    var allValues = [];
    var xValues = [];
    var yValues = [];
    var coincidentCoordinateCheck = {};
    data.forEach(function(series) {
      series.values.forEach(function(item, idx) {
        var x = xAccessor(item);
        if (isNaN(x)) {
          return;
        }
        xValues.push(x);
        var y = yAccessor(item);
        var yNode;
        if (typeof y === 'object' && Object.keys(y).length > 0) {
          Object.keys(y).forEach(function(key) {
            if (isNaN(y[key])) {
              return;
            }
            yValues.push(y[key]);
            yNode = 0;
          });
        } else {
          if (isNaN(y)) {
            return;
          }
          yValues.push(y);
          yNode = y;
        }
        var xyCoords = (x + "-" + yNode);
        if (xyCoords in coincidentCoordinateCheck) {
          return;
        }
        coincidentCoordinateCheck[xyCoords] = '';
        var pointItem = {
          coord: {
            x: x,
            y: yNode
          },
          id: (series.name + "-" + idx)
        };
        allValues.push(pointItem);
      });
    });
    return {
      allValues: allValues,
      xValues: xValues,
      yValues: yValues
    };
  };
  exports.shade = function(hex, percent) {
    var R,
        G,
        B,
        red,
        green,
        blue,
        number;
    var min = Math.min,
        round = Math.round;
    if (hex.length !== 7) {
      return hex;
    }
    number = parseInt(hex.slice(1), 16);
    R = number >> 16;
    G = number >> 8 & 0xFF;
    B = number & 0xFF;
    red = min(255, round((1 + percent) * R)).toString(16);
    green = min(255, round((1 + percent) * G)).toString(16);
    blue = min(255, round((1 + percent) * B)).toString(16);
    return ("#" + red + green + blue);
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/linechart/Line", ["react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  module.exports = React.createClass({
    displayName: 'Line',
    propTypes: {
      data: React.PropTypes.object,
      strokeWidth: React.PropTypes.number,
      path: React.PropTypes.string,
      fill: React.PropTypes.string,
      stroke: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        stroke: '#1f77b4',
        strokeWidth: 1.5,
        fill: 'none',
        className: 'rd3-linechart-path'
      };
    },
    getInitialState: function() {
      return {
        lineStrokeWidth: this.props.strokeWidth,
        lineStroke: this.props.stroke
      };
    },
    componentDidMount: function() {
      var props = this.props;
      var unobserve = props.voronoiSeriesRef.observe(function() {
        var lineStatus = props.voronoiSeriesRef.cursor().deref();
        if (lineStatus === 'active') {
          this._animateLine(props.id);
        } else if (lineStatus === 'inactive') {
          this._restoreLine(props.id);
        }
      }.bind(this));
    },
    componentWillUnmount: function() {
      this.props.voronoiSeriesRef.destroy();
    },
    _animateLine: function(id) {
      this.setState({lineStrokeWidth: this.state.lineStrokeWidth * 1.8});
    },
    _restoreLine: function(id) {
      this.setState({lineStrokeWidth: this.props.strokeWidth});
    },
    render: function() {
      var props = this.props;
      var state = this.state;
      return (React.createElement("path", {
        d: props.path,
        stroke: state.lineStroke,
        strokeWidth: state.lineStrokeWidth,
        fill: props.fill,
        className: props.className
      }));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/linechart/Line-dotted", ["react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  module.exports = React.createClass({
    displayName: 'Line',
    propTypes: {
      data: React.PropTypes.object,
      strokeWidth: React.PropTypes.number,
      path: React.PropTypes.string,
      fill: React.PropTypes.string,
      stroke: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        stroke: '#1f77b4',
        strokeWidth: 1.5,
        fill: 'none',
        className: 'rd3-linechart-path'
      };
    },
    getInitialState: function() {
      return {
        lineStrokeWidth: this.props.strokeWidth,
        lineStroke: this.props.stroke
      };
    },
    componentDidMount: function() {
      var props = this.props;
      var unobserve = props.voronoiSeriesRef.observe(function() {
        var lineStatus = props.voronoiSeriesRef.cursor().deref();
        if (lineStatus === 'active') {
          this._animateLine(props.id);
        } else if (lineStatus === 'inactive') {
          this._restoreLine(props.id);
        }
      }.bind(this));
    },
    componentWillUnmount: function() {
      this.props.voronoiSeriesRef.destroy();
    },
    _animateLine: function(id) {
      this.setState({lineStrokeWidth: this.state.lineStrokeWidth * 1.8});
    },
    _restoreLine: function(id) {
      this.setState({lineStrokeWidth: this.props.strokeWidth});
    },
    render: function() {
      var props = this.props;
      var state = this.state;
      return (React.createElement("path", {
        d: props.path,
        stroke: state.lineStroke,
        strokeWidth: state.lineStrokeWidth,
        fill: props.fill,
        className: props.className
      }));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/piechart/Arc", ["react", "d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  var d3 = require('d3');
  module.exports = React.createClass({
    displayName: 'Arc',
    propTypes: {
      fill: React.PropTypes.string,
      d: React.PropTypes.string,
      startAngle: React.PropTypes.number,
      endAngle: React.PropTypes.number,
      innerRadius: React.PropTypes.number,
      outerRadius: React.PropTypes.number,
      labelTextFill: React.PropTypes.string,
      valueTextFill: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        labelTextFill: 'black',
        valueTextFill: 'white'
      };
    },
    render: function() {
      var props = this.props;
      var arc = d3.svg.arc().innerRadius(props.innerRadius).outerRadius(props.outerRadius).startAngle(props.startAngle).endAngle(props.endAngle);
      var rotate = ("rotate(" + ((props.startAngle + props.endAngle) / 2 * (180 / Math.PI)) + ")");
      var positions = arc.centroid();
      var radius = props.outerRadius;
      var dist = radius + 35;
      var angle = (props.startAngle + props.endAngle) / 2;
      var x = dist * (1.2 * Math.sin(angle));
      var y = -dist * Math.cos(angle);
      var t = ("translate(" + x + "," + y + ")");
      return (React.createElement("g", {className: "rd3-piechart-arc"}, React.createElement("path", {
        d: arc(),
        fill: props.fill
      }), React.createElement("line", {
        x1: "0",
        x2: "0",
        y1: -radius - 2,
        y2: -radius - 26,
        stroke: props.labelTextFill,
        transform: rotate,
        style: {
          'fill': props.labelTextFill,
          'strokeWidth': 2
        }
      }), React.createElement("text", {
        className: "rd3-piechart-label",
        transform: t,
        dy: ".35em",
        style: {
          'textAnchor': 'middle',
          'fill': props.labelTextFill,
          'shapeRendering': 'crispEdges'
        }
      }, props.label), React.createElement("text", {
        className: "rd3-piechart-text",
        transform: ("translate(" + arc.centroid() + ")"),
        dy: ".35em",
        style: {
          'shapeRendering': 'crispEdges',
          'textAnchor': 'middle',
          'fill': props.valueTextFill
        }
      }, props.value + '%')));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/areachart/Area", ["react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  module.exports = React.createClass({
    displayName: 'Area',
    propTypes: {
      path: React.PropTypes.string,
      fill: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {fill: '#3182bd'};
    },
    render: function() {
      return (React.createElement("path", {
        className: "rd3-areachart-area",
        d: this.props.path,
        fill: this.props.fill
      }));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/treemap/Cell", ["react", "d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  var d3 = require('d3');
  module.exports = React.createClass({
    displayName: 'Cell',
    propTypes: {
      fill: React.PropTypes.string,
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      label: React.PropTypes.string
    },
    render: function() {
      var props = this.props;
      var textStyle = {
        'textAnchor': 'middle',
        'fill': props.textColor,
        'fontSize': props.fontSize
      };
      var t = ("translate(" + props.x + ", " + props.y + "  )");
      return (React.createElement("g", {transform: t}, React.createElement("rect", {
        fill: props.fill,
        width: props.width,
        height: props.height,
        className: "rd3-treemap-cell"
      }), React.createElement("text", {
        x: props.width / 2,
        y: props.height / 2,
        dy: ".35em",
        style: textStyle,
        className: "rd3-treemap-cell-text"
      }, props.label)));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/scatterchart/Circle", ["react", "d3", "../utils/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var utils = require("../utils/index");
  module.exports = React.createClass({
    displayName: 'Circle',
    propTypes: {
      id: React.PropTypes.string,
      cx: React.PropTypes.number,
      cy: React.PropTypes.number,
      r: React.PropTypes.number,
      fill: React.PropTypes.string,
      stroke: React.PropTypes.string,
      strokeWidth: React.PropTypes.number,
      strokeOpacity: React.PropTypes.number,
      hoverAnimation: React.PropTypes.bool
    },
    getDefaultProps: function() {
      return {
        fill: '#1f77b4',
        className: 'rd3-scatterchart-circle'
      };
    },
    getInitialState: function() {
      return {
        circleRadius: this.props.r,
        circleFill: this.props.fill
      };
    },
    componentDidMount: function() {
      var props = this.props;
      var unobserve = props.voronoiRef.observe(function() {
        var circleStatus = props.voronoiRef.cursor().deref();
        if (circleStatus === 'active') {
          this._animateCircle(props.id);
        } else if (circleStatus === 'inactive') {
          this._restoreCircle(props.id);
        }
      }.bind(this));
    },
    componentWillUnmount: function() {
      this.props.voronoiRef.destroy();
    },
    render: function() {
      return (React.createElement("circle", {
        fill: this.state.circleFill,
        cx: this.props.cx,
        cy: this.props.cy,
        r: this.state.circleRadius,
        id: this.props.id,
        className: this.props.className
      }));
    },
    _animateCircle: function(id) {
      this.setState({
        circleRadius: this.state.circleRadius * (5 / 4),
        circleFill: utils.shade(this.props.fill, -0.2)
      });
    },
    _restoreCircle: function(id) {
      this.setState({
        circleRadius: this.props.r,
        circleFill: this.props.fill
      });
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/candlestick/Candle", ["react", "../utils/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var utils = require("../utils/index");
  module.exports = React.createClass({
    displayName: 'Candle',
    getInitialState: function() {
      return {
        candleWidth: this.props.width,
        candleFill: this.props.fill
      };
    },
    getDefaultProps: function() {
      return {
        stroke: '#000',
        strokeWidth: 1,
        shapeRendering: 'crispEdges',
        className: 'rd3-candlestick-candle'
      };
    },
    componentDidMount: function() {
      var props = this.props;
      props.voronoiRef.observe(function() {
        var candleStatus = props.voronoiRef.cursor().deref();
        if (candleStatus === 'active') {
          this._animateCandle(props.id);
        } else if (candleStatus === 'inactive') {
          this._restoreCandle(props.id);
        }
      }.bind(this));
    },
    componentWillUnmount: function() {
      this.props.voronoiRef.destroy();
    },
    _animateCandle: function(id) {
      this.setState({
        candleWidth: this.props.width * 1.5,
        candleFill: utils.shade(this.props.fill, -0.2)
      });
    },
    _restoreCandle: function(id) {
      this.setState({
        candleWidth: this.props.width,
        candleFill: this.props.fill
      });
    },
    render: function() {
      return (React.createElement("rect", {
        className: this.props.className,
        fill: this.state.candleFill,
        x: this.props.x - ((this.state.candleWidth - this.props.width) / 2),
        y: this.props.y,
        stroke: this.props.stroke,
        strokeWidth: this.props.strokeWidth,
        style: {shapeRendering: this.props.shapeRendering},
        width: this.state.candleWidth,
        height: this.props.height
      }));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/candlestick/Wick", ["react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  module.exports = React.createClass({
    displayName: 'Wick',
    propTypes: {
      strokeWidth: React.PropTypes.number,
      stroke: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        className: 'rd3-candlestick-wick',
        stroke: '#000',
        strokeWidth: 1,
        shapeRendering: "crispEdges"
      };
    },
    render: function() {
      var props = this.props;
      return React.createElement("line", {
        stroke: props.stroke,
        strokeWidth: props.strokeWidth,
        style: {shapeRendering: props.shapeRendering},
        className: props.className,
        x1: props.x1,
        y1: props.y1,
        x2: props.x2,
        y2: props.y2
      });
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("github:mbostock/d3@3.5.5/d3", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    "format global";
    "exports d3";
    !function() {
      var d3 = {version: "3.5.5"};
      var d3_arraySlice = [].slice,
          d3_array = function(list) {
            return d3_arraySlice.call(list);
          };
      var d3_document = this.document;
      function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
      }
      function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
      }
      if (d3_document) {
        try {
          d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        } catch (e) {
          d3_array = function(list) {
            var i = list.length,
                array = new Array(i);
            while (i--)
              array[i] = list[i];
            return array;
          };
        }
      }
      if (!Date.now)
        Date.now = function() {
          return +new Date();
        };
      if (d3_document) {
        try {
          d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
        } catch (error) {
          var d3_element_prototype = this.Element.prototype,
              d3_element_setAttribute = d3_element_prototype.setAttribute,
              d3_element_setAttributeNS = d3_element_prototype.setAttributeNS,
              d3_style_prototype = this.CSSStyleDeclaration.prototype,
              d3_style_setProperty = d3_style_prototype.setProperty;
          d3_element_prototype.setAttribute = function(name, value) {
            d3_element_setAttribute.call(this, name, value + "");
          };
          d3_element_prototype.setAttributeNS = function(space, local, value) {
            d3_element_setAttributeNS.call(this, space, local, value + "");
          };
          d3_style_prototype.setProperty = function(name, value, priority) {
            d3_style_setProperty.call(this, name, value + "", priority);
          };
        }
      }
      d3.ascending = d3_ascending;
      function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      d3.descending = function(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
      };
      d3.min = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null && a > b)
              a = b;
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && a > b)
              a = b;
        }
        return a;
      };
      d3.max = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null && b > a)
              a = b;
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b > a)
              a = b;
        }
        return a;
      };
      d3.extent = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b,
            c;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = c = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null) {
              if (a > b)
                a = b;
              if (c < b)
                c = b;
            }
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = c = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null) {
              if (a > b)
                a = b;
              if (c < b)
                c = b;
            }
        }
        return [a, c];
      };
      function d3_number(x) {
        return x === null ? NaN : +x;
      }
      function d3_numeric(x) {
        return !isNaN(x);
      }
      d3.sum = function(array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = +array[i]))
              s += a;
        } else {
          while (++i < n)
            if (d3_numeric(a = +f.call(array, array[i], i)))
              s += a;
        }
        return s;
      };
      d3.mean = function(array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1,
            j = n;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = d3_number(array[i])))
              s += a;
            else
              --j;
        } else {
          while (++i < n)
            if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
              s += a;
            else
              --j;
        }
        if (j)
          return s / j;
      };
      d3.quantile = function(values, p) {
        var H = (values.length - 1) * p + 1,
            h = Math.floor(H),
            v = +values[h - 1],
            e = H - h;
        return e ? v + e * (values[h] - v) : v;
      };
      d3.median = function(array, f) {
        var numbers = [],
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = d3_number(array[i])))
              numbers.push(a);
        } else {
          while (++i < n)
            if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
              numbers.push(a);
        }
        if (numbers.length)
          return d3.quantile(numbers.sort(d3_ascending), .5);
      };
      d3.variance = function(array, f) {
        var n = array.length,
            m = 0,
            a,
            d,
            s = 0,
            i = -1,
            j = 0;
        if (arguments.length === 1) {
          while (++i < n) {
            if (d3_numeric(a = d3_number(array[i]))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        } else {
          while (++i < n) {
            if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        }
        if (j > 1)
          return s / (j - 1);
      };
      d3.deviation = function() {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
      };
      function d3_bisector(compare) {
        return {
          left: function(a, x, lo, hi) {
            if (arguments.length < 3)
              lo = 0;
            if (arguments.length < 4)
              hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) < 0)
                lo = mid + 1;
              else
                hi = mid;
            }
            return lo;
          },
          right: function(a, x, lo, hi) {
            if (arguments.length < 3)
              lo = 0;
            if (arguments.length < 4)
              hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) > 0)
                hi = mid;
              else
                lo = mid + 1;
            }
            return lo;
          }
        };
      }
      var d3_bisect = d3_bisector(d3_ascending);
      d3.bisectLeft = d3_bisect.left;
      d3.bisect = d3.bisectRight = d3_bisect.right;
      d3.bisector = function(f) {
        return d3_bisector(f.length === 1 ? function(d, x) {
          return d3_ascending(f(d), x);
        } : f);
      };
      d3.shuffle = function(array, i0, i1) {
        if ((m = arguments.length) < 3) {
          i1 = array.length;
          if (m < 2)
            i0 = 0;
        }
        var m = i1 - i0,
            t,
            i;
        while (m) {
          i = Math.random() * m-- | 0;
          t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
      };
      d3.permute = function(array, indexes) {
        var i = indexes.length,
            permutes = new Array(i);
        while (i--)
          permutes[i] = array[indexes[i]];
        return permutes;
      };
      d3.pairs = function(array) {
        var i = 0,
            n = array.length - 1,
            p0,
            p1 = array[0],
            pairs = new Array(n < 0 ? 0 : n);
        while (i < n)
          pairs[i] = [p0 = p1, p1 = array[++i]];
        return pairs;
      };
      d3.zip = function() {
        if (!(n = arguments.length))
          return [];
        for (var i = -1,
            m = d3.min(arguments, d3_zipLength),
            zips = new Array(m); ++i < m; ) {
          for (var j = -1,
              n,
              zip = zips[i] = new Array(n); ++j < n; ) {
            zip[j] = arguments[j][i];
          }
        }
        return zips;
      };
      function d3_zipLength(d) {
        return d.length;
      }
      d3.transpose = function(matrix) {
        return d3.zip.apply(d3, matrix);
      };
      d3.keys = function(map) {
        var keys = [];
        for (var key in map)
          keys.push(key);
        return keys;
      };
      d3.values = function(map) {
        var values = [];
        for (var key in map)
          values.push(map[key]);
        return values;
      };
      d3.entries = function(map) {
        var entries = [];
        for (var key in map)
          entries.push({
            key: key,
            value: map[key]
          });
        return entries;
      };
      d3.merge = function(arrays) {
        var n = arrays.length,
            m,
            i = -1,
            j = 0,
            merged,
            array;
        while (++i < n)
          j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
          array = arrays[n];
          m = array.length;
          while (--m >= 0) {
            merged[--j] = array[m];
          }
        }
        return merged;
      };
      var abs = Math.abs;
      d3.range = function(start, stop, step) {
        if (arguments.length < 3) {
          step = 1;
          if (arguments.length < 2) {
            stop = start;
            start = 0;
          }
        }
        if ((stop - start) / step === Infinity)
          throw new Error("infinite range");
        var range = [],
            k = d3_range_integerScale(abs(step)),
            i = -1,
            j;
        start *= k, stop *= k, step *= k;
        if (step < 0)
          while ((j = start + step * ++i) > stop)
            range.push(j / k);
        else
          while ((j = start + step * ++i) < stop)
            range.push(j / k);
        return range;
      };
      function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1)
          k *= 10;
        return k;
      }
      function d3_class(ctor, properties) {
        for (var key in properties) {
          Object.defineProperty(ctor.prototype, key, {
            value: properties[key],
            enumerable: false
          });
        }
      }
      d3.map = function(object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
          object.forEach(function(key, value) {
            map.set(key, value);
          });
        } else if (Array.isArray(object)) {
          var i = -1,
              n = object.length,
              o;
          if (arguments.length === 1)
            while (++i < n)
              map.set(i, object[i]);
          else
            while (++i < n)
              map.set(f.call(object, o = object[i], i), o);
        } else {
          for (var key in object)
            map.set(key, object[key]);
        }
        return map;
      };
      function d3_Map() {
        this._ = Object.create(null);
      }
      var d3_map_proto = "__proto__",
          d3_map_zero = "\x00";
      d3_class(d3_Map, {
        has: d3_map_has,
        get: function(key) {
          return this._[d3_map_escape(key)];
        },
        set: function(key, value) {
          return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function() {
          var values = [];
          for (var key in this._)
            values.push(this._[key]);
          return values;
        },
        entries: function() {
          var entries = [];
          for (var key in this._)
            entries.push({
              key: d3_map_unescape(key),
              value: this._[key]
            });
          return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
          for (var key in this._)
            f.call(this, d3_map_unescape(key), this._[key]);
        }
      });
      function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
      }
      function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
      }
      function d3_map_has(key) {
        return d3_map_escape(key) in this._;
      }
      function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
      }
      function d3_map_keys() {
        var keys = [];
        for (var key in this._)
          keys.push(d3_map_unescape(key));
        return keys;
      }
      function d3_map_size() {
        var size = 0;
        for (var key in this._)
          ++size;
        return size;
      }
      function d3_map_empty() {
        for (var key in this._)
          return false;
        return true;
      }
      d3.nest = function() {
        var nest = {},
            keys = [],
            sortKeys = [],
            sortValues,
            rollup;
        function map(mapType, array, depth) {
          if (depth >= keys.length)
            return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
          var i = -1,
              n = array.length,
              key = keys[depth++],
              keyValue,
              object,
              setter,
              valuesByKey = new d3_Map(),
              values;
          while (++i < n) {
            if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
              values.push(object);
            } else {
              valuesByKey.set(keyValue, [object]);
            }
          }
          if (mapType) {
            object = mapType();
            setter = function(keyValue, values) {
              object.set(keyValue, map(mapType, values, depth));
            };
          } else {
            object = {};
            setter = function(keyValue, values) {
              object[keyValue] = map(mapType, values, depth);
            };
          }
          valuesByKey.forEach(setter);
          return object;
        }
        function entries(map, depth) {
          if (depth >= keys.length)
            return map;
          var array = [],
              sortKey = sortKeys[depth++];
          map.forEach(function(key, keyMap) {
            array.push({
              key: key,
              values: entries(keyMap, depth)
            });
          });
          return sortKey ? array.sort(function(a, b) {
            return sortKey(a.key, b.key);
          }) : array;
        }
        nest.map = function(array, mapType) {
          return map(mapType, array, 0);
        };
        nest.entries = function(array) {
          return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function(d) {
          keys.push(d);
          return nest;
        };
        nest.sortKeys = function(order) {
          sortKeys[keys.length - 1] = order;
          return nest;
        };
        nest.sortValues = function(order) {
          sortValues = order;
          return nest;
        };
        nest.rollup = function(f) {
          rollup = f;
          return nest;
        };
        return nest;
      };
      d3.set = function(array) {
        var set = new d3_Set();
        if (array)
          for (var i = 0,
              n = array.length; i < n; ++i)
            set.add(array[i]);
        return set;
      };
      function d3_Set() {
        this._ = Object.create(null);
      }
      d3_class(d3_Set, {
        has: d3_map_has,
        add: function(key) {
          this._[d3_map_escape(key += "")] = true;
          return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
          for (var key in this._)
            f.call(this, d3_map_unescape(key));
        }
      });
      d3.behavior = {};
      function d3_identity(d) {
        return d;
      }
      d3.rebind = function(target, source) {
        var i = 1,
            n = arguments.length,
            method;
        while (++i < n)
          target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
      };
      function d3_rebind(target, source, method) {
        return function() {
          var value = method.apply(source, arguments);
          return value === source ? target : value;
        };
      }
      function d3_vendorSymbol(object, name) {
        if (name in object)
          return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0,
            n = d3_vendorPrefixes.length; i < n; ++i) {
          var prefixName = d3_vendorPrefixes[i] + name;
          if (prefixName in object)
            return prefixName;
        }
      }
      var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
      function d3_noop() {}
      d3.dispatch = function() {
        var dispatch = new d3_dispatch(),
            i = -1,
            n = arguments.length;
        while (++i < n)
          dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
      };
      function d3_dispatch() {}
      d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf("."),
            name = "";
        if (i >= 0) {
          name = type.slice(i + 1);
          type = type.slice(0, i);
        }
        if (type)
          return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
          if (listener == null)
            for (type in this) {
              if (this.hasOwnProperty(type))
                this[type].on(name, null);
            }
          return this;
        }
      };
      function d3_dispatch_event(dispatch) {
        var listeners = [],
            listenerByName = new d3_Map();
        function event() {
          var z = listeners,
              i = -1,
              n = z.length,
              l;
          while (++i < n)
            if (l = z[i].on)
              l.apply(this, arguments);
          return dispatch;
        }
        event.on = function(name, listener) {
          var l = listenerByName.get(name),
              i;
          if (arguments.length < 2)
            return l && l.on;
          if (l) {
            l.on = null;
            listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
            listenerByName.remove(name);
          }
          if (listener)
            listeners.push(listenerByName.set(name, {on: listener}));
          return dispatch;
        };
        return event;
      }
      d3.event = null;
      function d3_eventPreventDefault() {
        d3.event.preventDefault();
      }
      function d3_eventSource() {
        var e = d3.event,
            s;
        while (s = e.sourceEvent)
          e = s;
        return e;
      }
      function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(),
            i = 0,
            n = arguments.length;
        while (++i < n)
          dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function(thiz, argumentz) {
          return function(e1) {
            try {
              var e0 = e1.sourceEvent = d3.event;
              e1.target = target;
              d3.event = e1;
              dispatch[e1.type].apply(thiz, argumentz);
            } finally {
              d3.event = e0;
            }
          };
        };
        return dispatch;
      }
      d3.requote = function(s) {
        return s.replace(d3_requote_re, "\\$&");
      };
      var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      var d3_subclass = {}.__proto__ ? function(object, prototype) {
        object.__proto__ = prototype;
      } : function(object, prototype) {
        for (var property in prototype)
          object[property] = prototype[property];
      };
      function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
      }
      var d3_select = function(s, n) {
        return n.querySelector(s);
      },
          d3_selectAll = function(s, n) {
            return n.querySelectorAll(s);
          },
          d3_selectMatches = function(n, s) {
            var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
            d3_selectMatches = function(n, s) {
              return d3_selectMatcher.call(n, s);
            };
            return d3_selectMatches(n, s);
          };
      if (typeof Sizzle === "function") {
        d3_select = function(s, n) {
          return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
      }
      d3.selection = function() {
        return d3.select(d3_document.documentElement);
      };
      var d3_selectionPrototype = d3.selection.prototype = [];
      d3_selectionPrototype.select = function(selector) {
        var subgroups = [],
            subgroup,
            subnode,
            group,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroup.push(subnode = selector.call(node, node.__data__, i, j));
              if (subnode && "__data__" in node)
                subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function() {
          return d3_select(selector, this);
        };
      }
      d3_selectionPrototype.selectAll = function(selector) {
        var subgroups = [],
            subgroup,
            node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
              subgroup.parentNode = node;
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function() {
          return d3_selectAll(selector, this);
        };
      }
      var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: "http://www.w3.org/1999/xhtml",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
      d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function(name) {
          var i = name.indexOf(":"),
              prefix = name;
          if (i >= 0) {
            prefix = name.slice(0, i);
            name = name.slice(i + 1);
          }
          return d3_nsPrefix.hasOwnProperty(prefix) ? {
            space: d3_nsPrefix[prefix],
            local: name
          } : name;
        }
      };
      d3_selectionPrototype.attr = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node();
            name = d3.ns.qualify(name);
            return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
          }
          for (value in name)
            this.each(d3_selection_attr(value, name[value]));
          return this;
        }
        return this.each(d3_selection_attr(name, value));
      };
      function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
          this.setAttribute(name, value);
        }
        function attrConstantNS() {
          this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.removeAttribute(name);
          else
            this.setAttribute(name, x);
        }
        function attrFunctionNS() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.removeAttributeNS(name.space, name.local);
          else
            this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
      }
      function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
      }
      d3_selectionPrototype.classed = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node(),
                n = (name = d3_selection_classes(name)).length,
                i = -1;
            if (value = node.classList) {
              while (++i < n)
                if (!value.contains(name[i]))
                  return false;
            } else {
              value = node.getAttribute("class");
              while (++i < n)
                if (!d3_selection_classedRe(name[i]).test(value))
                  return false;
            }
            return true;
          }
          for (value in name)
            this.each(d3_selection_classed(value, name[value]));
          return this;
        }
        return this.each(d3_selection_classed(name, value));
      };
      function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
      }
      function d3_selection_classes(name) {
        return (name + "").trim().split(/^|\s+/);
      }
      function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
          var i = -1;
          while (++i < n)
            name[i](this, value);
        }
        function classedFunction() {
          var i = -1,
              x = value.apply(this, arguments);
          while (++i < n)
            name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
      }
      function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function(node, value) {
          if (c = node.classList)
            return value ? c.add(name) : c.remove(name);
          var c = node.getAttribute("class") || "";
          if (value) {
            re.lastIndex = 0;
            if (!re.test(c))
              node.setAttribute("class", d3_collapse(c + " " + name));
          } else {
            node.setAttribute("class", d3_collapse(c.replace(re, " ")));
          }
        };
      }
      d3_selectionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2)
              value = "";
            for (priority in name)
              this.each(d3_selection_style(priority, name[priority], value));
            return this;
          }
          if (n < 2) {
            var node = this.node();
            return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
          }
          priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
      };
      function d3_selection_style(name, value, priority) {
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleConstant() {
          this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.style.removeProperty(name);
          else
            this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
      }
      d3_selectionPrototype.property = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string")
            return this.node()[name];
          for (value in name)
            this.each(d3_selection_property(value, name[value]));
          return this;
        }
        return this.each(d3_selection_property(name, value));
      };
      function d3_selection_property(name, value) {
        function propertyNull() {
          delete this[name];
        }
        function propertyConstant() {
          this[name] = value;
        }
        function propertyFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            delete this[name];
          else
            this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
      }
      d3_selectionPrototype.text = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
          var v = value.apply(this, arguments);
          this.textContent = v == null ? "" : v;
        } : value == null ? function() {
          this.textContent = "";
        } : function() {
          this.textContent = value;
        }) : this.node().textContent;
      };
      d3_selectionPrototype.html = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
          var v = value.apply(this, arguments);
          this.innerHTML = v == null ? "" : v;
        } : value == null ? function() {
          this.innerHTML = "";
        } : function() {
          this.innerHTML = value;
        }) : this.node().innerHTML;
      };
      d3_selectionPrototype.append = function(name) {
        name = d3_selection_creator(name);
        return this.select(function() {
          return this.appendChild(name.apply(this, arguments));
        });
      };
      function d3_selection_creator(name) {
        function create() {
          var document = this.ownerDocument,
              namespace = this.namespaceURI;
          return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
        }
        function createNS() {
          return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
      }
      d3_selectionPrototype.insert = function(name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function() {
          return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
      };
      d3_selectionPrototype.remove = function() {
        return this.each(d3_selectionRemove);
      };
      function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent)
          parent.removeChild(this);
      }
      d3_selectionPrototype.data = function(value, key) {
        var i = -1,
            n = this.length,
            group,
            node;
        if (!arguments.length) {
          value = new Array(n = (group = this[0]).length);
          while (++i < n) {
            if (node = group[i]) {
              value[i] = node.__data__;
            }
          }
          return value;
        }
        function bind(group, groupData) {
          var i,
              n = group.length,
              m = groupData.length,
              n0 = Math.min(n, m),
              updateNodes = new Array(m),
              enterNodes = new Array(m),
              exitNodes = new Array(n),
              node,
              nodeData;
          if (key) {
            var nodeByKeyValue = new d3_Map(),
                keyValues = new Array(n),
                keyValue;
            for (i = -1; ++i < n; ) {
              if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
                exitNodes[i] = node;
              } else {
                nodeByKeyValue.set(keyValue, node);
              }
              keyValues[i] = keyValue;
            }
            for (i = -1; ++i < m; ) {
              if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              } else if (node !== true) {
                updateNodes[i] = node;
                node.__data__ = nodeData;
              }
              nodeByKeyValue.set(keyValue, true);
            }
            for (i = -1; ++i < n; ) {
              if (nodeByKeyValue.get(keyValues[i]) !== true) {
                exitNodes[i] = group[i];
              }
            }
          } else {
            for (i = -1; ++i < n0; ) {
              node = group[i];
              nodeData = groupData[i];
              if (node) {
                node.__data__ = nodeData;
                updateNodes[i] = node;
              } else {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              }
            }
            for (; i < m; ++i) {
              enterNodes[i] = d3_selection_dataNode(groupData[i]);
            }
            for (; i < n; ++i) {
              exitNodes[i] = group[i];
            }
          }
          enterNodes.update = updateNodes;
          enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
          enter.push(enterNodes);
          update.push(updateNodes);
          exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]),
            update = d3_selection([]),
            exit = d3_selection([]);
        if (typeof value === "function") {
          while (++i < n) {
            bind(group = this[i], value.call(group, group.parentNode.__data__, i));
          }
        } else {
          while (++i < n) {
            bind(group = this[i], value);
          }
        }
        update.enter = function() {
          return enter;
        };
        update.exit = function() {
          return exit;
        };
        return update;
      };
      function d3_selection_dataNode(data) {
        return {__data__: data};
      }
      d3_selectionPrototype.datum = function(value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
      };
      d3_selectionPrototype.filter = function(filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function")
          filter = d3_selection_filter(filter);
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = 0,
              n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_filter(selector) {
        return function() {
          return d3_selectMatches(this, selector);
        };
      }
      d3_selectionPrototype.order = function() {
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = group.length - 1,
              next = group[i],
              node; --i >= 0; ) {
            if (node = group[i]) {
              if (next && next !== node.nextSibling)
                next.parentNode.insertBefore(node, next);
              next = node;
            }
          }
        }
        return this;
      };
      d3_selectionPrototype.sort = function(comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1,
            m = this.length; ++j < m; )
          this[j].sort(comparator);
        return this.order();
      };
      function d3_selection_sortComparator(comparator) {
        if (!arguments.length)
          comparator = d3_ascending;
        return function(a, b) {
          return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
      }
      d3_selectionPrototype.each = function(callback) {
        return d3_selection_each(this, function(node, i, j) {
          callback.call(node, node.__data__, i, j);
        });
      };
      function d3_selection_each(groups, callback) {
        for (var j = 0,
            m = groups.length; j < m; j++) {
          for (var group = groups[j],
              i = 0,
              n = group.length,
              node; i < n; i++) {
            if (node = group[i])
              callback(node, i, j);
          }
        }
        return groups;
      }
      d3_selectionPrototype.call = function(callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
      };
      d3_selectionPrototype.empty = function() {
        return !this.node();
      };
      d3_selectionPrototype.node = function() {
        for (var j = 0,
            m = this.length; j < m; j++) {
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            var node = group[i];
            if (node)
              return node;
          }
        }
        return null;
      };
      d3_selectionPrototype.size = function() {
        var n = 0;
        d3_selection_each(this, function() {
          ++n;
        });
        return n;
      };
      function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
      }
      var d3_selection_enterPrototype = [];
      d3.selection.enter = d3_selection_enter;
      d3.selection.enter.prototype = d3_selection_enterPrototype;
      d3_selection_enterPrototype.append = d3_selectionPrototype.append;
      d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
      d3_selection_enterPrototype.node = d3_selectionPrototype.node;
      d3_selection_enterPrototype.call = d3_selectionPrototype.call;
      d3_selection_enterPrototype.size = d3_selectionPrototype.size;
      d3_selection_enterPrototype.select = function(selector) {
        var subgroups = [],
            subgroup,
            subnode,
            upgroup,
            group,
            node;
        for (var j = -1,
            m = this.length; ++j < m; ) {
          upgroup = (group = this[j]).update;
          subgroups.push(subgroup = []);
          subgroup.parentNode = group.parentNode;
          for (var i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
              subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      d3_selection_enterPrototype.insert = function(name, before) {
        if (arguments.length < 2)
          before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
      };
      function d3_selection_enterInsertBefore(enter) {
        var i0,
            j0;
        return function(d, i, j) {
          var group = enter[j].update,
              n = group.length,
              node;
          if (j != j0)
            j0 = j, i0 = 0;
          if (i >= i0)
            i0 = i + 1;
          while (!(node = group[i0]) && ++i0 < n)
            ;
          return node;
        };
      }
      d3.select = function(node) {
        var group;
        if (typeof node === "string") {
          group = [d3_select(node, d3_document)];
          group.parentNode = d3_document.documentElement;
        } else {
          group = [node];
          group.parentNode = d3_documentElement(node);
        }
        return d3_selection([group]);
      };
      d3.selectAll = function(nodes) {
        var group;
        if (typeof nodes === "string") {
          group = d3_array(d3_selectAll(nodes, d3_document));
          group.parentNode = d3_document.documentElement;
        } else {
          group = nodes;
          group.parentNode = null;
        }
        return d3_selection([group]);
      };
      d3_selectionPrototype.on = function(type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof type !== "string") {
            if (n < 2)
              listener = false;
            for (capture in type)
              this.each(d3_selection_on(capture, type[capture], listener));
            return this;
          }
          if (n < 2)
            return (n = this.node()["__on" + type]) && n._;
          capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
      };
      function d3_selection_on(type, listener, capture) {
        var name = "__on" + type,
            i = type.indexOf("."),
            wrap = d3_selection_onListener;
        if (i > 0)
          type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter)
          type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
          var l = this[name];
          if (l) {
            this.removeEventListener(type, l, l.$);
            delete this[name];
          }
        }
        function onAdd() {
          var l = wrap(listener, d3_array(arguments));
          onRemove.call(this);
          this.addEventListener(type, this[name] = l, l.$ = capture);
          l._ = listener;
        }
        function removeAll() {
          var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"),
              match;
          for (var name in this) {
            if (match = name.match(re)) {
              var l = this[name];
              this.removeEventListener(match[1], l, l.$);
              delete this[name];
            }
          }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
      }
      var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
      });
      if (d3_document) {
        d3_selection_onFilters.forEach(function(k) {
          if ("on" + k in d3_document)
            d3_selection_onFilters.remove(k);
        });
      }
      function d3_selection_onListener(listener, argumentz) {
        return function(e) {
          var o = d3.event;
          d3.event = e;
          argumentz[0] = this.__data__;
          try {
            listener.apply(this, argumentz);
          } finally {
            d3.event = o;
          }
        };
      }
      function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function(e) {
          var target = this,
              related = e.relatedTarget;
          if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
            l.call(target, e);
          }
        };
      }
      var d3_event_dragSelect,
          d3_event_dragId = 0;
      function d3_event_dragSuppress(node) {
        var name = ".dragsuppress-" + ++d3_event_dragId,
            click = "click" + name,
            w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
          d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
        }
        if (d3_event_dragSelect) {
          var style = d3_documentElement(node).style,
              select = style[d3_event_dragSelect];
          style[d3_event_dragSelect] = "none";
        }
        return function(suppressClick) {
          w.on(name, null);
          if (d3_event_dragSelect)
            style[d3_event_dragSelect] = select;
          if (suppressClick) {
            var off = function() {
              w.on(click, null);
            };
            w.on(click, function() {
              d3_eventPreventDefault();
              off();
            }, true);
            setTimeout(off, 0);
          }
        };
      }
      d3.mouse = function(container) {
        return d3_mousePoint(container, d3_eventSource());
      };
      var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
      function d3_mousePoint(container, e) {
        if (e.changedTouches)
          e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          if (d3_mouse_bug44083 < 0) {
            var window = d3_window(container);
            if (window.scrollX || window.scrollY) {
              svg = d3.select("body").append("svg").style({
                position: "absolute",
                top: 0,
                left: 0,
                margin: 0,
                padding: 0,
                border: "none"
              }, "important");
              var ctm = svg[0][0].getScreenCTM();
              d3_mouse_bug44083 = !(ctm.f || ctm.e);
              svg.remove();
            }
          }
          if (d3_mouse_bug44083)
            point.x = e.pageX, point.y = e.pageY;
          else
            point.x = e.clientX, point.y = e.clientY;
          point = point.matrixTransform(container.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        var rect = container.getBoundingClientRect();
        return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
      }
      d3.touch = function(container, touches, identifier) {
        if (arguments.length < 3)
          identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches)
          for (var i = 0,
              n = touches.length,
              touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
              return d3_mousePoint(container, touch);
            }
          }
      };
      d3.behavior.drag = function() {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"),
            origin = null,
            mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"),
            touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
        function drag() {
          this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
          return function() {
            var that = this,
                target = d3.event.target,
                parent = that.parentNode,
                dispatch = event.of(that, arguments),
                dragged = 0,
                dragId = id(),
                dragName = ".drag" + (dragId == null ? "" : "-" + dragId),
                dragOffset,
                dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended),
                dragRestore = d3_event_dragSuppress(target),
                position0 = position(parent, dragId);
            if (origin) {
              dragOffset = origin.apply(that, arguments);
              dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
            } else {
              dragOffset = [0, 0];
            }
            dispatch({type: "dragstart"});
            function moved() {
              var position1 = position(parent, dragId),
                  dx,
                  dy;
              if (!position1)
                return;
              dx = position1[0] - position0[0];
              dy = position1[1] - position0[1];
              dragged |= dx | dy;
              position0 = position1;
              dispatch({
                type: "drag",
                x: position1[0] + dragOffset[0],
                y: position1[1] + dragOffset[1],
                dx: dx,
                dy: dy
              });
            }
            function ended() {
              if (!position(parent, dragId))
                return;
              dragSubject.on(move + dragName, null).on(end + dragName, null);
              dragRestore(dragged && d3.event.target === target);
              dispatch({type: "dragend"});
            }
          };
        }
        drag.origin = function(x) {
          if (!arguments.length)
            return origin;
          origin = x;
          return drag;
        };
        return d3.rebind(drag, event, "on");
      };
      function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
      }
      d3.touches = function(container, touches) {
        if (arguments.length < 2)
          touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function(touch) {
          var point = d3_mousePoint(container, touch);
          point.identifier = touch.identifier;
          return point;
        }) : [];
      };
      var ε = 1e-6,
          ε2 = ε * ε,
          π = Math.PI,
          τ = 2 * π,
          τε = τ - ε,
          halfπ = π / 2,
          d3_radians = π / 180,
          d3_degrees = 180 / π;
      function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
      }
      function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
      }
      function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
      }
      function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
      }
      function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
      }
      function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
      }
      function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
      }
      function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
      }
      var ρ = Math.SQRT2,
          ρ2 = 2,
          ρ4 = 4;
      d3.interpolateZoom = function(p0, p1) {
        var ux0 = p0[0],
            uy0 = p0[1],
            w0 = p0[2],
            ux1 = p1[0],
            uy1 = p1[1],
            w1 = p1[2];
        var dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            d1 = Math.sqrt(d2),
            b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1),
            b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1),
            r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
            r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1),
            dr = r1 - r0,
            S = (dr || Math.log(w1 / w0)) / ρ;
        function interpolate(t) {
          var s = t * S;
          if (dr) {
            var coshr0 = d3_cosh(r0),
                u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
            return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0)];
          }
          return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s)];
        }
        interpolate.duration = S * 1e3;
        return interpolate;
      };
      d3.behavior.zoom = function() {
        var view = {
          x: 0,
          y: 0,
          k: 1
        },
            translate0,
            center0,
            center,
            size = [960, 500],
            scaleExtent = d3_behavior_zoomInfinity,
            duration = 250,
            zooming = 0,
            mousedown = "mousedown.zoom",
            mousemove = "mousemove.zoom",
            mouseup = "mouseup.zoom",
            mousewheelTimer,
            touchstart = "touchstart.zoom",
            touchtime,
            event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"),
            x0,
            x1,
            y0,
            y1;
        if (!d3_behavior_zoomWheel) {
          d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
            return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
          }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
            return d3.event.wheelDelta;
          }, "mousewheel") : (d3_behavior_zoomDelta = function() {
            return -d3.event.detail;
          }, "MozMousePixelScroll");
        }
        function zoom(g) {
          g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function(g) {
          g.each(function() {
            var dispatch = event.of(this, arguments),
                view1 = view;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.zoom", function() {
                view = this.__chart__ || {
                  x: 0,
                  y: 0,
                  k: 1
                };
                zoomstarted(dispatch);
              }).tween("zoom:zoom", function() {
                var dx = size[0],
                    dy = size[1],
                    cx = center0 ? center0[0] : dx / 2,
                    cy = center0 ? center0[1] : dy / 2,
                    i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                return function(t) {
                  var l = i(t),
                      k = dx / l[2];
                  this.__chart__ = view = {
                    x: cx - l[0] * k,
                    y: cy - l[1] * k,
                    k: k
                  };
                  zoomed(dispatch);
                };
              }).each("interrupt.zoom", function() {
                zoomended(dispatch);
              }).each("end.zoom", function() {
                zoomended(dispatch);
              });
            } else {
              this.__chart__ = view;
              zoomstarted(dispatch);
              zoomed(dispatch);
              zoomended(dispatch);
            }
          });
        };
        zoom.translate = function(_) {
          if (!arguments.length)
            return [view.x, view.y];
          view = {
            x: +_[0],
            y: +_[1],
            k: view.k
          };
          rescale();
          return zoom;
        };
        zoom.scale = function(_) {
          if (!arguments.length)
            return view.k;
          view = {
            x: view.x,
            y: view.y,
            k: +_
          };
          rescale();
          return zoom;
        };
        zoom.scaleExtent = function(_) {
          if (!arguments.length)
            return scaleExtent;
          scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];
          return zoom;
        };
        zoom.center = function(_) {
          if (!arguments.length)
            return center;
          center = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.size = function(_) {
          if (!arguments.length)
            return size;
          size = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.duration = function(_) {
          if (!arguments.length)
            return duration;
          duration = +_;
          return zoom;
        };
        zoom.x = function(z) {
          if (!arguments.length)
            return x1;
          x1 = z;
          x0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        zoom.y = function(z) {
          if (!arguments.length)
            return y1;
          y1 = z;
          y0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        function location(p) {
          return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
        }
        function point(l) {
          return [l[0] * view.k + view.x, l[1] * view.k + view.y];
        }
        function scaleTo(s) {
          view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
          l = point(l);
          view.x += p[0] - l[0];
          view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
          that.__chart__ = {
            x: view.x,
            y: view.y,
            k: view.k
          };
          scaleTo(Math.pow(2, k));
          translateTo(center0 = p, l);
          that = d3.select(that);
          if (duration > 0)
            that = that.transition().duration(duration);
          that.call(zoom.event);
        }
        function rescale() {
          if (x1)
            x1.domain(x0.range().map(function(x) {
              return (x - view.x) / view.k;
            }).map(x0.invert));
          if (y1)
            y1.domain(y0.range().map(function(y) {
              return (y - view.y) / view.k;
            }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
          if (!zooming++)
            dispatch({type: "zoomstart"});
        }
        function zoomed(dispatch) {
          rescale();
          dispatch({
            type: "zoom",
            scale: view.k,
            translate: [view.x, view.y]
          });
        }
        function zoomended(dispatch) {
          if (!--zooming)
            dispatch({type: "zoomend"});
          center0 = null;
        }
        function mousedowned() {
          var that = this,
              target = d3.event.target,
              dispatch = event.of(that, arguments),
              dragged = 0,
              subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended),
              location0 = location(d3.mouse(that)),
              dragRestore = d3_event_dragSuppress(that);
          d3_selection_interrupt.call(that);
          zoomstarted(dispatch);
          function moved() {
            dragged = 1;
            translateTo(d3.mouse(that), location0);
            zoomed(dispatch);
          }
          function ended() {
            subject.on(mousemove, null).on(mouseup, null);
            dragRestore(dragged && d3.event.target === target);
            zoomended(dispatch);
          }
        }
        function touchstarted() {
          var that = this,
              dispatch = event.of(that, arguments),
              locations0 = {},
              distance0 = 0,
              scale0,
              zoomName = ".zoom-" + d3.event.changedTouches[0].identifier,
              touchmove = "touchmove" + zoomName,
              touchend = "touchend" + zoomName,
              targets = [],
              subject = d3.select(that),
              dragRestore = d3_event_dragSuppress(that);
          started();
          zoomstarted(dispatch);
          subject.on(mousedown, null).on(touchstart, started);
          function relocate() {
            var touches = d3.touches(that);
            scale0 = view.k;
            touches.forEach(function(t) {
              if (t.identifier in locations0)
                locations0[t.identifier] = location(t);
            });
            return touches;
          }
          function started() {
            var target = d3.event.target;
            d3.select(target).on(touchmove, moved).on(touchend, ended);
            targets.push(target);
            var changed = d3.event.changedTouches;
            for (var i = 0,
                n = changed.length; i < n; ++i) {
              locations0[changed[i].identifier] = null;
            }
            var touches = relocate(),
                now = Date.now();
            if (touches.length === 1) {
              if (now - touchtime < 500) {
                var p = touches[0];
                zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                d3_eventPreventDefault();
              }
              touchtime = now;
            } else if (touches.length > 1) {
              var p = touches[0],
                  q = touches[1],
                  dx = p[0] - q[0],
                  dy = p[1] - q[1];
              distance0 = dx * dx + dy * dy;
            }
          }
          function moved() {
            var touches = d3.touches(that),
                p0,
                l0,
                p1,
                l1;
            d3_selection_interrupt.call(that);
            for (var i = 0,
                n = touches.length; i < n; ++i, l1 = null) {
              p1 = touches[i];
              if (l1 = locations0[p1.identifier]) {
                if (l0)
                  break;
                p0 = p1, l0 = l1;
              }
            }
            if (l1) {
              var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1,
                  scale1 = distance0 && Math.sqrt(distance1 / distance0);
              p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
              l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
              scaleTo(scale1 * scale0);
            }
            touchtime = null;
            translateTo(p0, l0);
            zoomed(dispatch);
          }
          function ended() {
            if (d3.event.touches.length) {
              var changed = d3.event.changedTouches;
              for (var i = 0,
                  n = changed.length; i < n; ++i) {
                delete locations0[changed[i].identifier];
              }
              for (var identifier in locations0) {
                return void relocate();
              }
            }
            d3.selectAll(targets).on(zoomName, null);
            subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
            dragRestore();
            zoomended(dispatch);
          }
        }
        function mousewheeled() {
          var dispatch = event.of(this, arguments);
          if (mousewheelTimer)
            clearTimeout(mousewheelTimer);
          else
            translate0 = location(center0 = center || d3.mouse(this)), d3_selection_interrupt.call(this), zoomstarted(dispatch);
          mousewheelTimer = setTimeout(function() {
            mousewheelTimer = null;
            zoomended(dispatch);
          }, 50);
          d3_eventPreventDefault();
          scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
          translateTo(center0, translate0);
          zoomed(dispatch);
        }
        function dblclicked() {
          var p = d3.mouse(this),
              k = Math.log(view.k) / Math.LN2;
          zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, "on");
      };
      var d3_behavior_zoomInfinity = [0, Infinity],
          d3_behavior_zoomDelta,
          d3_behavior_zoomWheel;
      d3.color = d3_color;
      function d3_color() {}
      d3_color.prototype.toString = function() {
        return this.rgb() + "";
      };
      d3.hsl = d3_hsl;
      function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void(this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
      }
      var d3_hslPrototype = d3_hsl.prototype = new d3_color();
      d3_hslPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
      };
      d3_hslPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
      };
      d3_hslPrototype.rgb = function() {
        return d3_hsl_rgb(this.h, this.s, this.l);
      };
      function d3_hsl_rgb(h, s, l) {
        var m1,
            m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
          if (h > 360)
            h -= 360;
          else if (h < 0)
            h += 360;
          if (h < 60)
            return m1 + (m2 - m1) * h / 60;
          if (h < 180)
            return m2;
          if (h < 240)
            return m1 + (m2 - m1) * (240 - h) / 60;
          return m1;
        }
        function vv(h) {
          return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
      }
      d3.hcl = d3_hcl;
      function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void(this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
      }
      var d3_hclPrototype = d3_hcl.prototype = new d3_color();
      d3_hclPrototype.brighter = function(k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.darker = function(k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.rgb = function() {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
      };
      function d3_hcl_lab(h, c, l) {
        if (isNaN(h))
          h = 0;
        if (isNaN(c))
          c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
      }
      d3.lab = d3_lab;
      function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void(this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
      }
      var d3_lab_K = 18;
      var d3_lab_X = .95047,
          d3_lab_Y = 1,
          d3_lab_Z = 1.08883;
      var d3_labPrototype = d3_lab.prototype = new d3_color();
      d3_labPrototype.brighter = function(k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.darker = function(k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.rgb = function() {
        return d3_lab_rgb(this.l, this.a, this.b);
      };
      function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116,
            x = y + a / 500,
            z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
      }
      function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
      }
      function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
      }
      function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
      }
      function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
      }
      d3.rgb = d3_rgb;
      function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void(this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
      }
      function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
      }
      function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
      }
      var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
      d3_rgbPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r,
            g = this.g,
            b = this.b,
            i = 30;
        if (!r && !g && !b)
          return new d3_rgb(i, i, i);
        if (r && r < i)
          r = i;
        if (g && g < i)
          g = i;
        if (b && b < i)
          b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
      };
      d3_rgbPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
      };
      d3_rgbPrototype.hsl = function() {
        return d3_rgb_hsl(this.r, this.g, this.b);
      };
      d3_rgbPrototype.toString = function() {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
      };
      function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
      }
      function d3_rgb_parse(format, rgb, hsl) {
        var r = 0,
            g = 0,
            b = 0,
            m1,
            m2,
            color;
        m1 = /([a-z]+)\((.*)\)/i.exec(format);
        if (m1) {
          m2 = m1[2].split(",");
          switch (m1[1]) {
            case "hsl":
              {
                return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
              }
            case "rgb":
              {
                return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
              }
          }
        }
        if (color = d3_rgb_names.get(format.toLowerCase())) {
          return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
          if (format.length === 4) {
            r = (color & 3840) >> 4;
            r = r >> 4 | r;
            g = color & 240;
            g = g >> 4 | g;
            b = color & 15;
            b = b << 4 | b;
          } else if (format.length === 7) {
            r = (color & 16711680) >> 16;
            g = (color & 65280) >> 8;
            b = color & 255;
          }
        }
        return rgb(r, g, b);
      }
      function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255),
            max = Math.max(r, g, b),
            d = max - min,
            h,
            s,
            l = (max + min) / 2;
        if (d) {
          s = l < .5 ? d / (max + min) : d / (2 - max - min);
          if (r == max)
            h = (g - b) / d + (g < b ? 6 : 0);
          else if (g == max)
            h = (b - r) / d + 2;
          else
            h = (r - g) / d + 4;
          h *= 60;
        } else {
          h = NaN;
          s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
      }
      function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X),
            y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y),
            z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
      }
      function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
      }
      function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
      }
      var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      });
      d3_rgb_names.forEach(function(key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
      });
      function d3_functor(v) {
        return typeof v === "function" ? v : function() {
          return v;
        };
      }
      d3.functor = d3_functor;
      d3.xhr = d3_xhrType(d3_identity);
      function d3_xhrType(response) {
        return function(url, mimeType, callback) {
          if (arguments.length === 2 && typeof mimeType === "function")
            callback = mimeType, mimeType = null;
          return d3_xhr(url, mimeType, response, callback);
        };
      }
      function d3_xhr(url, mimeType, response, callback) {
        var xhr = {},
            dispatch = d3.dispatch("beforesend", "progress", "load", "error"),
            headers = {},
            request = new XMLHttpRequest(),
            responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url))
          request = new XDomainRequest();
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
          request.readyState > 3 && respond();
        };
        function respond() {
          var status = request.status,
              result;
          if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
            try {
              result = response.call(xhr, request);
            } catch (e) {
              dispatch.error.call(xhr, e);
              return;
            }
            dispatch.load.call(xhr, result);
          } else {
            dispatch.error.call(xhr, request);
          }
        }
        request.onprogress = function(event) {
          var o = d3.event;
          d3.event = event;
          try {
            dispatch.progress.call(xhr, request);
          } finally {
            d3.event = o;
          }
        };
        xhr.header = function(name, value) {
          name = (name + "").toLowerCase();
          if (arguments.length < 2)
            return headers[name];
          if (value == null)
            delete headers[name];
          else
            headers[name] = value + "";
          return xhr;
        };
        xhr.mimeType = function(value) {
          if (!arguments.length)
            return mimeType;
          mimeType = value == null ? null : value + "";
          return xhr;
        };
        xhr.responseType = function(value) {
          if (!arguments.length)
            return responseType;
          responseType = value;
          return xhr;
        };
        xhr.response = function(value) {
          response = value;
          return xhr;
        };
        ["get", "post"].forEach(function(method) {
          xhr[method] = function() {
            return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
          };
        });
        xhr.send = function(method, data, callback) {
          if (arguments.length === 2 && typeof data === "function")
            callback = data, data = null;
          request.open(method, url, true);
          if (mimeType != null && !("accept" in headers))
            headers["accept"] = mimeType + ",*/*";
          if (request.setRequestHeader)
            for (var name in headers)
              request.setRequestHeader(name, headers[name]);
          if (mimeType != null && request.overrideMimeType)
            request.overrideMimeType(mimeType);
          if (responseType != null)
            request.responseType = responseType;
          if (callback != null)
            xhr.on("error", callback).on("load", function(request) {
              callback(null, request);
            });
          dispatch.beforesend.call(xhr, request);
          request.send(data == null ? null : data);
          return xhr;
        };
        xhr.abort = function() {
          request.abort();
          return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
      }
      function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
          callback(error == null ? request : null);
        } : callback;
      }
      function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
      }
      d3.dsv = function(delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"),
            delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
          if (arguments.length < 3)
            callback = row, row = null;
          var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
          xhr.row = function(_) {
            return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
          };
          return xhr;
        }
        function response(request) {
          return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
          return function(request) {
            return dsv.parse(request.responseText, f);
          };
        }
        dsv.parse = function(text, f) {
          var o;
          return dsv.parseRows(text, function(row, i) {
            if (o)
              return o(row, i - 1);
            var a = new Function("d", "return {" + row.map(function(name, i) {
              return JSON.stringify(name) + ": d[" + i + "]";
            }).join(",") + "}");
            o = f ? function(row, i) {
              return f(a(row), i);
            } : a;
          });
        };
        dsv.parseRows = function(text, f) {
          var EOL = {},
              EOF = {},
              rows = [],
              N = text.length,
              I = 0,
              n = 0,
              t,
              eol;
          function token() {
            if (I >= N)
              return EOF;
            if (eol)
              return eol = false, EOL;
            var j = I;
            if (text.charCodeAt(j) === 34) {
              var i = j;
              while (i++ < N) {
                if (text.charCodeAt(i) === 34) {
                  if (text.charCodeAt(i + 1) !== 34)
                    break;
                  ++i;
                }
              }
              I = i + 2;
              var c = text.charCodeAt(i + 1);
              if (c === 13) {
                eol = true;
                if (text.charCodeAt(i + 2) === 10)
                  ++I;
              } else if (c === 10) {
                eol = true;
              }
              return text.slice(j + 1, i).replace(/""/g, '"');
            }
            while (I < N) {
              var c = text.charCodeAt(I++),
                  k = 1;
              if (c === 10)
                eol = true;
              else if (c === 13) {
                eol = true;
                if (text.charCodeAt(I) === 10)
                  ++I, ++k;
              } else if (c !== delimiterCode)
                continue;
              return text.slice(j, I - k);
            }
            return text.slice(j);
          }
          while ((t = token()) !== EOF) {
            var a = [];
            while (t !== EOL && t !== EOF) {
              a.push(t);
              t = token();
            }
            if (f && (a = f(a, n++)) == null)
              continue;
            rows.push(a);
          }
          return rows;
        };
        dsv.format = function(rows) {
          if (Array.isArray(rows[0]))
            return dsv.formatRows(rows);
          var fieldSet = new d3_Set(),
              fields = [];
          rows.forEach(function(row) {
            for (var field in row) {
              if (!fieldSet.has(field)) {
                fields.push(fieldSet.add(field));
              }
            }
          });
          return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
            return fields.map(function(field) {
              return formatValue(row[field]);
            }).join(delimiter);
          })).join("\n");
        };
        dsv.formatRows = function(rows) {
          return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
          return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
          return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
      };
      d3.csv = d3.dsv(",", "text/csv");
      d3.tsv = d3.dsv("	", "text/tab-separated-values");
      var d3_timer_queueHead,
          d3_timer_queueTail,
          d3_timer_interval,
          d3_timer_timeout,
          d3_timer_active,
          d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
            setTimeout(callback, 17);
          };
      d3.timer = function(callback, delay, then) {
        var n = arguments.length;
        if (n < 2)
          delay = 0;
        if (n < 3)
          then = Date.now();
        var time = then + delay,
            timer = {
              c: callback,
              t: time,
              f: false,
              n: null
            };
        if (d3_timer_queueTail)
          d3_timer_queueTail.n = timer;
        else
          d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
          d3_timer_timeout = clearTimeout(d3_timer_timeout);
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
      };
      function d3_timer_step() {
        var now = d3_timer_mark(),
            delay = d3_timer_sweep() - now;
        if (delay > 24) {
          if (isFinite(delay)) {
            clearTimeout(d3_timer_timeout);
            d3_timer_timeout = setTimeout(d3_timer_step, delay);
          }
          d3_timer_interval = 0;
        } else {
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
      }
      d3.timer.flush = function() {
        d3_timer_mark();
        d3_timer_sweep();
      };
      function d3_timer_mark() {
        var now = Date.now();
        d3_timer_active = d3_timer_queueHead;
        while (d3_timer_active) {
          if (now >= d3_timer_active.t)
            d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
          d3_timer_active = d3_timer_active.n;
        }
        return now;
      }
      function d3_timer_sweep() {
        var t0,
            t1 = d3_timer_queueHead,
            time = Infinity;
        while (t1) {
          if (t1.f) {
            t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
          } else {
            if (t1.t < time)
              time = t1.t;
            t1 = (t0 = t1).n;
          }
        }
        d3_timer_queueTail = t0;
        return time;
      }
      function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
      }
      d3.round = function(x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
      };
      var d3_formatPrefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(d3_formatPrefix);
      d3.formatPrefix = function(value, precision) {
        var i = 0;
        if (value) {
          if (value < 0)
            value *= -1;
          if (precision)
            value = d3.round(value, d3_format_precision(value, precision));
          i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
          i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
      };
      function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
          scale: i > 8 ? function(d) {
            return d / k;
          } : function(d) {
            return d * k;
          },
          symbol: d
        };
      }
      function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal,
            locale_thousands = locale.thousands,
            locale_grouping = locale.grouping,
            locale_currency = locale.currency,
            formatGroup = locale_grouping && locale_thousands ? function(value, width) {
              var i = value.length,
                  t = [],
                  j = 0,
                  g = locale_grouping[0],
                  length = 0;
              while (i > 0 && g > 0) {
                if (length + g + 1 > width)
                  g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width)
                  break;
                g = locale_grouping[j = (j + 1) % locale_grouping.length];
              }
              return t.reverse().join(locale_thousands);
            } : d3_identity;
        return function(specifier) {
          var match = d3_format_re.exec(specifier),
              fill = match[1] || " ",
              align = match[2] || ">",
              sign = match[3] || "-",
              symbol = match[4] || "",
              zfill = match[5],
              width = +match[6],
              comma = match[7],
              precision = match[8],
              type = match[9],
              scale = 1,
              prefix = "",
              suffix = "",
              integer = false,
              exponent = true;
          if (precision)
            precision = +precision.substring(1);
          if (zfill || fill === "0" && align === "=") {
            zfill = fill = "0";
            align = "=";
          }
          switch (type) {
            case "n":
              comma = true;
              type = "g";
              break;
            case "%":
              scale = 100;
              suffix = "%";
              type = "f";
              break;
            case "p":
              scale = 100;
              suffix = "%";
              type = "r";
              break;
            case "b":
            case "o":
            case "x":
            case "X":
              if (symbol === "#")
                prefix = "0" + type.toLowerCase();
            case "c":
              exponent = false;
            case "d":
              integer = true;
              precision = 0;
              break;
            case "s":
              scale = -1;
              type = "r";
              break;
          }
          if (symbol === "$")
            prefix = locale_currency[0], suffix = locale_currency[1];
          if (type == "r" && !precision)
            type = "g";
          if (precision != null) {
            if (type == "g")
              precision = Math.max(1, Math.min(21, precision));
            else if (type == "e" || type == "f")
              precision = Math.max(0, Math.min(20, precision));
          }
          type = d3_format_types.get(type) || d3_format_typeDefault;
          var zcomma = zfill && comma;
          return function(value) {
            var fullSuffix = suffix;
            if (integer && value % 1)
              return "";
            var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
            if (scale < 0) {
              var unit = d3.formatPrefix(value, precision);
              value = unit.scale(value);
              fullSuffix = unit.symbol + suffix;
            } else {
              value *= scale;
            }
            value = type(value, precision);
            var i = value.lastIndexOf("."),
                before,
                after;
            if (i < 0) {
              var j = exponent ? value.lastIndexOf("e") : -1;
              if (j < 0)
                before = value, after = "";
              else
                before = value.substring(0, j), after = value.substring(j);
            } else {
              before = value.substring(0, i);
              after = locale_decimal + value.substring(i + 1);
            }
            if (!zfill && comma)
              before = formatGroup(before, Infinity);
            var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length),
                padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
            if (zcomma)
              before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
            negative += prefix;
            value = before + after;
            return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
          };
        };
      }
      var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
      var d3_format_types = d3.map({
        b: function(x) {
          return x.toString(2);
        },
        c: function(x) {
          return String.fromCharCode(x);
        },
        o: function(x) {
          return x.toString(8);
        },
        x: function(x) {
          return x.toString(16);
        },
        X: function(x) {
          return x.toString(16).toUpperCase();
        },
        g: function(x, p) {
          return x.toPrecision(p);
        },
        e: function(x, p) {
          return x.toExponential(p);
        },
        f: function(x, p) {
          return x.toFixed(p);
        },
        r: function(x, p) {
          return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
      });
      function d3_format_typeDefault(x) {
        return x + "";
      }
      var d3_time = d3.time = {},
          d3_date = Date;
      function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
      }
      d3_date_utc.prototype = {
        getDate: function() {
          return this._.getUTCDate();
        },
        getDay: function() {
          return this._.getUTCDay();
        },
        getFullYear: function() {
          return this._.getUTCFullYear();
        },
        getHours: function() {
          return this._.getUTCHours();
        },
        getMilliseconds: function() {
          return this._.getUTCMilliseconds();
        },
        getMinutes: function() {
          return this._.getUTCMinutes();
        },
        getMonth: function() {
          return this._.getUTCMonth();
        },
        getSeconds: function() {
          return this._.getUTCSeconds();
        },
        getTime: function() {
          return this._.getTime();
        },
        getTimezoneOffset: function() {
          return 0;
        },
        valueOf: function() {
          return this._.valueOf();
        },
        setDate: function() {
          d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function() {
          d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function() {
          d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function() {
          d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function() {
          d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function() {
          d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function() {
          d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function() {
          d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function() {
          d3_time_prototype.setTime.apply(this._, arguments);
        }
      };
      var d3_time_prototype = Date.prototype;
      function d3_time_interval(local, step, number) {
        function round(date) {
          var d0 = local(date),
              d1 = offset(d0, 1);
          return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
          step(date = local(new d3_date(date - 1)), 1);
          return date;
        }
        function offset(date, k) {
          step(date = new d3_date(+date), k);
          return date;
        }
        function range(t0, t1, dt) {
          var time = ceil(t0),
              times = [];
          if (dt > 1) {
            while (time < t1) {
              if (!(number(time) % dt))
                times.push(new Date(+time));
              step(time, 1);
            }
          } else {
            while (time < t1)
              times.push(new Date(+time)), step(time, 1);
          }
          return times;
        }
        function range_utc(t0, t1, dt) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = t0;
            return range(utc, t1, dt);
          } finally {
            d3_date = Date;
          }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
      }
      function d3_time_interval_utc(method) {
        return function(date, k) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = date;
            return method(utc, k)._;
          } finally {
            d3_date = Date;
          }
        };
      }
      d3_time.year = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
      }, function(date, offset) {
        date.setFullYear(date.getFullYear() + offset);
      }, function(date) {
        return date.getFullYear();
      });
      d3_time.years = d3_time.year.range;
      d3_time.years.utc = d3_time.year.utc.range;
      d3_time.day = d3_time_interval(function(date) {
        var day = new d3_date(2e3, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
      }, function(date, offset) {
        date.setDate(date.getDate() + offset);
      }, function(date) {
        return date.getDate() - 1;
      });
      d3_time.days = d3_time.day.range;
      d3_time.days.utc = d3_time.day.utc.range;
      d3_time.dayOfYear = function(date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
      };
      ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function(day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function(date) {
          (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
          return date;
        }, function(date, offset) {
          date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function(date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + "s"] = interval.range;
        d3_time[day + "s"].utc = interval.utc.range;
        d3_time[day + "OfYear"] = function(date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
      });
      d3_time.week = d3_time.sunday;
      d3_time.weeks = d3_time.sunday.range;
      d3_time.weeks.utc = d3_time.sunday.utc.range;
      d3_time.weekOfYear = d3_time.sundayOfYear;
      function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime,
            locale_date = locale.date,
            locale_time = locale.time,
            locale_periods = locale.periods,
            locale_days = locale.days,
            locale_shortDays = locale.shortDays,
            locale_months = locale.months,
            locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
          var n = template.length;
          function format(date) {
            var string = [],
                i = -1,
                j = 0,
                c,
                p,
                f;
            while (++i < n) {
              if (template.charCodeAt(i) === 37) {
                string.push(template.slice(j, i));
                if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null)
                  c = template.charAt(++i);
                if (f = d3_time_formats[c])
                  c = f(date, p == null ? c === "e" ? " " : "0" : p);
                string.push(c);
                j = i + 1;
              }
            }
            string.push(template.slice(j, i));
            return string.join("");
          }
          format.parse = function(string) {
            var d = {
              y: 1900,
              m: 0,
              d: 1,
              H: 0,
              M: 0,
              S: 0,
              L: 0,
              Z: null
            },
                i = d3_time_parse(d, template, string, 0);
            if (i != string.length)
              return null;
            if ("p" in d)
              d.H = d.H % 12 + d.p * 12;
            var localZ = d.Z != null && d3_date !== d3_date_utc,
                date = new (localZ ? d3_date_utc : d3_date)();
            if ("j" in d)
              date.setFullYear(d.y, 0, d.j);
            else if ("w" in d && ("W" in d || "U" in d)) {
              date.setFullYear(d.y, 0, 1);
              date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
            } else
              date.setFullYear(d.y, d.m, d.d);
            date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
            return localZ ? date._ : date;
          };
          format.toString = function() {
            return template;
          };
          return format;
        }
        function d3_time_parse(date, template, string, j) {
          var c,
              p,
              t,
              i = 0,
              n = template.length,
              m = string.length;
          while (i < n) {
            if (j >= m)
              return -1;
            c = template.charCodeAt(i++);
            if (c === 37) {
              t = template.charAt(i++);
              p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
              if (!p || (j = p(date, string, j)) < 0)
                return -1;
            } else if (c != string.charCodeAt(j++)) {
              return -1;
            }
          }
          return j;
        }
        d3_time_format.utc = function(template) {
          var local = d3_time_format(template);
          function format(date) {
            try {
              d3_date = d3_date_utc;
              var utc = new d3_date();
              utc._ = date;
              return local(utc);
            } finally {
              d3_date = Date;
            }
          }
          format.parse = function(string) {
            try {
              d3_date = d3_date_utc;
              var date = local.parse(string);
              return date && date._;
            } finally {
              d3_date = Date;
            }
          };
          format.toString = local.toString;
          return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(),
            d3_time_dayRe = d3_time_formatRe(locale_days),
            d3_time_dayLookup = d3_time_formatLookup(locale_days),
            d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays),
            d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays),
            d3_time_monthRe = d3_time_formatRe(locale_months),
            d3_time_monthLookup = d3_time_formatLookup(locale_months),
            d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths),
            d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function(p, i) {
          d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
          a: function(d) {
            return locale_shortDays[d.getDay()];
          },
          A: function(d) {
            return locale_days[d.getDay()];
          },
          b: function(d) {
            return locale_shortMonths[d.getMonth()];
          },
          B: function(d) {
            return locale_months[d.getMonth()];
          },
          c: d3_time_format(locale_dateTime),
          d: function(d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          e: function(d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          H: function(d, p) {
            return d3_time_formatPad(d.getHours(), p, 2);
          },
          I: function(d, p) {
            return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
          },
          j: function(d, p) {
            return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
          },
          L: function(d, p) {
            return d3_time_formatPad(d.getMilliseconds(), p, 3);
          },
          m: function(d, p) {
            return d3_time_formatPad(d.getMonth() + 1, p, 2);
          },
          M: function(d, p) {
            return d3_time_formatPad(d.getMinutes(), p, 2);
          },
          p: function(d) {
            return locale_periods[+(d.getHours() >= 12)];
          },
          S: function(d, p) {
            return d3_time_formatPad(d.getSeconds(), p, 2);
          },
          U: function(d, p) {
            return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
          },
          w: function(d) {
            return d.getDay();
          },
          W: function(d, p) {
            return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
          },
          x: d3_time_format(locale_date),
          X: d3_time_format(locale_time),
          y: function(d, p) {
            return d3_time_formatPad(d.getFullYear() % 100, p, 2);
          },
          Y: function(d, p) {
            return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
          },
          Z: d3_time_zone,
          "%": function() {
            return "%";
          }
        };
        var d3_time_parsers = {
          a: d3_time_parseWeekdayAbbrev,
          A: d3_time_parseWeekday,
          b: d3_time_parseMonthAbbrev,
          B: d3_time_parseMonth,
          c: d3_time_parseLocaleFull,
          d: d3_time_parseDay,
          e: d3_time_parseDay,
          H: d3_time_parseHour24,
          I: d3_time_parseHour24,
          j: d3_time_parseDayOfYear,
          L: d3_time_parseMilliseconds,
          m: d3_time_parseMonthNumber,
          M: d3_time_parseMinutes,
          p: d3_time_parseAmPm,
          S: d3_time_parseSeconds,
          U: d3_time_parseWeekNumberSunday,
          w: d3_time_parseWeekdayNumber,
          W: d3_time_parseWeekNumberMonday,
          x: d3_time_parseLocaleDate,
          X: d3_time_parseLocaleTime,
          y: d3_time_parseYear,
          Y: d3_time_parseFullYear,
          Z: d3_time_parseZone,
          "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
          d3_time_dayAbbrevRe.lastIndex = 0;
          var n = d3_time_dayAbbrevRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
          d3_time_dayRe.lastIndex = 0;
          var n = d3_time_dayRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
          d3_time_monthAbbrevRe.lastIndex = 0;
          var n = d3_time_monthAbbrevRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
          d3_time_monthRe.lastIndex = 0;
          var n = d3_time_monthRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
          return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
          return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
          return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
          var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
          return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
      }
      var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
      },
          d3_time_numberRe = /^\s*\d+/,
          d3_time_percentRe = /^%/;
      function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : "",
            string = (sign ? -value : value) + "",
            length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
      }
      function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
      }
      function d3_time_formatLookup(names) {
        var map = new d3_Map(),
            i = -1,
            n = names.length;
        while (++i < n)
          map.set(names[i].toLowerCase(), i);
        return map;
      }
      function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
      }
      function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1;
      }
      function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
      }
      function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
      }
      function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
      }
      function d3_time_zone(d) {
        var z = d.getTimezoneOffset(),
            zs = z > 0 ? "-" : "+",
            zh = abs(z) / 60 | 0,
            zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
      }
      function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
      }
      function d3_time_formatMulti(formats) {
        var n = formats.length,
            i = -1;
        while (++i < n)
          formats[i][0] = this(formats[i][0]);
        return function(date) {
          var i = 0,
              f = formats[i];
          while (!f[1](date))
            f = formats[++i];
          return f[0](date);
        };
      }
      d3.locale = function(locale) {
        return {
          numberFormat: d3_locale_numberFormat(locale),
          timeFormat: d3_locale_timeFormat(locale)
        };
      };
      var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
      });
      d3.format = d3_locale_enUS.numberFormat;
      d3.geo = {};
      function d3_adder() {}
      d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function(y) {
          d3_adderSum(y, this.t, d3_adderTemp);
          d3_adderSum(d3_adderTemp.s, this.s, this);
          if (this.s)
            this.t += d3_adderTemp.t;
          else
            this.s = d3_adderTemp.t;
        },
        reset: function() {
          this.s = this.t = 0;
        },
        valueOf: function() {
          return this.s;
        }
      };
      var d3_adderTemp = new d3_adder();
      function d3_adderSum(a, b, o) {
        var x = o.s = a + b,
            bv = x - a,
            av = x - bv;
        o.t = a - av + (b - bv);
      }
      d3.geo.stream = function(object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
          d3_geo_streamObjectType[object.type](object, listener);
        } else {
          d3_geo_streamGeometry(object, listener);
        }
      };
      function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
          d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
      }
      var d3_geo_streamObjectType = {
        Feature: function(feature, listener) {
          d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function(object, listener) {
          var features = object.features,
              i = -1,
              n = features.length;
          while (++i < n)
            d3_geo_streamGeometry(features[i].geometry, listener);
        }
      };
      var d3_geo_streamGeometryType = {
        Sphere: function(object, listener) {
          listener.sphere();
        },
        Point: function(object, listener) {
          object = object.coordinates;
          listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function(object, listener) {
          d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function(object, listener) {
          d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function(object, listener) {
          var geometries = object.geometries,
              i = -1,
              n = geometries.length;
          while (++i < n)
            d3_geo_streamGeometry(geometries[i], listener);
        }
      };
      function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1,
            n = coordinates.length - closed,
            coordinate;
        listener.lineStart();
        while (++i < n)
          coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
      }
      function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1,
            n = coordinates.length;
        listener.polygonStart();
        while (++i < n)
          d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
      }
      d3.geo.area = function(object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
      };
      var d3_geo_areaSum,
          d3_geo_areaRingSum = new d3_adder();
      var d3_geo_area = {
        sphere: function() {
          d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
          d3_geo_areaRingSum.reset();
          d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function() {
          var area = 2 * d3_geo_areaRingSum;
          d3_geo_areaSum += area < 0 ? 4 * π + area : area;
          d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
      };
      function d3_geo_areaRingStart() {
        var λ00,
            φ00,
            λ0,
            cosφ0,
            sinφ0;
        d3_geo_area.point = function(λ, φ) {
          d3_geo_area.point = nextPoint;
          λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          φ = φ * d3_radians / 2 + π / 4;
          var dλ = λ - λ0,
              sdλ = dλ >= 0 ? 1 : -1,
              adλ = sdλ * dλ,
              cosφ = Math.cos(φ),
              sinφ = Math.sin(φ),
              k = sinφ0 * sinφ,
              u = cosφ0 * cosφ + k * Math.cos(adλ),
              v = k * sdλ * Math.sin(adλ);
          d3_geo_areaRingSum.add(Math.atan2(v, u));
          λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function() {
          nextPoint(λ00, φ00);
        };
      }
      function d3_geo_cartesian(spherical) {
        var λ = spherical[0],
            φ = spherical[1],
            cosφ = Math.cos(φ);
        return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];
      }
      function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }
      function d3_geo_cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }
      function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
      }
      function d3_geo_cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
      }
      function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
      }
      function d3_geo_spherical(cartesian) {
        return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])];
      }
      function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
      }
      d3.geo.bounds = function() {
        var λ0,
            φ0,
            λ1,
            φ1,
            λ_,
            λ__,
            φ__,
            p0,
            dλSum,
            ranges,
            range;
        var bound = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            bound.point = ringPoint;
            bound.lineStart = ringStart;
            bound.lineEnd = ringEnd;
            dλSum = 0;
            d3_geo_area.polygonStart();
          },
          polygonEnd: function() {
            d3_geo_area.polygonEnd();
            bound.point = point;
            bound.lineStart = lineStart;
            bound.lineEnd = lineEnd;
            if (d3_geo_areaRingSum < 0)
              λ0 = -(λ1 = 180), φ0 = -(φ1 = 90);
            else if (dλSum > ε)
              φ1 = 90;
            else if (dλSum < -ε)
              φ0 = -90;
            range[0] = λ0, range[1] = λ1;
          }
        };
        function point(λ, φ) {
          ranges.push(range = [λ0 = λ, λ1 = λ]);
          if (φ < φ0)
            φ0 = φ;
          if (φ > φ1)
            φ1 = φ;
        }
        function linePoint(λ, φ) {
          var p = d3_geo_cartesian([λ * d3_radians, φ * d3_radians]);
          if (p0) {
            var normal = d3_geo_cartesianCross(p0, p),
                equatorial = [normal[1], -normal[0], 0],
                inflection = d3_geo_cartesianCross(equatorial, normal);
            d3_geo_cartesianNormalize(inflection);
            inflection = d3_geo_spherical(inflection);
            var dλ = λ - λ_,
                s = dλ > 0 ? 1 : -1,
                λi = inflection[0] * d3_degrees * s,
                antimeridian = abs(dλ) > 180;
            if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = inflection[1] * d3_degrees;
              if (φi > φ1)
                φ1 = φi;
            } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = -inflection[1] * d3_degrees;
              if (φi < φ0)
                φ0 = φi;
            } else {
              if (φ < φ0)
                φ0 = φ;
              if (φ > φ1)
                φ1 = φ;
            }
            if (antimeridian) {
              if (λ < λ_) {
                if (angle(λ0, λ) > angle(λ0, λ1))
                  λ1 = λ;
              } else {
                if (angle(λ, λ1) > angle(λ0, λ1))
                  λ0 = λ;
              }
            } else {
              if (λ1 >= λ0) {
                if (λ < λ0)
                  λ0 = λ;
                if (λ > λ1)
                  λ1 = λ;
              } else {
                if (λ > λ_) {
                  if (angle(λ0, λ) > angle(λ0, λ1))
                    λ1 = λ;
                } else {
                  if (angle(λ, λ1) > angle(λ0, λ1))
                    λ0 = λ;
                }
              }
            }
          } else {
            point(λ, φ);
          }
          p0 = p, λ_ = λ;
        }
        function lineStart() {
          bound.point = linePoint;
        }
        function lineEnd() {
          range[0] = λ0, range[1] = λ1;
          bound.point = point;
          p0 = null;
        }
        function ringPoint(λ, φ) {
          if (p0) {
            var dλ = λ - λ_;
            dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
          } else
            λ__ = λ, φ__ = φ;
          d3_geo_area.point(λ, φ);
          linePoint(λ, φ);
        }
        function ringStart() {
          d3_geo_area.lineStart();
        }
        function ringEnd() {
          ringPoint(λ__, φ__);
          d3_geo_area.lineEnd();
          if (abs(dλSum) > ε)
            λ0 = -(λ1 = 180);
          range[0] = λ0, range[1] = λ1;
          p0 = null;
        }
        function angle(λ0, λ1) {
          return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
          return a[0] - b[0];
        }
        function withinRange(x, range) {
          return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function(feature) {
          φ1 = λ1 = -(λ0 = φ0 = Infinity);
          ranges = [];
          d3.geo.stream(feature, bound);
          var n = ranges.length;
          if (n) {
            ranges.sort(compareRanges);
            for (var i = 1,
                a = ranges[0],
                b,
                merged = [a]; i < n; ++i) {
              b = ranges[i];
              if (withinRange(b[0], a) || withinRange(b[1], a)) {
                if (angle(a[0], b[1]) > angle(a[0], a[1]))
                  a[1] = b[1];
                if (angle(b[0], a[1]) > angle(a[0], a[1]))
                  a[0] = b[0];
              } else {
                merged.push(a = b);
              }
            }
            var best = -Infinity,
                dλ;
            for (var n = merged.length - 1,
                i = 0,
                a = merged[n],
                b; i <= n; a = b, ++i) {
              b = merged[i];
              if ((dλ = angle(a[1], b[0])) > best)
                best = dλ, λ0 = b[0], λ1 = a[1];
            }
          }
          ranges = range = null;
          return λ0 === Infinity || φ0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[λ0, φ0], [λ1, φ1]];
        };
      }();
      d3.geo.centroid = function(object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2,
            y = d3_geo_centroidY2,
            z = d3_geo_centroidZ2,
            m = x * x + y * y + z * z;
        if (m < ε2) {
          x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
          if (d3_geo_centroidW1 < ε)
            x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
          m = x * x + y * y + z * z;
          if (m < ε2)
            return [NaN, NaN];
        }
        return [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees];
      };
      var d3_geo_centroidW0,
          d3_geo_centroidW1,
          d3_geo_centroidX0,
          d3_geo_centroidY0,
          d3_geo_centroidZ0,
          d3_geo_centroidX1,
          d3_geo_centroidY1,
          d3_geo_centroidZ1,
          d3_geo_centroidX2,
          d3_geo_centroidY2,
          d3_geo_centroidZ2;
      var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function() {
          d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function() {
          d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
      };
      function d3_geo_centroidPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
      }
      function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
      }
      function d3_geo_centroidLineStart() {
        var x0,
            y0,
            z0;
        d3_geo_centroid.point = function(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroid.point = nextPoint;
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
      }
      function d3_geo_centroidRingStart() {
        var λ00,
            φ00,
            x0,
            y0,
            z0;
        d3_geo_centroid.point = function(λ, φ) {
          λ00 = λ, φ00 = φ;
          d3_geo_centroid.point = nextPoint;
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function() {
          nextPoint(λ00, φ00);
          d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
          d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              cx = y0 * z - z0 * y,
              cy = z0 * x - x0 * z,
              cz = x0 * y - y0 * x,
              m = Math.sqrt(cx * cx + cy * cy + cz * cz),
              u = x0 * x + y0 * y + z0 * z,
              v = m && -d3_acos(u) / m,
              w = Math.atan2(m, u);
          d3_geo_centroidX2 += v * cx;
          d3_geo_centroidY2 += v * cy;
          d3_geo_centroidZ2 += v * cz;
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_compose(a, b) {
        function compose(x, y) {
          return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert)
          compose.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
          };
        return compose;
      }
      function d3_true() {
        return true;
      }
      function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [],
            clip = [];
        segments.forEach(function(segment) {
          if ((n = segment.length - 1) <= 0)
            return;
          var n,
              p0 = segment[0],
              p1 = segment[n];
          if (d3_geo_sphericalEqual(p0, p1)) {
            listener.lineStart();
            for (var i = 0; i < n; ++i)
              listener.point((p0 = segment[i])[0], p0[1]);
            listener.lineEnd();
            return;
          }
          var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true),
              b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
          a.o = b;
          subject.push(a);
          clip.push(b);
          a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
          b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
          a.o = b;
          subject.push(a);
          clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length)
          return;
        for (var i = 0,
            entry = clipStartInside,
            n = clip.length; i < n; ++i) {
          clip[i].e = entry = !entry;
        }
        var start = subject[0],
            points,
            point;
        while (1) {
          var current = start,
              isSubject = true;
          while (current.v)
            if ((current = current.n) === start)
              return;
          points = current.z;
          listener.lineStart();
          do {
            current.v = current.o.v = true;
            if (current.e) {
              if (isSubject) {
                for (var i = 0,
                    n = points.length; i < n; ++i)
                  listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.n.x, 1, listener);
              }
              current = current.n;
            } else {
              if (isSubject) {
                points = current.p.z;
                for (var i = points.length - 1; i >= 0; --i)
                  listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.p.x, -1, listener);
              }
              current = current.p;
            }
            current = current.o;
            points = current.z;
            isSubject = !isSubject;
          } while (!current.v);
          listener.lineEnd();
        }
      }
      function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length))
          return;
        var n,
            i = 0,
            a = array[0],
            b;
        while (++i < n) {
          a.n = b = array[i];
          b.p = a;
          a = b;
        }
        a.n = b = array[0];
        b.p = a;
      }
      function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
      }
      function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function(rotate, listener) {
          var line = clipLine(listener),
              rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              clip.point = pointRing;
              clip.lineStart = ringStart;
              clip.lineEnd = ringEnd;
              segments = [];
              polygon = [];
            },
            polygonEnd: function() {
              clip.point = point;
              clip.lineStart = lineStart;
              clip.lineEnd = lineEnd;
              segments = d3.merge(segments);
              var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
              if (segments.length) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
              } else if (clipStartInside) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                interpolate(null, null, 1, listener);
                listener.lineEnd();
              }
              if (polygonStarted)
                listener.polygonEnd(), polygonStarted = false;
              segments = polygon = null;
            },
            sphere: function() {
              listener.polygonStart();
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
              listener.polygonEnd();
            }
          };
          function point(λ, φ) {
            var point = rotate(λ, φ);
            if (pointVisible(λ = point[0], φ = point[1]))
              listener.point(λ, φ);
          }
          function pointLine(λ, φ) {
            var point = rotate(λ, φ);
            line.point(point[0], point[1]);
          }
          function lineStart() {
            clip.point = pointLine;
            line.lineStart();
          }
          function lineEnd() {
            clip.point = point;
            line.lineEnd();
          }
          var segments;
          var buffer = d3_geo_clipBufferListener(),
              ringListener = clipLine(buffer),
              polygonStarted = false,
              polygon,
              ring;
          function pointRing(λ, φ) {
            ring.push([λ, φ]);
            var point = rotate(λ, φ);
            ringListener.point(point[0], point[1]);
          }
          function ringStart() {
            ringListener.lineStart();
            ring = [];
          }
          function ringEnd() {
            pointRing(ring[0][0], ring[0][1]);
            ringListener.lineEnd();
            var clean = ringListener.clean(),
                ringSegments = buffer.buffer(),
                segment,
                n = ringSegments.length;
            ring.pop();
            polygon.push(ring);
            ring = null;
            if (!n)
              return;
            if (clean & 1) {
              segment = ringSegments[0];
              var n = segment.length - 1,
                  i = -1,
                  point;
              if (n > 0) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                while (++i < n)
                  listener.point((point = segment[i])[0], point[1]);
                listener.lineEnd();
              }
              return;
            }
            if (n > 1 && clean & 2)
              ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
            segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
          }
          return clip;
        };
      }
      function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
      }
      function d3_geo_clipBufferListener() {
        var lines = [],
            line;
        return {
          lineStart: function() {
            lines.push(line = []);
          },
          point: function(λ, φ) {
            line.push([λ, φ]);
          },
          lineEnd: d3_noop,
          buffer: function() {
            var buffer = lines;
            lines = [];
            line = null;
            return buffer;
          },
          rejoin: function() {
            if (lines.length > 1)
              lines.push(lines.pop().concat(lines.shift()));
          }
        };
      }
      function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
      }
      var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-π, -π / 2]);
      function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN,
            φ0 = NaN,
            sλ0 = NaN,
            clean;
        return {
          lineStart: function() {
            listener.lineStart();
            clean = 1;
          },
          point: function(λ1, φ1) {
            var sλ1 = λ1 > 0 ? π : -π,
                dλ = abs(λ1 - λ0);
            if (abs(dλ - π) < ε) {
              listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              listener.point(λ1, φ0);
              clean = 0;
            } else if (sλ0 !== sλ1 && dλ >= π) {
              if (abs(λ0 - sλ0) < ε)
                λ0 -= sλ0 * ε;
              if (abs(λ1 - sλ1) < ε)
                λ1 -= sλ1 * ε;
              φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              clean = 0;
            }
            listener.point(λ0 = λ1, φ0 = φ1);
            sλ0 = sλ1;
          },
          lineEnd: function() {
            listener.lineEnd();
            λ0 = φ0 = NaN;
          },
          clean: function() {
            return 2 - clean;
          }
        };
      }
      function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0,
            cosφ1,
            sinλ0_λ1 = Math.sin(λ0 - λ1);
        return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
      }
      function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
          φ = direction * halfπ;
          listener.point(-π, φ);
          listener.point(0, φ);
          listener.point(π, φ);
          listener.point(π, 0);
          listener.point(π, -φ);
          listener.point(0, -φ);
          listener.point(-π, -φ);
          listener.point(-π, 0);
          listener.point(-π, φ);
        } else if (abs(from[0] - to[0]) > ε) {
          var s = from[0] < to[0] ? π : -π;
          φ = direction * s / 2;
          listener.point(-s, φ);
          listener.point(0, φ);
          listener.point(s, φ);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0],
            parallel = point[1],
            meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0],
            polarAngle = 0,
            winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0,
            n = polygon.length; i < n; ++i) {
          var ring = polygon[i],
              m = ring.length;
          if (!m)
            continue;
          var point0 = ring[0],
              λ0 = point0[0],
              φ0 = point0[1] / 2 + π / 4,
              sinφ0 = Math.sin(φ0),
              cosφ0 = Math.cos(φ0),
              j = 1;
          while (true) {
            if (j === m)
              j = 0;
            point = ring[j];
            var λ = point[0],
                φ = point[1] / 2 + π / 4,
                sinφ = Math.sin(φ),
                cosφ = Math.cos(φ),
                dλ = λ - λ0,
                sdλ = dλ >= 0 ? 1 : -1,
                adλ = sdλ * dλ,
                antimeridian = adλ > π,
                k = sinφ0 * sinφ;
            d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
            polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
            if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
              var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
              d3_geo_cartesianNormalize(arc);
              var intersection = d3_geo_cartesianCross(meridianNormal, arc);
              d3_geo_cartesianNormalize(intersection);
              var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
              if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                winding += antimeridian ^ dλ >= 0 ? 1 : -1;
              }
            }
            if (!j++)
              break;
            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
          }
        }
        return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
      }
      function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius),
            smallRadius = cr > 0,
            notHemisphere = abs(cr) > ε,
            interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-π, radius - π]);
        function visible(λ, φ) {
          return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
          var point0,
              c0,
              v0,
              v00,
              clean;
          return {
            lineStart: function() {
              v00 = v0 = false;
              clean = 1;
            },
            point: function(λ, φ) {
              var point1 = [λ, φ],
                  point2,
                  v = visible(λ, φ),
                  c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
              if (!point0 && (v00 = v0 = v))
                listener.lineStart();
              if (v !== v0) {
                point2 = intersect(point0, point1);
                if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                  point1[0] += ε;
                  point1[1] += ε;
                  v = visible(point1[0], point1[1]);
                }
              }
              if (v !== v0) {
                clean = 0;
                if (v) {
                  listener.lineStart();
                  point2 = intersect(point1, point0);
                  listener.point(point2[0], point2[1]);
                } else {
                  point2 = intersect(point0, point1);
                  listener.point(point2[0], point2[1]);
                  listener.lineEnd();
                }
                point0 = point2;
              } else if (notHemisphere && point0 && smallRadius ^ v) {
                var t;
                if (!(c & c0) && (t = intersect(point1, point0, true))) {
                  clean = 0;
                  if (smallRadius) {
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                  } else {
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                  }
                }
              }
              if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                listener.point(point1[0], point1[1]);
              }
              point0 = point1, v0 = v, c0 = c;
            },
            lineEnd: function() {
              if (v0)
                listener.lineEnd();
              point0 = null;
            },
            clean: function() {
              return clean | (v00 && v0) << 1;
            }
          };
        }
        function intersect(a, b, two) {
          var pa = d3_geo_cartesian(a),
              pb = d3_geo_cartesian(b);
          var n1 = [1, 0, 0],
              n2 = d3_geo_cartesianCross(pa, pb),
              n2n2 = d3_geo_cartesianDot(n2, n2),
              n1n2 = n2[0],
              determinant = n2n2 - n1n2 * n1n2;
          if (!determinant)
            return !two && a;
          var c1 = cr * n2n2 / determinant,
              c2 = -cr * n1n2 / determinant,
              n1xn2 = d3_geo_cartesianCross(n1, n2),
              A = d3_geo_cartesianScale(n1, c1),
              B = d3_geo_cartesianScale(n2, c2);
          d3_geo_cartesianAdd(A, B);
          var u = n1xn2,
              w = d3_geo_cartesianDot(A, u),
              uu = d3_geo_cartesianDot(u, u),
              t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
          if (t2 < 0)
            return;
          var t = Math.sqrt(t2),
              q = d3_geo_cartesianScale(u, (-w - t) / uu);
          d3_geo_cartesianAdd(q, A);
          q = d3_geo_spherical(q);
          if (!two)
            return q;
          var λ0 = a[0],
              λ1 = b[0],
              φ0 = a[1],
              φ1 = b[1],
              z;
          if (λ1 < λ0)
            z = λ0, λ0 = λ1, λ1 = z;
          var δλ = λ1 - λ0,
              polar = abs(δλ - π) < ε,
              meridian = polar || δλ < ε;
          if (!polar && φ1 < φ0)
            z = φ0, φ0 = φ1, φ1 = z;
          if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
            var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
            d3_geo_cartesianAdd(q1, A);
            return [q, d3_geo_spherical(q1)];
          }
        }
        function code(λ, φ) {
          var r = smallRadius ? radius : π - radius,
              code = 0;
          if (λ < -r)
            code |= 1;
          else if (λ > r)
            code |= 2;
          if (φ < -r)
            code |= 4;
          else if (φ > r)
            code |= 8;
          return code;
        }
      }
      function d3_geom_clipLine(x0, y0, x1, y1) {
        return function(line) {
          var a = line.a,
              b = line.b,
              ax = a.x,
              ay = a.y,
              bx = b.x,
              by = b.y,
              t0 = 0,
              t1 = 1,
              dx = bx - ax,
              dy = by - ay,
              r;
          r = x0 - ax;
          if (!dx && r > 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dx > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = x1 - ax;
          if (!dx && r < 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dx > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          r = y0 - ay;
          if (!dy && r > 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dy > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = y1 - ay;
          if (!dy && r < 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dy > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          if (t0 > 0)
            line.a = {
              x: ax + t0 * dx,
              y: ay + t0 * dy
            };
          if (t1 < 1)
            line.b = {
              x: ax + t1 * dx,
              y: ay + t1 * dy
            };
          return line;
        };
      }
      var d3_geo_clipExtentMAX = 1e9;
      d3.geo.clipExtent = function() {
        var x0,
            y0,
            x1,
            y1,
            stream,
            clip,
            clipExtent = {
              stream: function(output) {
                if (stream)
                  stream.valid = false;
                stream = clip(output);
                stream.valid = true;
                return stream;
              },
              extent: function(_) {
                if (!arguments.length)
                  return [[x0, y0], [x1, y1]];
                clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                if (stream)
                  stream.valid = false, stream = null;
                return clipExtent;
              }
            };
        return clipExtent.extent([[0, 0], [960, 500]]);
      };
      function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function(listener) {
          var listener_ = listener,
              bufferListener = d3_geo_clipBufferListener(),
              clipLine = d3_geom_clipLine(x0, y0, x1, y1),
              segments,
              polygon,
              ring;
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              listener = bufferListener;
              segments = [];
              polygon = [];
              clean = true;
            },
            polygonEnd: function() {
              listener = listener_;
              segments = d3.merge(segments);
              var clipStartInside = insidePolygon([x0, y1]),
                  inside = clean && clipStartInside,
                  visible = segments.length;
              if (inside || visible) {
                listener.polygonStart();
                if (inside) {
                  listener.lineStart();
                  interpolate(null, null, 1, listener);
                  listener.lineEnd();
                }
                if (visible) {
                  d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                }
                listener.polygonEnd();
              }
              segments = polygon = ring = null;
            }
          };
          function insidePolygon(p) {
            var wn = 0,
                n = polygon.length,
                y = p[1];
            for (var i = 0; i < n; ++i) {
              for (var j = 1,
                  v = polygon[i],
                  m = v.length,
                  a = v[0],
                  b; j < m; ++j) {
                b = v[j];
                if (a[1] <= y) {
                  if (b[1] > y && d3_cross2d(a, b, p) > 0)
                    ++wn;
                } else {
                  if (b[1] <= y && d3_cross2d(a, b, p) < 0)
                    --wn;
                }
                a = b;
              }
            }
            return wn !== 0;
          }
          function interpolate(from, to, direction, listener) {
            var a = 0,
                a1 = 0;
            if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
              do {
                listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
              } while ((a = (a + direction + 4) % 4) !== a1);
            } else {
              listener.point(to[0], to[1]);
            }
          }
          function pointVisible(x, y) {
            return x0 <= x && x <= x1 && y0 <= y && y <= y1;
          }
          function point(x, y) {
            if (pointVisible(x, y))
              listener.point(x, y);
          }
          var x__,
              y__,
              v__,
              x_,
              y_,
              v_,
              first,
              clean;
          function lineStart() {
            clip.point = linePoint;
            if (polygon)
              polygon.push(ring = []);
            first = true;
            v_ = false;
            x_ = y_ = NaN;
          }
          function lineEnd() {
            if (segments) {
              linePoint(x__, y__);
              if (v__ && v_)
                bufferListener.rejoin();
              segments.push(bufferListener.buffer());
            }
            clip.point = point;
            if (v_)
              listener.lineEnd();
          }
          function linePoint(x, y) {
            x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
            y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
            var v = pointVisible(x, y);
            if (polygon)
              ring.push([x, y]);
            if (first) {
              x__ = x, y__ = y, v__ = v;
              first = false;
              if (v) {
                listener.lineStart();
                listener.point(x, y);
              }
            } else {
              if (v && v_)
                listener.point(x, y);
              else {
                var l = {
                  a: {
                    x: x_,
                    y: y_
                  },
                  b: {
                    x: x,
                    y: y
                  }
                };
                if (clipLine(l)) {
                  if (!v_) {
                    listener.lineStart();
                    listener.point(l.a.x, l.a.y);
                  }
                  listener.point(l.b.x, l.b.y);
                  if (!v)
                    listener.lineEnd();
                  clean = false;
                } else if (v) {
                  listener.lineStart();
                  listener.point(x, y);
                  clean = false;
                }
              }
            }
            x_ = x, y_ = y, v_ = v;
          }
          return clip;
        };
        function corner(p, direction) {
          return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
          return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
          var ca = corner(a, 1),
              cb = corner(b, 1);
          return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
      }
      function d3_geo_conic(projectAt) {
        var φ0 = 0,
            φ1 = π / 3,
            m = d3_geo_projectionMutator(projectAt),
            p = m(φ0, φ1);
        p.parallels = function(_) {
          if (!arguments.length)
            return [φ0 / π * 180, φ1 / π * 180];
          return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        };
        return p;
      }
      function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0),
            n = (sinφ0 + Math.sin(φ1)) / 2,
            C = 1 + sinφ0 * (2 * n - sinφ0),
            ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
          var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
          return [ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = ρ0 - y;
          return [Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))];
        };
        return forward;
      }
      (d3.geo.conicEqualArea = function() {
        return d3_geo_conic(d3_geo_conicEqualArea);
      }).raw = d3_geo_conicEqualArea;
      d3.geo.albers = function() {
        return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070);
      };
      d3.geo.albersUsa = function() {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]);
        var hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]);
        var point,
            pointStream = {point: function(x, y) {
                point = [x, y];
              }},
            lower48Point,
            alaskaPoint,
            hawaiiPoint;
        function albersUsa(coordinates) {
          var x = coordinates[0],
              y = coordinates[1];
          point = null;
          (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
          return point;
        }
        albersUsa.invert = function(coordinates) {
          var k = lower48.scale(),
              t = lower48.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k;
          return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function(stream) {
          var lower48Stream = lower48.stream(stream),
              alaskaStream = alaska.stream(stream),
              hawaiiStream = hawaii.stream(stream);
          return {
            point: function(x, y) {
              lower48Stream.point(x, y);
              alaskaStream.point(x, y);
              hawaiiStream.point(x, y);
            },
            sphere: function() {
              lower48Stream.sphere();
              alaskaStream.sphere();
              hawaiiStream.sphere();
            },
            lineStart: function() {
              lower48Stream.lineStart();
              alaskaStream.lineStart();
              hawaiiStream.lineStart();
            },
            lineEnd: function() {
              lower48Stream.lineEnd();
              alaskaStream.lineEnd();
              hawaiiStream.lineEnd();
            },
            polygonStart: function() {
              lower48Stream.polygonStart();
              alaskaStream.polygonStart();
              hawaiiStream.polygonStart();
            },
            polygonEnd: function() {
              lower48Stream.polygonEnd();
              alaskaStream.polygonEnd();
              hawaiiStream.polygonEnd();
            }
          };
        };
        albersUsa.precision = function(_) {
          if (!arguments.length)
            return lower48.precision();
          lower48.precision(_);
          alaska.precision(_);
          hawaii.precision(_);
          return albersUsa;
        };
        albersUsa.scale = function(_) {
          if (!arguments.length)
            return lower48.scale();
          lower48.scale(_);
          alaska.scale(_ * .35);
          hawaii.scale(_);
          return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function(_) {
          if (!arguments.length)
            return lower48.translate();
          var k = lower48.scale(),
              x = +_[0],
              y = +_[1];
          lower48Point = lower48.translate(_).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(pointStream).point;
          alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + ε, y + .12 * k + ε], [x - .214 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + ε, y + .166 * k + ε], [x - .115 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          return albersUsa;
        };
        return albersUsa.scale(1070);
      };
      var d3_geo_pathAreaSum,
          d3_geo_pathAreaPolygon,
          d3_geo_pathArea = {
            point: d3_noop,
            lineStart: d3_noop,
            lineEnd: d3_noop,
            polygonStart: function() {
              d3_geo_pathAreaPolygon = 0;
              d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
            },
            polygonEnd: function() {
              d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
              d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
            }
          };
      function d3_geo_pathAreaRingStart() {
        var x00,
            y00,
            x0,
            y0;
        d3_geo_pathArea.point = function(x, y) {
          d3_geo_pathArea.point = nextPoint;
          x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
          d3_geo_pathAreaPolygon += y0 * x - x0 * y;
          x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function() {
          nextPoint(x00, y00);
        };
      }
      var d3_geo_pathBoundsX0,
          d3_geo_pathBoundsY0,
          d3_geo_pathBoundsX1,
          d3_geo_pathBoundsY1;
      var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0)
          d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1)
          d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0)
          d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1)
          d3_geo_pathBoundsY1 = y;
      }
      function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5),
            buffer = [];
        var stream = {
          point: point,
          lineStart: function() {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function() {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function() {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function(_) {
            pointCircle = d3_geo_pathBufferCircle(_);
            return stream;
          },
          result: function() {
            if (buffer.length) {
              var result = buffer.join("");
              buffer = [];
              return result;
            }
          }
        };
        function point(x, y) {
          buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
          buffer.push("M", x, ",", y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          buffer.push("L", x, ",", y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          buffer.push("Z");
        }
        return stream;
      }
      function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
      }
      var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function() {
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function() {
          d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
          d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
      };
      function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
      }
      function d3_geo_pathCentroidLineStart() {
        var x0,
            y0;
        d3_geo_pathCentroid.point = function(x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
      }
      function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      }
      function d3_geo_pathCentroidRingStart() {
        var x00,
            y00,
            x0,
            y0;
        d3_geo_pathCentroid.point = function(x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          z = y0 * x - x0 * y;
          d3_geo_centroidX2 += z * (x0 + x);
          d3_geo_centroidY2 += z * (y0 + y);
          d3_geo_centroidZ2 += z * 3;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function() {
          nextPoint(x00, y00);
        };
      }
      function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
          point: point,
          lineStart: function() {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function() {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function() {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function(_) {
            pointRadius = _;
            return stream;
          },
          result: d3_noop
        };
        function point(x, y) {
          context.moveTo(x + pointRadius, y);
          context.arc(x, y, pointRadius, 0, τ);
        }
        function pointLineStart(x, y) {
          context.moveTo(x, y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          context.lineTo(x, y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          context.closePath();
        }
        return stream;
      }
      function d3_geo_resample(project) {
        var δ2 = .5,
            cosMinDistance = Math.cos(30 * d3_radians),
            maxDepth = 16;
        function resample(stream) {
          return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
          return d3_geo_transformPoint(stream, function(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          });
        }
        function resampleRecursive(stream) {
          var λ00,
              φ00,
              x00,
              y00,
              a00,
              b00,
              c00,
              λ0,
              x0,
              y0,
              a0,
              b0,
              c0;
          var resample = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              stream.polygonStart();
              resample.lineStart = ringStart;
            },
            polygonEnd: function() {
              stream.polygonEnd();
              resample.lineStart = lineStart;
            }
          };
          function point(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          }
          function lineStart() {
            x0 = NaN;
            resample.point = linePoint;
            stream.lineStart();
          }
          function linePoint(λ, φ) {
            var c = d3_geo_cartesian([λ, φ]),
                p = project(λ, φ);
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
            stream.point(x0, y0);
          }
          function lineEnd() {
            resample.point = point;
            stream.lineEnd();
          }
          function ringStart() {
            lineStart();
            resample.point = ringPoint;
            resample.lineEnd = ringEnd;
          }
          function ringPoint(λ, φ) {
            linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
            resample.point = linePoint;
          }
          function ringEnd() {
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
            resample.lineEnd = lineEnd;
            lineEnd();
          }
          return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
          var dx = x1 - x0,
              dy = y1 - y0,
              d2 = dx * dx + dy * dy;
          if (d2 > 4 * δ2 && depth--) {
            var a = a0 + a1,
                b = b0 + b1,
                c = c0 + c1,
                m = Math.sqrt(a * a + b * b + c * c),
                φ2 = Math.asin(c /= m),
                λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a),
                p = project(λ2, φ2),
                x2 = p[0],
                y2 = p[1],
                dx2 = x2 - x0,
                dy2 = y2 - y0,
                dz = dy * dx2 - dx * dy2;
            if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
              resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
              stream.point(x2, y2);
              resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
            }
          }
        }
        resample.precision = function(_) {
          if (!arguments.length)
            return Math.sqrt(δ2);
          maxDepth = (δ2 = _ * _) > 0 && 16;
          return resample;
        };
        return resample;
      }
      d3.geo.path = function() {
        var pointRadius = 4.5,
            projection,
            context,
            projectStream,
            contextStream,
            cacheStream;
        function path(object) {
          if (object) {
            if (typeof pointRadius === "function")
              contextStream.pointRadius(+pointRadius.apply(this, arguments));
            if (!cacheStream || !cacheStream.valid)
              cacheStream = projectStream(contextStream);
            d3.geo.stream(object, cacheStream);
          }
          return contextStream.result();
        }
        path.area = function(object) {
          d3_geo_pathAreaSum = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathArea));
          return d3_geo_pathAreaSum;
        };
        path.centroid = function(object) {
          d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
          return d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN];
        };
        path.bounds = function(object) {
          d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
          d3.geo.stream(object, projectStream(d3_geo_pathBounds));
          return [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]];
        };
        path.projection = function(_) {
          if (!arguments.length)
            return projection;
          projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
          return reset();
        };
        path.context = function(_) {
          if (!arguments.length)
            return context;
          contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
          if (typeof pointRadius !== "function")
            contextStream.pointRadius(pointRadius);
          return reset();
        };
        path.pointRadius = function(_) {
          if (!arguments.length)
            return pointRadius;
          pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
          return path;
        };
        function reset() {
          cacheStream = null;
          return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
      };
      function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function(x, y) {
          return project([x * d3_degrees, y * d3_degrees]);
        });
        return function(stream) {
          return d3_geo_projectionRadians(resample(stream));
        };
      }
      d3.geo.transform = function(methods) {
        return {stream: function(stream) {
            var transform = new d3_geo_transform(stream);
            for (var k in methods)
              transform[k] = methods[k];
            return transform;
          }};
      };
      function d3_geo_transform(stream) {
        this.stream = stream;
      }
      d3_geo_transform.prototype = {
        point: function(x, y) {
          this.stream.point(x, y);
        },
        sphere: function() {
          this.stream.sphere();
        },
        lineStart: function() {
          this.stream.lineStart();
        },
        lineEnd: function() {
          this.stream.lineEnd();
        },
        polygonStart: function() {
          this.stream.polygonStart();
        },
        polygonEnd: function() {
          this.stream.polygonEnd();
        }
      };
      function d3_geo_transformPoint(stream, point) {
        return {
          point: point,
          sphere: function() {
            stream.sphere();
          },
          lineStart: function() {
            stream.lineStart();
          },
          lineEnd: function() {
            stream.lineEnd();
          },
          polygonStart: function() {
            stream.polygonStart();
          },
          polygonEnd: function() {
            stream.polygonEnd();
          }
        };
      }
      d3.geo.projection = d3_geo_projection;
      d3.geo.projectionMutator = d3_geo_projectionMutator;
      function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function() {
          return project;
        })();
      }
      function d3_geo_projectionMutator(projectAt) {
        var project,
            rotate,
            projectRotate,
            projectResample = d3_geo_resample(function(x, y) {
              x = project(x, y);
              return [x[0] * k + δx, δy - x[1] * k];
            }),
            k = 150,
            x = 480,
            y = 250,
            λ = 0,
            φ = 0,
            δλ = 0,
            δφ = 0,
            δγ = 0,
            δx,
            δy,
            preclip = d3_geo_clipAntimeridian,
            postclip = d3_identity,
            clipAngle = null,
            clipExtent = null,
            stream;
        function projection(point) {
          point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
          return [point[0] * k + δx, δy - point[1] * k];
        }
        function invert(point) {
          point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
          return point && [point[0] * d3_degrees, point[1] * d3_degrees];
        }
        projection.stream = function(output) {
          if (stream)
            stream.valid = false;
          stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
          stream.valid = true;
          return stream;
        };
        projection.clipAngle = function(_) {
          if (!arguments.length)
            return clipAngle;
          preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
          return invalidate();
        };
        projection.clipExtent = function(_) {
          if (!arguments.length)
            return clipExtent;
          clipExtent = _;
          postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
          return invalidate();
        };
        projection.scale = function(_) {
          if (!arguments.length)
            return k;
          k = +_;
          return reset();
        };
        projection.translate = function(_) {
          if (!arguments.length)
            return [x, y];
          x = +_[0];
          y = +_[1];
          return reset();
        };
        projection.center = function(_) {
          if (!arguments.length)
            return [λ * d3_degrees, φ * d3_degrees];
          λ = _[0] % 360 * d3_radians;
          φ = _[1] % 360 * d3_radians;
          return reset();
        };
        projection.rotate = function(_) {
          if (!arguments.length)
            return [δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees];
          δλ = _[0] % 360 * d3_radians;
          δφ = _[1] % 360 * d3_radians;
          δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
          return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
          projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
          var center = project(λ, φ);
          δx = x - center[0] * k;
          δy = y + center[1] * k;
          return invalidate();
        }
        function invalidate() {
          if (stream)
            stream.valid = false, stream = null;
          return projection;
        }
        return function() {
          project = projectAt.apply(this, arguments);
          projection.invert = project.invert && invert;
          return reset();
        };
      }
      function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function(x, y) {
          stream.point(x * d3_radians, y * d3_radians);
        });
      }
      function d3_geo_equirectangular(λ, φ) {
        return [λ, φ];
      }
      (d3.geo.equirectangular = function() {
        return d3_geo_projection(d3_geo_equirectangular);
      }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
      d3.geo.rotation = function(rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
          coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function(coordinates) {
          coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
      };
      function d3_geo_identityRotation(λ, φ) {
        return [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
      }
      d3_geo_identityRotation.invert = d3_geo_equirectangular;
      function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
      }
      function d3_geo_forwardRotationλ(δλ) {
        return function(λ, φ) {
          return λ += δλ, [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
        };
      }
      function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
      }
      function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ),
            sinδφ = Math.sin(δφ),
            cosδγ = Math.cos(δγ),
            sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδφ + x * sinδφ;
          return [Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ)];
        }
        rotation.invert = function(λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδγ - y * sinδγ;
          return [Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ)];
        };
        return rotation;
      }
      d3.geo.circle = function() {
        var origin = [0, 0],
            angle,
            precision = 6,
            interpolate;
        function circle() {
          var center = typeof origin === "function" ? origin.apply(this, arguments) : origin,
              rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert,
              ring = [];
          interpolate(null, null, 1, {point: function(x, y) {
              ring.push(x = rotate(x, y));
              x[0] *= d3_degrees, x[1] *= d3_degrees;
            }});
          return {
            type: "Polygon",
            coordinates: [ring]
          };
        }
        circle.origin = function(x) {
          if (!arguments.length)
            return origin;
          origin = x;
          return circle;
        };
        circle.angle = function(x) {
          if (!arguments.length)
            return angle;
          interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
          return circle;
        };
        circle.precision = function(_) {
          if (!arguments.length)
            return precision;
          interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
          return circle;
        };
        return circle.angle(90);
      };
      function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius),
            sr = Math.sin(radius);
        return function(from, to, direction, listener) {
          var step = direction * precision;
          if (from != null) {
            from = d3_geo_circleAngle(cr, from);
            to = d3_geo_circleAngle(cr, to);
            if (direction > 0 ? from < to : from > to)
              from += direction * τ;
          } else {
            from = radius + direction * τ;
            to = radius - .5 * step;
          }
          for (var point,
              t = from; direction > 0 ? t > to : t < to; t -= step) {
            listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1]);
          }
        };
      }
      function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
      }
      d3.geo.distance = function(a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians,
            φ0 = a[1] * d3_radians,
            φ1 = b[1] * d3_radians,
            sinΔλ = Math.sin(Δλ),
            cosΔλ = Math.cos(Δλ),
            sinφ0 = Math.sin(φ0),
            cosφ0 = Math.cos(φ0),
            sinφ1 = Math.sin(φ1),
            cosφ1 = Math.cos(φ1),
            t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
      };
      d3.geo.graticule = function() {
        var x1,
            x0,
            X1,
            X0,
            y1,
            y0,
            Y1,
            Y0,
            dx = 10,
            dy = dx,
            DX = 90,
            DY = 360,
            x,
            y,
            X,
            Y,
            precision = 2.5;
        function graticule() {
          return {
            type: "MultiLineString",
            coordinates: lines()
          };
        }
        function lines() {
          return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
            return abs(x % DX) > ε;
          }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
            return abs(y % DY) > ε;
          }).map(y));
        }
        graticule.lines = function() {
          return lines().map(function(coordinates) {
            return {
              type: "LineString",
              coordinates: coordinates
            };
          });
        };
        graticule.outline = function() {
          return {
            type: "Polygon",
            coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
          };
        };
        graticule.extent = function(_) {
          if (!arguments.length)
            return graticule.minorExtent();
          return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function(_) {
          if (!arguments.length)
            return [[X0, Y0], [X1, Y1]];
          X0 = +_[0][0], X1 = +_[1][0];
          Y0 = +_[0][1], Y1 = +_[1][1];
          if (X0 > X1)
            _ = X0, X0 = X1, X1 = _;
          if (Y0 > Y1)
            _ = Y0, Y0 = Y1, Y1 = _;
          return graticule.precision(precision);
        };
        graticule.minorExtent = function(_) {
          if (!arguments.length)
            return [[x0, y0], [x1, y1]];
          x0 = +_[0][0], x1 = +_[1][0];
          y0 = +_[0][1], y1 = +_[1][1];
          if (x0 > x1)
            _ = x0, x0 = x1, x1 = _;
          if (y0 > y1)
            _ = y0, y0 = y1, y1 = _;
          return graticule.precision(precision);
        };
        graticule.step = function(_) {
          if (!arguments.length)
            return graticule.minorStep();
          return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function(_) {
          if (!arguments.length)
            return [DX, DY];
          DX = +_[0], DY = +_[1];
          return graticule;
        };
        graticule.minorStep = function(_) {
          if (!arguments.length)
            return [dx, dy];
          dx = +_[0], dy = +_[1];
          return graticule;
        };
        graticule.precision = function(_) {
          if (!arguments.length)
            return precision;
          precision = +_;
          x = d3_geo_graticuleX(y0, y1, 90);
          y = d3_geo_graticuleY(x0, x1, precision);
          X = d3_geo_graticuleX(Y0, Y1, 90);
          Y = d3_geo_graticuleY(X0, X1, precision);
          return graticule;
        };
        return graticule.majorExtent([[-180, -90 + ε], [180, 90 - ε]]).minorExtent([[-180, -80 - ε], [180, 80 + ε]]);
      };
      function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - ε, dy).concat(y1);
        return function(x) {
          return y.map(function(y) {
            return [x, y];
          });
        };
      }
      function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - ε, dx).concat(x1);
        return function(y) {
          return x.map(function(x) {
            return [x, y];
          });
        };
      }
      function d3_source(d) {
        return d.source;
      }
      function d3_target(d) {
        return d.target;
      }
      d3.geo.greatArc = function() {
        var source = d3_source,
            source_,
            target = d3_target,
            target_;
        function greatArc() {
          return {
            type: "LineString",
            coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]
          };
        }
        greatArc.distance = function() {
          return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function(_) {
          if (!arguments.length)
            return source;
          source = _, source_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.target = function(_) {
          if (!arguments.length)
            return target;
          target = _, target_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.precision = function() {
          return arguments.length ? greatArc : 0;
        };
        return greatArc;
      };
      d3.geo.interpolate = function(source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
      };
      function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0),
            sy0 = Math.sin(y0),
            cy1 = Math.cos(y1),
            sy1 = Math.sin(y1),
            kx0 = cy0 * Math.cos(x0),
            ky0 = cy0 * Math.sin(x0),
            kx1 = cy1 * Math.cos(x1),
            ky1 = cy1 * Math.sin(x1),
            d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))),
            k = 1 / Math.sin(d);
        var interpolate = d ? function(t) {
          var B = Math.sin(t *= d) * k,
              A = Math.sin(d - t) * k,
              x = A * kx0 + B * kx1,
              y = A * ky0 + B * ky1,
              z = A * sy0 + B * sy1;
          return [Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees];
        } : function() {
          return [x0 * d3_degrees, y0 * d3_degrees];
        };
        interpolate.distance = d;
        return interpolate;
      }
      d3.geo.length = function(object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
      };
      var d3_geo_lengthSum;
      var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_lengthLineStart() {
        var λ0,
            sinφ0,
            cosφ0;
        d3_geo_length.point = function(λ, φ) {
          λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
          d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function() {
          d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(λ, φ) {
          var sinφ = Math.sin(φ *= d3_radians),
              cosφ = Math.cos(φ),
              t = abs((λ *= d3_radians) - λ0),
              cosΔλ = Math.cos(t);
          d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
          λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
        }
      }
      function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
          var cosλ = Math.cos(λ),
              cosφ = Math.cos(φ),
              k = scale(cosλ * cosφ);
          return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];
        }
        azimuthal.invert = function(x, y) {
          var ρ = Math.sqrt(x * x + y * y),
              c = angle(ρ),
              sinc = Math.sin(c),
              cosc = Math.cos(c);
          return [Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ)];
        };
        return azimuthal;
      }
      var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
      }, function(ρ) {
        return 2 * Math.asin(ρ / 2);
      });
      (d3.geo.azimuthalEqualArea = function() {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
      }).raw = d3_geo_azimuthalEqualArea;
      var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
      }, d3_identity);
      (d3.geo.azimuthalEquidistant = function() {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
      }).raw = d3_geo_azimuthalEquidistant;
      function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            t = function(φ) {
              return Math.tan(π / 4 + φ / 2);
            },
            n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)),
            F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n)
          return d3_geo_mercator;
        function forward(λ, φ) {
          if (F > 0) {
            if (φ < -halfπ + ε)
              φ = -halfπ + ε;
          } else {
            if (φ > halfπ - ε)
              φ = halfπ - ε;
          }
          var ρ = F / Math.pow(t(φ), n);
          return [ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = F - y,
              ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
          return [Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ];
        };
        return forward;
      }
      (d3.geo.conicConformal = function() {
        return d3_geo_conic(d3_geo_conicConformal);
      }).raw = d3_geo_conicConformal;
      function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0),
            G = cosφ0 / n + φ0;
        if (abs(n) < ε)
          return d3_geo_equirectangular;
        function forward(λ, φ) {
          var ρ = G - φ;
          return [ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = G - y;
          return [Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)];
        };
        return forward;
      }
      (d3.geo.conicEquidistant = function() {
        return d3_geo_conic(d3_geo_conicEquidistant);
      }).raw = d3_geo_conicEquidistant;
      var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / cosλcosφ;
      }, Math.atan);
      (d3.geo.gnomonic = function() {
        return d3_geo_projection(d3_geo_gnomonic);
      }).raw = d3_geo_gnomonic;
      function d3_geo_mercator(λ, φ) {
        return [λ, Math.log(Math.tan(π / 4 + φ / 2))];
      }
      d3_geo_mercator.invert = function(x, y) {
        return [x, 2 * Math.atan(Math.exp(y)) - halfπ];
      };
      function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project),
            scale = m.scale,
            translate = m.translate,
            clipExtent = m.clipExtent,
            clipAuto;
        m.scale = function() {
          var v = scale.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function() {
          var v = translate.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function(_) {
          var v = clipExtent.apply(m, arguments);
          if (v === m) {
            if (clipAuto = _ == null) {
              var k = π * scale(),
                  t = translate();
              clipExtent([[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]]);
            }
          } else if (clipAuto) {
            v = null;
          }
          return v;
        };
        return m.clipExtent(null);
      }
      (d3.geo.mercator = function() {
        return d3_geo_mercatorProjection(d3_geo_mercator);
      }).raw = d3_geo_mercator;
      var d3_geo_orthographic = d3_geo_azimuthal(function() {
        return 1;
      }, Math.asin);
      (d3.geo.orthographic = function() {
        return d3_geo_projection(d3_geo_orthographic);
      }).raw = d3_geo_orthographic;
      var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / (1 + cosλcosφ);
      }, function(ρ) {
        return 2 * Math.atan(ρ);
      });
      (d3.geo.stereographic = function() {
        return d3_geo_projection(d3_geo_stereographic);
      }).raw = d3_geo_stereographic;
      function d3_geo_transverseMercator(λ, φ) {
        return [Math.log(Math.tan(π / 4 + φ / 2)), -λ];
      }
      d3_geo_transverseMercator.invert = function(x, y) {
        return [-y, 2 * Math.atan(Math.exp(x)) - halfπ];
      };
      (d3.geo.transverseMercator = function() {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator),
            center = projection.center,
            rotate = projection.rotate;
        projection.center = function(_) {
          return _ ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
        };
        projection.rotate = function(_) {
          return _ ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
        };
        return rotate([0, 0, 90]);
      }).raw = d3_geo_transverseMercator;
      d3.geom = {};
      function d3_geom_pointX(d) {
        return d[0];
      }
      function d3_geom_pointY(d) {
        return d[1];
      }
      d3.geom.hull = function(vertices) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY;
        if (arguments.length)
          return hull(vertices);
        function hull(data) {
          if (data.length < 3)
            return [];
          var fx = d3_functor(x),
              fy = d3_functor(y),
              i,
              n = data.length,
              points = [],
              flippedPoints = [];
          for (i = 0; i < n; i++) {
            points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
          }
          points.sort(d3_geom_hullOrder);
          for (i = 0; i < n; i++)
            flippedPoints.push([points[i][0], -points[i][1]]);
          var upper = d3_geom_hullUpper(points),
              lower = d3_geom_hullUpper(flippedPoints);
          var skipLeft = lower[0] === upper[0],
              skipRight = lower[lower.length - 1] === upper[upper.length - 1],
              polygon = [];
          for (i = upper.length - 1; i >= 0; --i)
            polygon.push(data[points[upper[i]][2]]);
          for (i = +skipLeft; i < lower.length - skipRight; ++i)
            polygon.push(data[points[lower[i]][2]]);
          return polygon;
        }
        hull.x = function(_) {
          return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function(_) {
          return arguments.length ? (y = _, hull) : y;
        };
        return hull;
      };
      function d3_geom_hullUpper(points) {
        var n = points.length,
            hull = [0, 1],
            hs = 2;
        for (var i = 2; i < n; i++) {
          while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0)
            --hs;
          hull[hs++] = i;
        }
        return hull.slice(0, hs);
      }
      function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
      }
      d3.geom.polygon = function(coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
      };
      var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
      d3_geom_polygonPrototype.area = function() {
        var i = -1,
            n = this.length,
            a,
            b = this[n - 1],
            area = 0;
        while (++i < n) {
          a = b;
          b = this[i];
          area += a[1] * b[0] - a[0] * b[1];
        }
        return area * .5;
      };
      d3_geom_polygonPrototype.centroid = function(k) {
        var i = -1,
            n = this.length,
            x = 0,
            y = 0,
            a,
            b = this[n - 1],
            c;
        if (!arguments.length)
          k = -1 / (6 * this.area());
        while (++i < n) {
          a = b;
          b = this[i];
          c = a[0] * b[1] - b[0] * a[1];
          x += (a[0] + b[0]) * c;
          y += (a[1] + b[1]) * c;
        }
        return [x * k, y * k];
      };
      d3_geom_polygonPrototype.clip = function(subject) {
        var input,
            closed = d3_geom_polygonClosed(subject),
            i = -1,
            n = this.length - d3_geom_polygonClosed(this),
            j,
            m,
            a = this[n - 1],
            b,
            c,
            d;
        while (++i < n) {
          input = subject.slice();
          subject.length = 0;
          b = this[i];
          c = input[(m = input.length - closed) - 1];
          j = -1;
          while (++j < m) {
            d = input[j];
            if (d3_geom_polygonInside(d, a, b)) {
              if (!d3_geom_polygonInside(c, a, b)) {
                subject.push(d3_geom_polygonIntersect(c, d, a, b));
              }
              subject.push(d);
            } else if (d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            c = d;
          }
          if (closed)
            subject.push(subject[0]);
          a = b;
        }
        return subject;
      };
      function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
      }
      function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0],
            x3 = a[0],
            x21 = d[0] - x1,
            x43 = b[0] - x3,
            y1 = c[1],
            y3 = a[1],
            y21 = d[1] - y1,
            y43 = b[1] - y3,
            ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [x1 + ua * x21, y1 + ua * y21];
      }
      function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0],
            b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
      }
      var d3_geom_voronoiEdges,
          d3_geom_voronoiCells,
          d3_geom_voronoiBeaches,
          d3_geom_voronoiBeachPool = [],
          d3_geom_voronoiFirstCircle,
          d3_geom_voronoiCircles,
          d3_geom_voronoiCirclePool = [];
      function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
      }
      function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
      }
      function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
      }
      function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle,
            x = circle.x,
            y = circle.cy,
            vertex = {
              x: x,
              y: y
            },
            previous = beach.P,
            next = beach.N,
            disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
          previous = lArc.P;
          disappearing.unshift(lArc);
          d3_geom_voronoiDetachBeach(lArc);
          lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
          next = rArc.N;
          disappearing.push(rArc);
          d3_geom_voronoiDetachBeach(rArc);
          rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length,
            iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
          rArc = disappearing[iArc];
          lArc = disappearing[iArc - 1];
          d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiAddBeach(site) {
        var x = site.x,
            directrix = site.y,
            lArc,
            rArc,
            dxl,
            dxr,
            node = d3_geom_voronoiBeaches._;
        while (node) {
          dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
          if (dxl > ε)
            node = node.L;
          else {
            dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
            if (dxr > ε) {
              if (!node.R) {
                lArc = node;
                break;
              }
              node = node.R;
            } else {
              if (dxl > -ε) {
                lArc = node.P;
                rArc = node;
              } else if (dxr > -ε) {
                lArc = node;
                rArc = node.N;
              } else {
                lArc = rArc = node;
              }
              break;
            }
          }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc)
          return;
        if (lArc === rArc) {
          d3_geom_voronoiDetachCircle(lArc);
          rArc = d3_geom_voronoiCreateBeach(lArc.site);
          d3_geom_voronoiBeaches.insert(newArc, rArc);
          newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
          return;
        }
        if (!rArc) {
          newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site,
            ax = lSite.x,
            ay = lSite.y,
            bx = site.x - ax,
            by = site.y - ay,
            rSite = rArc.site,
            cx = rSite.x - ax,
            cy = rSite.y - ay,
            d = 2 * (bx * cy - by * cx),
            hb = bx * bx + by * by,
            hc = cx * cx + cy * cy,
            vertex = {
              x: (cy * hb - by * hc) / d + ax,
              y: (bx * hc - cx * hb) / d + ay
            };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site,
            rfocx = site.x,
            rfocy = site.y,
            pby2 = rfocy - directrix;
        if (!pby2)
          return rfocx;
        var lArc = arc.P;
        if (!lArc)
          return -Infinity;
        site = lArc.site;
        var lfocx = site.x,
            lfocy = site.y,
            plby2 = lfocy - directrix;
        if (!plby2)
          return lfocx;
        var hl = lfocx - rfocx,
            aby2 = 1 / pby2 - 1 / plby2,
            b = hl / plby2;
        if (aby2)
          return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
      }
      function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc)
          return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
      }
      function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
      }
      d3_geom_voronoiCell.prototype.prepare = function() {
        var halfEdges = this.edges,
            iHalfEdge = halfEdges.length,
            edge;
        while (iHalfEdge--) {
          edge = halfEdges[iHalfEdge].edge;
          if (!edge.b || !edge.a)
            halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
      };
      function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            x2,
            y2,
            x3,
            y3,
            cells = d3_geom_voronoiCells,
            iCell = cells.length,
            cell,
            iHalfEdge,
            halfEdges,
            nHalfEdges,
            start,
            end;
        while (iCell--) {
          cell = cells[iCell];
          if (!cell || !cell.prepare())
            continue;
          halfEdges = cell.edges;
          nHalfEdges = halfEdges.length;
          iHalfEdge = 0;
          while (iHalfEdge < nHalfEdges) {
            end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
            start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
            if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
              halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                x: x0,
                y: abs(x2 - x0) < ε ? y2 : y1
              } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                x: abs(y2 - y1) < ε ? x2 : x1,
                y: y1
              } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                x: x1,
                y: abs(x2 - x1) < ε ? y2 : y0
              } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                x: abs(y2 - y0) < ε ? x2 : x0,
                y: y0
              } : null), cell.site, null));
              ++nHalfEdges;
            }
          }
        }
      }
      function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
      }
      function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
      }
      function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P,
            rArc = arc.N;
        if (!lArc || !rArc)
          return;
        var lSite = lArc.site,
            cSite = arc.site,
            rSite = rArc.site;
        if (lSite === rSite)
          return;
        var bx = cSite.x,
            by = cSite.y,
            ax = lSite.x - bx,
            ay = lSite.y - by,
            cx = rSite.x - bx,
            cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -ε2)
          return;
        var ha = ax * ax + ay * ay,
            hc = cx * cx + cy * cy,
            x = (cy * ha - ay * hc) / d,
            y = (ax * hc - cx * ha) / d,
            cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null,
            node = d3_geom_voronoiCircles._;
        while (node) {
          if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
            if (node.L)
              node = node.L;
            else {
              before = node.P;
              break;
            }
          } else {
            if (node.R)
              node = node.R;
            else {
              before = node;
              break;
            }
          }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before)
          d3_geom_voronoiFirstCircle = circle;
      }
      function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
          if (!circle.P)
            d3_geom_voronoiFirstCircle = circle.N;
          d3_geom_voronoiCircles.remove(circle);
          d3_geom_voronoiCirclePool.push(circle);
          d3_geom_voronoiRedBlackNode(circle);
          arc.circle = null;
        }
      }
      function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges,
            clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]),
            i = edges.length,
            e;
        while (i--) {
          e = edges[i];
          if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
            e.a = e.b = null;
            edges.splice(i, 1);
          }
        }
      }
      function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb)
          return true;
        var va = edge.a,
            x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            lSite = edge.l,
            rSite = edge.r,
            lx = lSite.x,
            ly = lSite.y,
            rx = rSite.x,
            ry = rSite.y,
            fx = (lx + rx) / 2,
            fy = (ly + ry) / 2,
            fm,
            fb;
        if (ry === ly) {
          if (fx < x0 || fx >= x1)
            return;
          if (lx > rx) {
            if (!va)
              va = {
                x: fx,
                y: y0
              };
            else if (va.y >= y1)
              return;
            vb = {
              x: fx,
              y: y1
            };
          } else {
            if (!va)
              va = {
                x: fx,
                y: y1
              };
            else if (va.y < y0)
              return;
            vb = {
              x: fx,
              y: y0
            };
          }
        } else {
          fm = (lx - rx) / (ry - ly);
          fb = fy - fm * fx;
          if (fm < -1 || fm > 1) {
            if (lx > rx) {
              if (!va)
                va = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
              else if (va.y >= y1)
                return;
              vb = {
                x: (y1 - fb) / fm,
                y: y1
              };
            } else {
              if (!va)
                va = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
              else if (va.y < y0)
                return;
              vb = {
                x: (y0 - fb) / fm,
                y: y0
              };
            }
          } else {
            if (ly < ry) {
              if (!va)
                va = {
                  x: x0,
                  y: fm * x0 + fb
                };
              else if (va.x >= x1)
                return;
              vb = {
                x: x1,
                y: fm * x1 + fb
              };
            } else {
              if (!va)
                va = {
                  x: x1,
                  y: fm * x1 + fb
                };
              else if (va.x < x0)
                return;
              vb = {
                x: x0,
                y: fm * x0 + fb
              };
            }
          }
        }
        edge.a = va;
        edge.b = vb;
        return true;
      }
      function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
      }
      function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va)
          d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb)
          d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
      }
      function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
      }
      function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
          edge.a = vertex;
          edge.l = lSite;
          edge.r = rSite;
        } else if (edge.l === rSite) {
          edge.b = vertex;
        } else {
          edge.a = vertex;
        }
      }
      function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a,
            vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
      }
      d3_geom_voronoiHalfEdge.prototype = {
        start: function() {
          return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function() {
          return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
      };
      function d3_geom_voronoiRedBlackTree() {
        this._ = null;
      }
      function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
      }
      d3_geom_voronoiRedBlackTree.prototype = {
        insert: function(after, node) {
          var parent,
              grandpa,
              uncle;
          if (after) {
            node.P = after;
            node.N = after.N;
            if (after.N)
              after.N.P = node;
            after.N = node;
            if (after.R) {
              after = after.R;
              while (after.L)
                after = after.L;
              after.L = node;
            } else {
              after.R = node;
            }
            parent = after;
          } else if (this._) {
            after = d3_geom_voronoiRedBlackFirst(this._);
            node.P = null;
            node.N = after;
            after.P = after.L = node;
            parent = after;
          } else {
            node.P = node.N = null;
            this._ = node;
            parent = null;
          }
          node.L = node.R = null;
          node.U = parent;
          node.C = true;
          after = node;
          while (parent && parent.C) {
            grandpa = parent.U;
            if (parent === grandpa.L) {
              uncle = grandpa.R;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.R) {
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, grandpa);
              }
            } else {
              uncle = grandpa.L;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.L) {
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
              }
            }
            parent = after.U;
          }
          this._.C = false;
        },
        remove: function(node) {
          if (node.N)
            node.N.P = node.P;
          if (node.P)
            node.P.N = node.N;
          node.N = node.P = null;
          var parent = node.U,
              sibling,
              left = node.L,
              right = node.R,
              next,
              red;
          if (!left)
            next = right;
          else if (!right)
            next = left;
          else
            next = d3_geom_voronoiRedBlackFirst(right);
          if (parent) {
            if (parent.L === node)
              parent.L = next;
            else
              parent.R = next;
          } else {
            this._ = next;
          }
          if (left && right) {
            red = next.C;
            next.C = node.C;
            next.L = left;
            left.U = next;
            if (next !== right) {
              parent = next.U;
              next.U = node.U;
              node = next.R;
              parent.L = node;
              next.R = right;
              right.U = next;
            } else {
              next.U = parent;
              parent = next;
              node = next.R;
            }
          } else {
            red = node.C;
            node = next;
          }
          if (node)
            node.U = parent;
          if (red)
            return;
          if (node && node.C) {
            node.C = false;
            return;
          }
          do {
            if (node === this._)
              break;
            if (node === parent.L) {
              sibling = parent.R;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                sibling = parent.R;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.R || !sibling.R.C) {
                  sibling.L.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, sibling);
                  sibling = parent.R;
                }
                sibling.C = parent.C;
                parent.C = sibling.R.C = false;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                node = this._;
                break;
              }
            } else {
              sibling = parent.L;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                sibling = parent.L;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.L || !sibling.L.C) {
                  sibling.R.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                  sibling = parent.L;
                }
                sibling.C = parent.C;
                parent.C = sibling.L.C = false;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                node = this._;
                break;
              }
            }
            sibling.C = true;
            node = parent;
            parent = parent.U;
          } while (!node.C);
          if (node)
            node.C = false;
        }
      };
      function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node,
            q = node.R,
            parent = p.U;
        if (parent) {
          if (parent.L === p)
            parent.L = q;
          else
            parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R)
          p.R.U = p;
        q.L = p;
      }
      function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node,
            q = node.L,
            parent = p.U;
        if (parent) {
          if (parent.L === p)
            parent.L = q;
          else
            parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L)
          p.L.U = p;
        q.R = p;
      }
      function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L)
          node = node.L;
        return node;
      }
      function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(),
            x0,
            y0,
            circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
          circle = d3_geom_voronoiFirstCircle;
          if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
            if (site.x !== x0 || site.y !== y0) {
              d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
              d3_geom_voronoiAddBeach(site);
              x0 = site.x, y0 = site.y;
            }
            site = sites.pop();
          } else if (circle) {
            d3_geom_voronoiRemoveBeach(circle.arc);
          } else {
            break;
          }
        }
        if (bbox)
          d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
          cells: d3_geom_voronoiCells,
          edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
      }
      function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
      }
      d3.geom.voronoi = function(points) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            fx = x,
            fy = y,
            clipExtent = d3_geom_voronoiClipExtent;
        if (points)
          return voronoi(points);
        function voronoi(data) {
          var polygons = new Array(data.length),
              x0 = clipExtent[0][0],
              y0 = clipExtent[0][1],
              x1 = clipExtent[1][0],
              y1 = clipExtent[1][1];
          d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
            var edges = cell.edges,
                site = cell.site,
                polygon = polygons[i] = edges.length ? edges.map(function(e) {
                  var s = e.start();
                  return [s.x, s.y];
                }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
            polygon.point = data[i];
          });
          return polygons;
        }
        function sites(data) {
          return data.map(function(d, i) {
            return {
              x: Math.round(fx(d, i) / ε) * ε,
              y: Math.round(fy(d, i) / ε) * ε,
              i: i
            };
          });
        }
        voronoi.links = function(data) {
          return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
            return edge.l && edge.r;
          }).map(function(edge) {
            return {
              source: data[edge.l.i],
              target: data[edge.r.i]
            };
          });
        };
        voronoi.triangles = function(data) {
          var triangles = [];
          d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
            var site = cell.site,
                edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),
                j = -1,
                m = edges.length,
                e0,
                s0,
                e1 = edges[m - 1].edge,
                s1 = e1.l === site ? e1.r : e1.l;
            while (++j < m) {
              e0 = e1;
              s0 = s1;
              e1 = edges[j].edge;
              s1 = e1.l === site ? e1.r : e1.l;
              if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                triangles.push([data[i], data[s0.i], data[s1.i]]);
              }
            }
          });
          return triangles;
        };
        voronoi.x = function(_) {
          return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function(_) {
          return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function(_) {
          if (!arguments.length)
            return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
          clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
          return voronoi;
        };
        voronoi.size = function(_) {
          if (!arguments.length)
            return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
          return voronoi.clipExtent(_ && [[0, 0], _]);
        };
        return voronoi;
      };
      var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
      function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
      }
      d3.geom.delaunay = function(vertices) {
        return d3.geom.voronoi().triangles(vertices);
      };
      d3.geom.quadtree = function(points, x1, y1, x2, y2) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            compat;
        if (compat = arguments.length) {
          x = d3_geom_quadtreeCompatX;
          y = d3_geom_quadtreeCompatY;
          if (compat === 3) {
            y2 = y1;
            x2 = x1;
            y1 = x1 = 0;
          }
          return quadtree(points);
        }
        function quadtree(data) {
          var d,
              fx = d3_functor(x),
              fy = d3_functor(y),
              xs,
              ys,
              i,
              n,
              x1_,
              y1_,
              x2_,
              y2_;
          if (x1 != null) {
            x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
          } else {
            x2_ = y2_ = -(x1_ = y1_ = Infinity);
            xs = [], ys = [];
            n = data.length;
            if (compat)
              for (i = 0; i < n; ++i) {
                d = data[i];
                if (d.x < x1_)
                  x1_ = d.x;
                if (d.y < y1_)
                  y1_ = d.y;
                if (d.x > x2_)
                  x2_ = d.x;
                if (d.y > y2_)
                  y2_ = d.y;
                xs.push(d.x);
                ys.push(d.y);
              }
            else
              for (i = 0; i < n; ++i) {
                var x_ = +fx(d = data[i], i),
                    y_ = +fy(d, i);
                if (x_ < x1_)
                  x1_ = x_;
                if (y_ < y1_)
                  y1_ = y_;
                if (x_ > x2_)
                  x2_ = x_;
                if (y_ > y2_)
                  y2_ = y_;
                xs.push(x_);
                ys.push(y_);
              }
          }
          var dx = x2_ - x1_,
              dy = y2_ - y1_;
          if (dx > dy)
            y2_ = y1_ + dx;
          else
            x2_ = x1_ + dy;
          function insert(n, d, x, y, x1, y1, x2, y2) {
            if (isNaN(x) || isNaN(y))
              return;
            if (n.leaf) {
              var nx = n.x,
                  ny = n.y;
              if (nx != null) {
                if (abs(nx - x) + abs(ny - y) < .01) {
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                } else {
                  var nPoint = n.point;
                  n.x = n.y = n.point = null;
                  insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                }
              } else {
                n.x = x, n.y = y, n.point = d;
              }
            } else {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          }
          function insertChild(n, d, x, y, x1, y1, x2, y2) {
            var xm = (x1 + x2) * .5,
                ym = (y1 + y2) * .5,
                right = x >= xm,
                below = y >= ym,
                i = below << 1 | right;
            n.leaf = false;
            n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
            if (right)
              x1 = xm;
            else
              x2 = xm;
            if (below)
              y1 = ym;
            else
              y2 = ym;
            insert(n, d, x, y, x1, y1, x2, y2);
          }
          var root = d3_geom_quadtreeNode();
          root.add = function(d) {
            insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
          };
          root.visit = function(f) {
            d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
          };
          root.find = function(point) {
            return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
          };
          i = -1;
          if (x1 == null) {
            while (++i < n) {
              insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
            }
            --i;
          } else
            data.forEach(root.add);
          xs = ys = data = d = null;
          return root;
        }
        quadtree.x = function(_) {
          return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function(_) {
          return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function(_) {
          if (!arguments.length)
            return x1 == null ? null : [[x1, y1], [x2, y2]];
          if (_ == null)
            x1 = y1 = x2 = y2 = null;
          else
            x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
          return quadtree;
        };
        quadtree.size = function(_) {
          if (!arguments.length)
            return x1 == null ? null : [x2 - x1, y2 - y1];
          if (_ == null)
            x1 = y1 = x2 = y2 = null;
          else
            x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
          return quadtree;
        };
        return quadtree;
      };
      function d3_geom_quadtreeCompatX(d) {
        return d.x;
      }
      function d3_geom_quadtreeCompatY(d) {
        return d.y;
      }
      function d3_geom_quadtreeNode() {
        return {
          leaf: true,
          nodes: [],
          point: null,
          x: null,
          y: null
        };
      }
      function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
          var sx = (x1 + x2) * .5,
              sy = (y1 + y2) * .5,
              children = node.nodes;
          if (children[0])
            d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
          if (children[1])
            d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
          if (children[2])
            d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
          if (children[3])
            d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
      }
      function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity,
            closestPoint;
        (function find(node, x1, y1, x2, y2) {
          if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0)
            return;
          if (point = node.point) {
            var point,
                dx = x - node.x,
                dy = y - node.y,
                distance2 = dx * dx + dy * dy;
            if (distance2 < minDistance2) {
              var distance = Math.sqrt(minDistance2 = distance2);
              x0 = x - distance, y0 = y - distance;
              x3 = x + distance, y3 = y + distance;
              closestPoint = point;
            }
          }
          var children = node.nodes,
              xm = (x1 + x2) * .5,
              ym = (y1 + y2) * .5,
              right = x >= xm,
              below = y >= ym;
          for (var i = below << 1 | right,
              j = i + 4; i < j; ++i) {
            if (node = children[i & 3])
              switch (i & 3) {
                case 0:
                  find(node, x1, y1, xm, ym);
                  break;
                case 1:
                  find(node, xm, y1, x2, ym);
                  break;
                case 2:
                  find(node, x1, ym, xm, y2);
                  break;
                case 3:
                  find(node, xm, ym, x2, y2);
                  break;
              }
          }
        })(root, x0, y0, x3, y3);
        return closestPoint;
      }
      d3.interpolateRgb = d3_interpolateRgb;
      function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r,
            ag = a.g,
            ab = a.b,
            br = b.r - ar,
            bg = b.g - ag,
            bb = b.b - ab;
        return function(t) {
          return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
      }
      d3.interpolateObject = d3_interpolateObject;
      function d3_interpolateObject(a, b) {
        var i = {},
            c = {},
            k;
        for (k in a) {
          if (k in b) {
            i[k] = d3_interpolate(a[k], b[k]);
          } else {
            c[k] = a[k];
          }
        }
        for (k in b) {
          if (!(k in a)) {
            c[k] = b[k];
          }
        }
        return function(t) {
          for (k in i)
            c[k] = i[k](t);
          return c;
        };
      }
      d3.interpolateNumber = d3_interpolateNumber;
      function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function(t) {
          return a * (1 - t) + b * t;
        };
      }
      d3.interpolateString = d3_interpolateString;
      function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0,
            am,
            bm,
            bs,
            i = -1,
            s = [],
            q = [];
        a = a + "", b = b + "";
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
          if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s[i])
              s[i] += bs;
            else
              s[++i] = bs;
          }
          if ((am = am[0]) === (bm = bm[0])) {
            if (s[i])
              s[i] += bm;
            else
              s[++i] = bm;
          } else {
            s[++i] = null;
            q.push({
              i: i,
              x: d3_interpolateNumber(am, bm)
            });
          }
          bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
          bs = b.slice(bi);
          if (s[i])
            s[i] += bs;
          else
            s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
          return b(t) + "";
        }) : function() {
          return b;
        } : (b = q.length, function(t) {
          for (var i = 0,
              o; i < b; ++i)
            s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
      }
      var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
          d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
      d3.interpolate = d3_interpolate;
      function d3_interpolate(a, b) {
        var i = d3.interpolators.length,
            f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b)))
          ;
        return f;
      }
      d3.interpolators = [function(a, b) {
        var t = typeof b;
        return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
      }];
      d3.interpolateArray = d3_interpolateArray;
      function d3_interpolateArray(a, b) {
        var x = [],
            c = [],
            na = a.length,
            nb = b.length,
            n0 = Math.min(a.length, b.length),
            i;
        for (i = 0; i < n0; ++i)
          x.push(d3_interpolate(a[i], b[i]));
        for (; i < na; ++i)
          c[i] = a[i];
        for (; i < nb; ++i)
          c[i] = b[i];
        return function(t) {
          for (i = 0; i < n0; ++i)
            c[i] = x[i](t);
          return c;
        };
      }
      var d3_ease_default = function() {
        return d3_identity;
      };
      var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
          return d3_ease_quad;
        },
        cubic: function() {
          return d3_ease_cubic;
        },
        sin: function() {
          return d3_ease_sin;
        },
        exp: function() {
          return d3_ease_exp;
        },
        circle: function() {
          return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
          return d3_ease_bounce;
        }
      });
      var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
          return d3_ease_reflect(d3_ease_reverse(f));
        }
      });
      d3.ease = function(name) {
        var i = name.indexOf("-"),
            t = i >= 0 ? name.slice(0, i) : name,
            m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
      };
      function d3_ease_clamp(f) {
        return function(t) {
          return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
      }
      function d3_ease_reverse(f) {
        return function(t) {
          return 1 - f(1 - t);
        };
      }
      function d3_ease_reflect(f) {
        return function(t) {
          return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
      }
      function d3_ease_quad(t) {
        return t * t;
      }
      function d3_ease_cubic(t) {
        return t * t * t;
      }
      function d3_ease_cubicInOut(t) {
        if (t <= 0)
          return 0;
        if (t >= 1)
          return 1;
        var t2 = t * t,
            t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
      }
      function d3_ease_poly(e) {
        return function(t) {
          return Math.pow(t, e);
        };
      }
      function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
      }
      function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
      }
      function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
      function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2)
          p = .45;
        if (arguments.length)
          s = p / τ * Math.asin(1 / a);
        else
          a = 1, s = p / 4;
        return function(t) {
          return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        };
      }
      function d3_ease_back(s) {
        if (!s)
          s = 1.70158;
        return function(t) {
          return t * t * ((s + 1) * t - s);
        };
      }
      function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
      }
      d3.interpolateHcl = d3_interpolateHcl;
      function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h,
            ac = a.c,
            al = a.l,
            bh = b.h - ah,
            bc = b.c - ac,
            bl = b.l - al;
        if (isNaN(bc))
          bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh))
          bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
          bh -= 360;
        else if (bh < -180)
          bh += 360;
        return function(t) {
          return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
      }
      d3.interpolateHsl = d3_interpolateHsl;
      function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h,
            as = a.s,
            al = a.l,
            bh = b.h - ah,
            bs = b.s - as,
            bl = b.l - al;
        if (isNaN(bs))
          bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh))
          bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
          bh -= 360;
        else if (bh < -180)
          bh += 360;
        return function(t) {
          return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
      }
      d3.interpolateLab = d3_interpolateLab;
      function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l,
            aa = a.a,
            ab = a.b,
            bl = b.l - al,
            ba = b.a - aa,
            bb = b.b - ab;
        return function(t) {
          return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
      }
      d3.interpolateRound = d3_interpolateRound;
      function d3_interpolateRound(a, b) {
        b -= a;
        return function(t) {
          return Math.round(a + b * t);
        };
      }
      d3.transform = function(string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function(string) {
          if (string != null) {
            g.setAttribute("transform", string);
            var t = g.transform.baseVal.consolidate();
          }
          return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
      };
      function d3_transform(m) {
        var r0 = [m.a, m.b],
            r1 = [m.c, m.d],
            kx = d3_transformNormalize(r0),
            kz = d3_transformDot(r0, r1),
            ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
          r0[0] *= -1;
          r0[1] *= -1;
          kx *= -1;
          kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [m.e, m.f];
        this.scale = [kx, ky];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
      }
      d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
      };
      function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      }
      function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
          a[0] /= k;
          a[1] /= k;
        }
        return k;
      }
      function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
      }
      var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
      };
      d3.interpolateTransform = d3_interpolateTransform;
      function d3_interpolateTransform(a, b) {
        var s = [],
            q = [],
            n,
            A = d3.transform(a),
            B = d3.transform(b),
            ta = A.translate,
            tb = B.translate,
            ra = A.rotate,
            rb = B.rotate,
            wa = A.skew,
            wb = B.skew,
            ka = A.scale,
            kb = B.scale;
        if (ta[0] != tb[0] || ta[1] != tb[1]) {
          s.push("translate(", null, ",", null, ")");
          q.push({
            i: 1,
            x: d3_interpolateNumber(ta[0], tb[0])
          }, {
            i: 3,
            x: d3_interpolateNumber(ta[1], tb[1])
          });
        } else if (tb[0] || tb[1]) {
          s.push("translate(" + tb + ")");
        } else {
          s.push("");
        }
        if (ra != rb) {
          if (ra - rb > 180)
            rb += 360;
          else if (rb - ra > 180)
            ra += 360;
          q.push({
            i: s.push(s.pop() + "rotate(", null, ")") - 2,
            x: d3_interpolateNumber(ra, rb)
          });
        } else if (rb) {
          s.push(s.pop() + "rotate(" + rb + ")");
        }
        if (wa != wb) {
          q.push({
            i: s.push(s.pop() + "skewX(", null, ")") - 2,
            x: d3_interpolateNumber(wa, wb)
          });
        } else if (wb) {
          s.push(s.pop() + "skewX(" + wb + ")");
        }
        if (ka[0] != kb[0] || ka[1] != kb[1]) {
          n = s.push(s.pop() + "scale(", null, ",", null, ")");
          q.push({
            i: n - 4,
            x: d3_interpolateNumber(ka[0], kb[0])
          }, {
            i: n - 2,
            x: d3_interpolateNumber(ka[1], kb[1])
          });
        } else if (kb[0] != 1 || kb[1] != 1) {
          s.push(s.pop() + "scale(" + kb + ")");
        }
        n = q.length;
        return function(t) {
          var i = -1,
              o;
          while (++i < n)
            s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      }
      function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
          return (x - a) / b;
        };
      }
      function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
          return Math.max(0, Math.min(1, (x - a) / b));
        };
      }
      d3.layout = {};
      d3.layout.bundle = function() {
        return function(links) {
          var paths = [],
              i = -1,
              n = links.length;
          while (++i < n)
            paths.push(d3_layout_bundlePath(links[i]));
          return paths;
        };
      };
      function d3_layout_bundlePath(link) {
        var start = link.source,
            end = link.target,
            lca = d3_layout_bundleLeastCommonAncestor(start, end),
            points = [start];
        while (start !== lca) {
          start = start.parent;
          points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
          points.splice(k, 0, end);
          end = end.parent;
        }
        return points;
      }
      function d3_layout_bundleAncestors(node) {
        var ancestors = [],
            parent = node.parent;
        while (parent != null) {
          ancestors.push(node);
          node = parent;
          parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
      }
      function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b)
          return a;
        var aNodes = d3_layout_bundleAncestors(a),
            bNodes = d3_layout_bundleAncestors(b),
            aNode = aNodes.pop(),
            bNode = bNodes.pop(),
            sharedNode = null;
        while (aNode === bNode) {
          sharedNode = aNode;
          aNode = aNodes.pop();
          bNode = bNodes.pop();
        }
        return sharedNode;
      }
      d3.layout.chord = function() {
        var chord = {},
            chords,
            groups,
            matrix,
            n,
            padding = 0,
            sortGroups,
            sortSubgroups,
            sortChords;
        function relayout() {
          var subgroups = {},
              groupSums = [],
              groupIndex = d3.range(n),
              subgroupIndex = [],
              k,
              x,
              x0,
              i,
              j;
          chords = [];
          groups = [];
          k = 0, i = -1;
          while (++i < n) {
            x = 0, j = -1;
            while (++j < n) {
              x += matrix[i][j];
            }
            groupSums.push(x);
            subgroupIndex.push(d3.range(n));
            k += x;
          }
          if (sortGroups) {
            groupIndex.sort(function(a, b) {
              return sortGroups(groupSums[a], groupSums[b]);
            });
          }
          if (sortSubgroups) {
            subgroupIndex.forEach(function(d, i) {
              d.sort(function(a, b) {
                return sortSubgroups(matrix[i][a], matrix[i][b]);
              });
            });
          }
          k = (τ - padding * n) / k;
          x = 0, i = -1;
          while (++i < n) {
            x0 = x, j = -1;
            while (++j < n) {
              var di = groupIndex[i],
                  dj = subgroupIndex[di][j],
                  v = matrix[di][dj],
                  a0 = x,
                  a1 = x += v * k;
              subgroups[di + "-" + dj] = {
                index: di,
                subindex: dj,
                startAngle: a0,
                endAngle: a1,
                value: v
              };
            }
            groups[di] = {
              index: di,
              startAngle: x0,
              endAngle: x,
              value: (x - x0) / k
            };
            x += padding;
          }
          i = -1;
          while (++i < n) {
            j = i - 1;
            while (++j < n) {
              var source = subgroups[i + "-" + j],
                  target = subgroups[j + "-" + i];
              if (source.value || target.value) {
                chords.push(source.value < target.value ? {
                  source: target,
                  target: source
                } : {
                  source: source,
                  target: target
                });
              }
            }
          }
          if (sortChords)
            resort();
        }
        function resort() {
          chords.sort(function(a, b) {
            return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
          });
        }
        chord.matrix = function(x) {
          if (!arguments.length)
            return matrix;
          n = (matrix = x) && matrix.length;
          chords = groups = null;
          return chord;
        };
        chord.padding = function(x) {
          if (!arguments.length)
            return padding;
          padding = x;
          chords = groups = null;
          return chord;
        };
        chord.sortGroups = function(x) {
          if (!arguments.length)
            return sortGroups;
          sortGroups = x;
          chords = groups = null;
          return chord;
        };
        chord.sortSubgroups = function(x) {
          if (!arguments.length)
            return sortSubgroups;
          sortSubgroups = x;
          chords = null;
          return chord;
        };
        chord.sortChords = function(x) {
          if (!arguments.length)
            return sortChords;
          sortChords = x;
          if (chords)
            resort();
          return chord;
        };
        chord.chords = function() {
          if (!chords)
            relayout();
          return chords;
        };
        chord.groups = function() {
          if (!groups)
            relayout();
          return groups;
        };
        return chord;
      };
      d3.layout.force = function() {
        var force = {},
            event = d3.dispatch("start", "tick", "end"),
            size = [1, 1],
            drag,
            alpha,
            friction = .9,
            linkDistance = d3_layout_forceLinkDistance,
            linkStrength = d3_layout_forceLinkStrength,
            charge = -30,
            chargeDistance2 = d3_layout_forceChargeDistance2,
            gravity = .1,
            theta2 = .64,
            nodes = [],
            links = [],
            distances,
            strengths,
            charges;
        function repulse(node) {
          return function(quad, x1, _, x2) {
            if (quad.point !== node) {
              var dx = quad.cx - node.x,
                  dy = quad.cy - node.y,
                  dw = x2 - x1,
                  dn = dx * dx + dy * dy;
              if (dw * dw / theta2 < dn) {
                if (dn < chargeDistance2) {
                  var k = quad.charge / dn;
                  node.px -= dx * k;
                  node.py -= dy * k;
                }
                return true;
              }
              if (quad.point && dn && dn < chargeDistance2) {
                var k = quad.pointCharge / dn;
                node.px -= dx * k;
                node.py -= dy * k;
              }
            }
            return !quad.charge;
          };
        }
        force.tick = function() {
          if ((alpha *= .99) < .005) {
            event.end({
              type: "end",
              alpha: alpha = 0
            });
            return true;
          }
          var n = nodes.length,
              m = links.length,
              q,
              i,
              o,
              s,
              t,
              l,
              k,
              x,
              y;
          for (i = 0; i < m; ++i) {
            o = links[i];
            s = o.source;
            t = o.target;
            x = t.x - s.x;
            y = t.y - s.y;
            if (l = x * x + y * y) {
              l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
              x *= l;
              y *= l;
              t.x -= x * (k = s.weight / (t.weight + s.weight));
              t.y -= y * k;
              s.x += x * (k = 1 - k);
              s.y += y * k;
            }
          }
          if (k = alpha * gravity) {
            x = size[0] / 2;
            y = size[1] / 2;
            i = -1;
            if (k)
              while (++i < n) {
                o = nodes[i];
                o.x += (x - o.x) * k;
                o.y += (y - o.y) * k;
              }
          }
          if (charge) {
            d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
            i = -1;
            while (++i < n) {
              if (!(o = nodes[i]).fixed) {
                q.visit(repulse(o));
              }
            }
          }
          i = -1;
          while (++i < n) {
            o = nodes[i];
            if (o.fixed) {
              o.x = o.px;
              o.y = o.py;
            } else {
              o.x -= (o.px - (o.px = o.x)) * friction;
              o.y -= (o.py - (o.py = o.y)) * friction;
            }
          }
          event.tick({
            type: "tick",
            alpha: alpha
          });
        };
        force.nodes = function(x) {
          if (!arguments.length)
            return nodes;
          nodes = x;
          return force;
        };
        force.links = function(x) {
          if (!arguments.length)
            return links;
          links = x;
          return force;
        };
        force.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return force;
        };
        force.linkDistance = function(x) {
          if (!arguments.length)
            return linkDistance;
          linkDistance = typeof x === "function" ? x : +x;
          return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
          if (!arguments.length)
            return linkStrength;
          linkStrength = typeof x === "function" ? x : +x;
          return force;
        };
        force.friction = function(x) {
          if (!arguments.length)
            return friction;
          friction = +x;
          return force;
        };
        force.charge = function(x) {
          if (!arguments.length)
            return charge;
          charge = typeof x === "function" ? x : +x;
          return force;
        };
        force.chargeDistance = function(x) {
          if (!arguments.length)
            return Math.sqrt(chargeDistance2);
          chargeDistance2 = x * x;
          return force;
        };
        force.gravity = function(x) {
          if (!arguments.length)
            return gravity;
          gravity = +x;
          return force;
        };
        force.theta = function(x) {
          if (!arguments.length)
            return Math.sqrt(theta2);
          theta2 = x * x;
          return force;
        };
        force.alpha = function(x) {
          if (!arguments.length)
            return alpha;
          x = +x;
          if (alpha) {
            if (x > 0)
              alpha = x;
            else
              alpha = 0;
          } else if (x > 0) {
            event.start({
              type: "start",
              alpha: alpha = x
            });
            d3.timer(force.tick);
          }
          return force;
        };
        force.start = function() {
          var i,
              n = nodes.length,
              m = links.length,
              w = size[0],
              h = size[1],
              neighbors,
              o;
          for (i = 0; i < n; ++i) {
            (o = nodes[i]).index = i;
            o.weight = 0;
          }
          for (i = 0; i < m; ++i) {
            o = links[i];
            if (typeof o.source == "number")
              o.source = nodes[o.source];
            if (typeof o.target == "number")
              o.target = nodes[o.target];
            ++o.source.weight;
            ++o.target.weight;
          }
          for (i = 0; i < n; ++i) {
            o = nodes[i];
            if (isNaN(o.x))
              o.x = position("x", w);
            if (isNaN(o.y))
              o.y = position("y", h);
            if (isNaN(o.px))
              o.px = o.x;
            if (isNaN(o.py))
              o.py = o.y;
          }
          distances = [];
          if (typeof linkDistance === "function")
            for (i = 0; i < m; ++i)
              distances[i] = +linkDistance.call(this, links[i], i);
          else
            for (i = 0; i < m; ++i)
              distances[i] = linkDistance;
          strengths = [];
          if (typeof linkStrength === "function")
            for (i = 0; i < m; ++i)
              strengths[i] = +linkStrength.call(this, links[i], i);
          else
            for (i = 0; i < m; ++i)
              strengths[i] = linkStrength;
          charges = [];
          if (typeof charge === "function")
            for (i = 0; i < n; ++i)
              charges[i] = +charge.call(this, nodes[i], i);
          else
            for (i = 0; i < n; ++i)
              charges[i] = charge;
          function position(dimension, size) {
            if (!neighbors) {
              neighbors = new Array(n);
              for (j = 0; j < n; ++j) {
                neighbors[j] = [];
              }
              for (j = 0; j < m; ++j) {
                var o = links[j];
                neighbors[o.source.index].push(o.target);
                neighbors[o.target.index].push(o.source);
              }
            }
            var candidates = neighbors[i],
                j = -1,
                l = candidates.length,
                x;
            while (++j < l)
              if (!isNaN(x = candidates[j][dimension]))
                return x;
            return Math.random() * size;
          }
          return force.resume();
        };
        force.resume = function() {
          return force.alpha(.1);
        };
        force.stop = function() {
          return force.alpha(0);
        };
        force.drag = function() {
          if (!drag)
            drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
          if (!arguments.length)
            return drag;
          this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
          d.px = d3.event.x, d.py = d3.event.y;
          force.resume();
        }
        return d3.rebind(force, event, "on");
      };
      function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
      }
      function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
      }
      function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
      }
      function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
      }
      function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0,
            cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
          var nodes = quad.nodes,
              n = nodes.length,
              i = -1,
              c;
          while (++i < n) {
            c = nodes[i];
            if (c == null)
              continue;
            d3_layout_forceAccumulate(c, alpha, charges);
            quad.charge += c.charge;
            cx += c.charge * c.cx;
            cy += c.charge * c.cy;
          }
        }
        if (quad.point) {
          if (!quad.leaf) {
            quad.point.x += Math.random() - .5;
            quad.point.y += Math.random() - .5;
          }
          var k = alpha * charges[quad.point.index];
          quad.charge += quad.pointCharge = k;
          cx += k * quad.point.x;
          cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
      }
      var d3_layout_forceLinkDistance = 20,
          d3_layout_forceLinkStrength = 1,
          d3_layout_forceChargeDistance2 = Infinity;
      d3.layout.hierarchy = function() {
        var sort = d3_layout_hierarchySort,
            children = d3_layout_hierarchyChildren,
            value = d3_layout_hierarchyValue;
        function hierarchy(root) {
          var stack = [root],
              nodes = [],
              node;
          root.depth = 0;
          while ((node = stack.pop()) != null) {
            nodes.push(node);
            if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
              var n,
                  childs,
                  child;
              while (--n >= 0) {
                stack.push(child = childs[n]);
                child.parent = node;
                child.depth = node.depth + 1;
              }
              if (value)
                node.value = 0;
              node.children = childs;
            } else {
              if (value)
                node.value = +value.call(hierarchy, node, node.depth) || 0;
              delete node.children;
            }
          }
          d3_layout_hierarchyVisitAfter(root, function(node) {
            var childs,
                parent;
            if (sort && (childs = node.children))
              childs.sort(sort);
            if (value && (parent = node.parent))
              parent.value += node.value;
          });
          return nodes;
        }
        hierarchy.sort = function(x) {
          if (!arguments.length)
            return sort;
          sort = x;
          return hierarchy;
        };
        hierarchy.children = function(x) {
          if (!arguments.length)
            return children;
          children = x;
          return hierarchy;
        };
        hierarchy.value = function(x) {
          if (!arguments.length)
            return value;
          value = x;
          return hierarchy;
        };
        hierarchy.revalue = function(root) {
          if (value) {
            d3_layout_hierarchyVisitBefore(root, function(node) {
              if (node.children)
                node.value = 0;
            });
            d3_layout_hierarchyVisitAfter(root, function(node) {
              var parent;
              if (!node.children)
                node.value = +value.call(hierarchy, node, node.depth) || 0;
              if (parent = node.parent)
                parent.value += node.value;
            });
          }
          return root;
        };
        return hierarchy;
      };
      function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
      }
      function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [node];
        while ((node = nodes.pop()) != null) {
          callback(node);
          if ((children = node.children) && (n = children.length)) {
            var n,
                children;
            while (--n >= 0)
              nodes.push(children[n]);
          }
        }
      }
      function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [node],
            nodes2 = [];
        while ((node = nodes.pop()) != null) {
          nodes2.push(node);
          if ((children = node.children) && (n = children.length)) {
            var i = -1,
                n,
                children;
            while (++i < n)
              nodes.push(children[i]);
          }
        }
        while ((node = nodes2.pop()) != null) {
          callback(node);
        }
      }
      function d3_layout_hierarchyChildren(d) {
        return d.children;
      }
      function d3_layout_hierarchyValue(d) {
        return d.value;
      }
      function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
      }
      function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
          return (parent.children || []).map(function(child) {
            return {
              source: parent,
              target: child
            };
          });
        }));
      }
      d3.layout.partition = function() {
        var hierarchy = d3.layout.hierarchy(),
            size = [1, 1];
        function position(node, x, dx, dy) {
          var children = node.children;
          node.x = x;
          node.y = node.depth * dy;
          node.dx = dx;
          node.dy = dy;
          if (children && (n = children.length)) {
            var i = -1,
                n,
                c,
                d;
            dx = node.value ? dx / node.value : 0;
            while (++i < n) {
              position(c = children[i], x, d = c.value * dx, dy);
              x += d;
            }
          }
        }
        function depth(node) {
          var children = node.children,
              d = 0;
          if (children && (n = children.length)) {
            var i = -1,
                n;
            while (++i < n)
              d = Math.max(d, depth(children[i]));
          }
          return 1 + d;
        }
        function partition(d, i) {
          var nodes = hierarchy.call(this, d, i);
          position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
          return nodes;
        }
        partition.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
      };
      d3.layout.pie = function() {
        var value = Number,
            sort = d3_layout_pieSortByValue,
            startAngle = 0,
            endAngle = τ,
            padAngle = 0;
        function pie(data) {
          var n = data.length,
              values = data.map(function(d, i) {
                return +value.call(pie, d, i);
              }),
              a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle),
              da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a,
              p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)),
              pa = p * (da < 0 ? -1 : 1),
              k = (da - n * pa) / d3.sum(values),
              index = d3.range(n),
              arcs = [],
              v;
          if (sort != null)
            index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
              return values[j] - values[i];
            } : function(i, j) {
              return sort(data[i], data[j]);
            });
          index.forEach(function(i) {
            arcs[i] = {
              data: data[i],
              value: v = values[i],
              startAngle: a,
              endAngle: a += v * k + pa,
              padAngle: p
            };
          });
          return arcs;
        }
        pie.value = function(_) {
          if (!arguments.length)
            return value;
          value = _;
          return pie;
        };
        pie.sort = function(_) {
          if (!arguments.length)
            return sort;
          sort = _;
          return pie;
        };
        pie.startAngle = function(_) {
          if (!arguments.length)
            return startAngle;
          startAngle = _;
          return pie;
        };
        pie.endAngle = function(_) {
          if (!arguments.length)
            return endAngle;
          endAngle = _;
          return pie;
        };
        pie.padAngle = function(_) {
          if (!arguments.length)
            return padAngle;
          padAngle = _;
          return pie;
        };
        return pie;
      };
      var d3_layout_pieSortByValue = {};
      d3.layout.stack = function() {
        var values = d3_identity,
            order = d3_layout_stackOrderDefault,
            offset = d3_layout_stackOffsetZero,
            out = d3_layout_stackOut,
            x = d3_layout_stackX,
            y = d3_layout_stackY;
        function stack(data, index) {
          if (!(n = data.length))
            return data;
          var series = data.map(function(d, i) {
            return values.call(stack, d, i);
          });
          var points = series.map(function(d) {
            return d.map(function(v, i) {
              return [x.call(stack, v, i), y.call(stack, v, i)];
            });
          });
          var orders = order.call(stack, points, index);
          series = d3.permute(series, orders);
          points = d3.permute(points, orders);
          var offsets = offset.call(stack, points, index);
          var m = series[0].length,
              n,
              i,
              j,
              o;
          for (j = 0; j < m; ++j) {
            out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
            for (i = 1; i < n; ++i) {
              out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
            }
          }
          return data;
        }
        stack.values = function(x) {
          if (!arguments.length)
            return values;
          values = x;
          return stack;
        };
        stack.order = function(x) {
          if (!arguments.length)
            return order;
          order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
          return stack;
        };
        stack.offset = function(x) {
          if (!arguments.length)
            return offset;
          offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
          return stack;
        };
        stack.x = function(z) {
          if (!arguments.length)
            return x;
          x = z;
          return stack;
        };
        stack.y = function(z) {
          if (!arguments.length)
            return y;
          y = z;
          return stack;
        };
        stack.out = function(z) {
          if (!arguments.length)
            return out;
          out = z;
          return stack;
        };
        return stack;
      };
      function d3_layout_stackX(d) {
        return d.x;
      }
      function d3_layout_stackY(d) {
        return d.y;
      }
      function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
      }
      var d3_layout_stackOrders = d3.map({
        "inside-out": function(data) {
          var n = data.length,
              i,
              j,
              max = data.map(d3_layout_stackMaxIndex),
              sums = data.map(d3_layout_stackReduceSum),
              index = d3.range(n).sort(function(a, b) {
                return max[a] - max[b];
              }),
              top = 0,
              bottom = 0,
              tops = [],
              bottoms = [];
          for (i = 0; i < n; ++i) {
            j = index[i];
            if (top < bottom) {
              top += sums[j];
              tops.push(j);
            } else {
              bottom += sums[j];
              bottoms.push(j);
            }
          }
          return bottoms.reverse().concat(tops);
        },
        reverse: function(data) {
          return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
      });
      var d3_layout_stackOffsets = d3.map({
        silhouette: function(data) {
          var n = data.length,
              m = data[0].length,
              sums = [],
              max = 0,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++)
              o += data[i][j][1];
            if (o > max)
              max = o;
            sums.push(o);
          }
          for (j = 0; j < m; ++j) {
            y0[j] = (max - sums[j]) / 2;
          }
          return y0;
        },
        wiggle: function(data) {
          var n = data.length,
              x = data[0],
              m = x.length,
              i,
              j,
              k,
              s1,
              s2,
              s3,
              dx,
              o,
              o0,
              y0 = [];
          y0[0] = o = o0 = 0;
          for (j = 1; j < m; ++j) {
            for (i = 0, s1 = 0; i < n; ++i)
              s1 += data[i][j][1];
            for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
              for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
              }
              s2 += s3 * data[i][j][1];
            }
            y0[j] = o -= s1 ? s2 / s1 * dx : 0;
            if (o < o0)
              o0 = o;
          }
          for (j = 0; j < m; ++j)
            y0[j] -= o0;
          return y0;
        },
        expand: function(data) {
          var n = data.length,
              m = data[0].length,
              k = 1 / n,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++)
              o += data[i][j][1];
            if (o)
              for (i = 0; i < n; i++)
                data[i][j][1] /= o;
            else
              for (i = 0; i < n; i++)
                data[i][j][1] = k;
          }
          for (j = 0; j < m; ++j)
            y0[j] = 0;
          return y0;
        },
        zero: d3_layout_stackOffsetZero
      });
      function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
      }
      function d3_layout_stackOffsetZero(data) {
        var j = -1,
            m = data[0].length,
            y0 = [];
        while (++j < m)
          y0[j] = 0;
        return y0;
      }
      function d3_layout_stackMaxIndex(array) {
        var i = 1,
            j = 0,
            v = array[0][1],
            k,
            n = array.length;
        for (; i < n; ++i) {
          if ((k = array[i][1]) > v) {
            j = i;
            v = k;
          }
        }
        return j;
      }
      function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
      }
      function d3_layout_stackSum(p, d) {
        return p + d[1];
      }
      d3.layout.histogram = function() {
        var frequency = true,
            valuer = Number,
            ranger = d3_layout_histogramRange,
            binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
          var bins = [],
              values = data.map(valuer, this),
              range = ranger.call(this, values, i),
              thresholds = binner.call(this, range, values, i),
              bin,
              i = -1,
              n = values.length,
              m = thresholds.length - 1,
              k = frequency ? 1 : 1 / n,
              x;
          while (++i < m) {
            bin = bins[i] = [];
            bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
            bin.y = 0;
          }
          if (m > 0) {
            i = -1;
            while (++i < n) {
              x = values[i];
              if (x >= range[0] && x <= range[1]) {
                bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                bin.y += k;
                bin.push(data[i]);
              }
            }
          }
          return bins;
        }
        histogram.value = function(x) {
          if (!arguments.length)
            return valuer;
          valuer = x;
          return histogram;
        };
        histogram.range = function(x) {
          if (!arguments.length)
            return ranger;
          ranger = d3_functor(x);
          return histogram;
        };
        histogram.bins = function(x) {
          if (!arguments.length)
            return binner;
          binner = typeof x === "number" ? function(range) {
            return d3_layout_histogramBinFixed(range, x);
          } : d3_functor(x);
          return histogram;
        };
        histogram.frequency = function(x) {
          if (!arguments.length)
            return frequency;
          frequency = !!x;
          return histogram;
        };
        return histogram;
      };
      function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
      }
      function d3_layout_histogramBinFixed(range, n) {
        var x = -1,
            b = +range[0],
            m = (range[1] - b) / n,
            f = [];
        while (++x <= n)
          f[x] = m * x + b;
        return f;
      }
      function d3_layout_histogramRange(values) {
        return [d3.min(values), d3.max(values)];
      }
      d3.layout.pack = function() {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),
            padding = 0,
            size = [1, 1],
            radius;
        function pack(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              w = size[0],
              h = size[1],
              r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                return radius;
              };
          root.x = root.y = 0;
          d3_layout_hierarchyVisitAfter(root, function(d) {
            d.r = +r(d.value);
          });
          d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
          if (padding) {
            var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
            d3_layout_hierarchyVisitAfter(root, function(d) {
              d.r += dr;
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            d3_layout_hierarchyVisitAfter(root, function(d) {
              d.r -= dr;
            });
          }
          d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
          return nodes;
        }
        pack.size = function(_) {
          if (!arguments.length)
            return size;
          size = _;
          return pack;
        };
        pack.radius = function(_) {
          if (!arguments.length)
            return radius;
          radius = _ == null || typeof _ === "function" ? _ : +_;
          return pack;
        };
        pack.padding = function(_) {
          if (!arguments.length)
            return padding;
          padding = +_;
          return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
      };
      function d3_layout_packSort(a, b) {
        return a.value - b.value;
      }
      function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
      }
      function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
      }
      function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x,
            dy = b.y - a.y,
            dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy;
      }
      function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length))
          return;
        var nodes,
            xMin = Infinity,
            xMax = -Infinity,
            yMin = Infinity,
            yMax = -Infinity,
            a,
            b,
            c,
            i,
            j,
            k,
            n;
        function bound(node) {
          xMin = Math.min(node.x - node.r, xMin);
          xMax = Math.max(node.x + node.r, xMax);
          yMin = Math.min(node.y - node.r, yMin);
          yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
          b = nodes[1];
          b.x = b.r;
          b.y = 0;
          bound(b);
          if (n > 2) {
            c = nodes[2];
            d3_layout_packPlace(a, b, c);
            bound(c);
            d3_layout_packInsert(a, c);
            a._pack_prev = c;
            d3_layout_packInsert(c, b);
            b = a._pack_next;
            for (i = 3; i < n; i++) {
              d3_layout_packPlace(a, b, c = nodes[i]);
              var isect = 0,
                  s1 = 1,
                  s2 = 1;
              for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                if (d3_layout_packIntersects(j, c)) {
                  isect = 1;
                  break;
                }
              }
              if (isect == 1) {
                for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                  if (d3_layout_packIntersects(k, c)) {
                    break;
                  }
                }
              }
              if (isect) {
                if (s1 < s2 || s1 == s2 && b.r < a.r)
                  d3_layout_packSplice(a, b = j);
                else
                  d3_layout_packSplice(a = k, b);
                i--;
              } else {
                d3_layout_packInsert(a, c);
                b = c;
                bound(c);
              }
            }
          }
        }
        var cx = (xMin + xMax) / 2,
            cy = (yMin + yMax) / 2,
            cr = 0;
        for (i = 0; i < n; i++) {
          c = nodes[i];
          c.x -= cx;
          c.y -= cy;
          cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
      }
      function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
      }
      function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
      }
      function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
          var i = -1,
              n = children.length;
          while (++i < n)
            d3_layout_packTransform(children[i], x, y, k);
        }
      }
      function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r,
            dx = b.x - a.x,
            dy = b.y - a.y;
        if (db && (dx || dy)) {
          var da = b.r + c.r,
              dc = dx * dx + dy * dy;
          da *= da;
          db *= db;
          var x = .5 + (db - da) / (2 * dc),
              y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
          c.x = a.x + x * dx + y * dy;
          c.y = a.y + x * dy - y * dx;
        } else {
          c.x = a.x + db;
          c.y = a.y;
        }
      }
      d3.layout.tree = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = null;
        function tree(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root0 = nodes[0],
              root1 = wrapTree(root0);
          d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
          d3_layout_hierarchyVisitBefore(root1, secondWalk);
          if (nodeSize)
            d3_layout_hierarchyVisitBefore(root0, sizeNode);
          else {
            var left = root0,
                right = root0,
                bottom = root0;
            d3_layout_hierarchyVisitBefore(root0, function(node) {
              if (node.x < left.x)
                left = node;
              if (node.x > right.x)
                right = node;
              if (node.depth > bottom.depth)
                bottom = node;
            });
            var tx = separation(left, right) / 2 - left.x,
                kx = size[0] / (right.x + separation(right, left) / 2 + tx),
                ky = size[1] / (bottom.depth || 1);
            d3_layout_hierarchyVisitBefore(root0, function(node) {
              node.x = (node.x + tx) * kx;
              node.y = node.depth * ky;
            });
          }
          return nodes;
        }
        function wrapTree(root0) {
          var root1 = {
            A: null,
            children: [root0]
          },
              queue = [root1],
              node1;
          while ((node1 = queue.pop()) != null) {
            for (var children = node1.children,
                child,
                i = 0,
                n = children.length; i < n; ++i) {
              queue.push((children[i] = child = {
                _: children[i],
                parent: node1,
                children: (child = children[i].children) && child.slice() || [],
                A: null,
                a: null,
                z: 0,
                m: 0,
                c: 0,
                s: 0,
                t: null,
                i: i
              }).a = child);
            }
          }
          return root1.children[0];
        }
        function firstWalk(v) {
          var children = v.children,
              siblings = v.parent.children,
              w = v.i ? siblings[v.i - 1] : null;
          if (children.length) {
            d3_layout_treeShift(v);
            var midpoint = (children[0].z + children[children.length - 1].z) / 2;
            if (w) {
              v.z = w.z + separation(v._, w._);
              v.m = v.z - midpoint;
            } else {
              v.z = midpoint;
            }
          } else if (w) {
            v.z = w.z + separation(v._, w._);
          }
          v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
          v._.x = v.z + v.parent.m;
          v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
          if (w) {
            var vip = v,
                vop = v,
                vim = w,
                vom = vip.parent.children[0],
                sip = vip.m,
                sop = vop.m,
                sim = vim.m,
                som = vom.m,
                shift;
            while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
              vom = d3_layout_treeLeft(vom);
              vop = d3_layout_treeRight(vop);
              vop.a = v;
              shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
              if (shift > 0) {
                d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                sip += shift;
                sop += shift;
              }
              sim += vim.m;
              sip += vip.m;
              som += vom.m;
              sop += vop.m;
            }
            if (vim && !d3_layout_treeRight(vop)) {
              vop.t = vim;
              vop.m += sim - sop;
            }
            if (vip && !d3_layout_treeLeft(vom)) {
              vom.t = vip;
              vom.m += sip - som;
              ancestor = v;
            }
          }
          return ancestor;
        }
        function sizeNode(node) {
          node.x *= size[0];
          node.y = node.depth * size[1];
        }
        tree.separation = function(x) {
          if (!arguments.length)
            return separation;
          separation = x;
          return tree;
        };
        tree.size = function(x) {
          if (!arguments.length)
            return nodeSize ? null : size;
          nodeSize = (size = x) == null ? sizeNode : null;
          return tree;
        };
        tree.nodeSize = function(x) {
          if (!arguments.length)
            return nodeSize ? size : null;
          nodeSize = (size = x) == null ? null : sizeNode;
          return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
      };
      function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
      }
      function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
      }
      function d3_layout_treeRight(v) {
        var children = v.children,
            n;
        return (n = children.length) ? children[n - 1] : v.t;
      }
      function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
      }
      function d3_layout_treeShift(v) {
        var shift = 0,
            change = 0,
            children = v.children,
            i = children.length,
            w;
        while (--i >= 0) {
          w = children[i];
          w.z += shift;
          w.m += shift;
          shift += w.s + (change += w.c);
        }
      }
      function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
      }
      d3.layout.cluster = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = false;
        function cluster(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              previousNode,
              x = 0;
          d3_layout_hierarchyVisitAfter(root, function(node) {
            var children = node.children;
            if (children && children.length) {
              node.x = d3_layout_clusterX(children);
              node.y = d3_layout_clusterY(children);
            } else {
              node.x = previousNode ? x += separation(node, previousNode) : 0;
              node.y = 0;
              previousNode = node;
            }
          });
          var left = d3_layout_clusterLeft(root),
              right = d3_layout_clusterRight(root),
              x0 = left.x - separation(left, right) / 2,
              x1 = right.x + separation(right, left) / 2;
          d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
            node.x = (node.x - root.x) * size[0];
            node.y = (root.y - node.y) * size[1];
          } : function(node) {
            node.x = (node.x - x0) / (x1 - x0) * size[0];
            node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
          });
          return nodes;
        }
        cluster.separation = function(x) {
          if (!arguments.length)
            return separation;
          separation = x;
          return cluster;
        };
        cluster.size = function(x) {
          if (!arguments.length)
            return nodeSize ? null : size;
          nodeSize = (size = x) == null;
          return cluster;
        };
        cluster.nodeSize = function(x) {
          if (!arguments.length)
            return nodeSize ? size : null;
          nodeSize = (size = x) != null;
          return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
      };
      function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function(child) {
          return child.y;
        });
      }
      function d3_layout_clusterX(children) {
        return children.reduce(function(x, child) {
          return x + child.x;
        }, 0) / children.length;
      }
      function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
      }
      function d3_layout_clusterRight(node) {
        var children = node.children,
            n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
      }
      d3.layout.treemap = function() {
        var hierarchy = d3.layout.hierarchy(),
            round = Math.round,
            size = [1, 1],
            padding = null,
            pad = d3_layout_treemapPadNull,
            sticky = false,
            stickies,
            mode = "squarify",
            ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
          var i = -1,
              n = children.length,
              child,
              area;
          while (++i < n) {
            area = (child = children[i]).value * (k < 0 ? 0 : k);
            child.area = isNaN(area) || area <= 0 ? 0 : area;
          }
        }
        function squarify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                row = [],
                remaining = children.slice(),
                child,
                best = Infinity,
                score,
                u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy),
                n;
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while ((n = remaining.length) > 0) {
              row.push(child = remaining[n - 1]);
              row.area += child.area;
              if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                remaining.pop();
                best = score;
              } else {
                row.area -= row.pop().area;
                position(row, u, rect, false);
                u = Math.min(rect.dx, rect.dy);
                row.length = row.area = 0;
                best = Infinity;
              }
            }
            if (row.length) {
              position(row, u, rect, true);
              row.length = row.area = 0;
            }
            children.forEach(squarify);
          }
        }
        function stickify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                remaining = children.slice(),
                child,
                row = [];
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while (child = remaining.pop()) {
              row.push(child);
              row.area += child.area;
              if (child.z != null) {
                position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                row.length = row.area = 0;
              }
            }
            children.forEach(stickify);
          }
        }
        function worst(row, u) {
          var s = row.area,
              r,
              rmax = 0,
              rmin = Infinity,
              i = -1,
              n = row.length;
          while (++i < n) {
            if (!(r = row[i].area))
              continue;
            if (r < rmin)
              rmin = r;
            if (r > rmax)
              rmax = r;
          }
          s *= s;
          u *= u;
          return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
          var i = -1,
              n = row.length,
              x = rect.x,
              y = rect.y,
              v = u ? round(row.area / u) : 0,
              o;
          if (u == rect.dx) {
            if (flush || v > rect.dy)
              v = rect.dy;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dy = v;
              x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
            }
            o.z = true;
            o.dx += rect.x + rect.dx - x;
            rect.y += v;
            rect.dy -= v;
          } else {
            if (flush || v > rect.dx)
              v = rect.dx;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dx = v;
              y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
            }
            o.z = false;
            o.dy += rect.y + rect.dy - y;
            rect.x += v;
            rect.dx -= v;
          }
        }
        function treemap(d) {
          var nodes = stickies || hierarchy(d),
              root = nodes[0];
          root.x = 0;
          root.y = 0;
          root.dx = size[0];
          root.dy = size[1];
          if (stickies)
            hierarchy.revalue(root);
          scale([root], root.dx * root.dy / root.value);
          (stickies ? stickify : squarify)(root);
          if (sticky)
            stickies = nodes;
          return nodes;
        }
        treemap.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return treemap;
        };
        treemap.padding = function(x) {
          if (!arguments.length)
            return padding;
          function padFunction(node) {
            var p = x.call(treemap, node, node.depth);
            return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
          }
          function padConstant(node) {
            return d3_layout_treemapPad(node, x);
          }
          var type;
          pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [x, x, x, x], padConstant) : padConstant;
          return treemap;
        };
        treemap.round = function(x) {
          if (!arguments.length)
            return round != Number;
          round = x ? Math.round : Number;
          return treemap;
        };
        treemap.sticky = function(x) {
          if (!arguments.length)
            return sticky;
          sticky = x;
          stickies = null;
          return treemap;
        };
        treemap.ratio = function(x) {
          if (!arguments.length)
            return ratio;
          ratio = x;
          return treemap;
        };
        treemap.mode = function(x) {
          if (!arguments.length)
            return mode;
          mode = x + "";
          return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
      };
      function d3_layout_treemapPadNull(node) {
        return {
          x: node.x,
          y: node.y,
          dx: node.dx,
          dy: node.dy
        };
      }
      function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3],
            y = node.y + padding[0],
            dx = node.dx - padding[1] - padding[3],
            dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
          x += dx / 2;
          dx = 0;
        }
        if (dy < 0) {
          y += dy / 2;
          dy = 0;
        }
        return {
          x: x,
          y: y,
          dx: dx,
          dy: dy
        };
      }
      d3.random = {
        normal: function(µ, σ) {
          var n = arguments.length;
          if (n < 2)
            σ = 1;
          if (n < 1)
            µ = 0;
          return function() {
            var x,
                y,
                r;
            do {
              x = Math.random() * 2 - 1;
              y = Math.random() * 2 - 1;
              r = x * x + y * y;
            } while (!r || r > 1);
            return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
          };
        },
        logNormal: function() {
          var random = d3.random.normal.apply(d3, arguments);
          return function() {
            return Math.exp(random());
          };
        },
        bates: function(m) {
          var random = d3.random.irwinHall(m);
          return function() {
            return random() / m;
          };
        },
        irwinHall: function(m) {
          return function() {
            for (var s = 0,
                j = 0; j < m; j++)
              s += Math.random();
            return s;
          };
        }
      };
      d3.scale = {};
      function d3_scaleExtent(domain) {
        var start = domain[0],
            stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
      }
      function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
      }
      function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]),
            i = interpolate(range[0], range[1]);
        return function(x) {
          return i(u(x));
        };
      }
      function d3_scale_nice(domain, nice) {
        var i0 = 0,
            i1 = domain.length - 1,
            x0 = domain[i0],
            x1 = domain[i1],
            dx;
        if (x1 < x0) {
          dx = i0, i0 = i1, i1 = dx;
          dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
      }
      function d3_scale_niceStep(step) {
        return step ? {
          floor: function(x) {
            return Math.floor(x / step) * step;
          },
          ceil: function(x) {
            return Math.ceil(x / step) * step;
          }
        } : d3_scale_niceIdentity;
      }
      var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
      };
      function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [],
            i = [],
            j = 0,
            k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
          domain = domain.slice().reverse();
          range = range.slice().reverse();
        }
        while (++j <= k) {
          u.push(uninterpolate(domain[j - 1], domain[j]));
          i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
          var j = d3.bisect(domain, x, 1, k) - 1;
          return i[j](u[j](x));
        };
      }
      d3.scale.linear = function() {
        return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
      };
      function d3_scale_linear(domain, range, interpolate, clamp) {
        var output,
            input;
        function rescale() {
          var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,
              uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
          output = linear(domain, range, uninterpolate, interpolate);
          input = linear(range, domain, uninterpolate, d3_interpolate);
          return scale;
        }
        function scale(x) {
          return output(x);
        }
        scale.invert = function(y) {
          return input(y);
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(Number);
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.rangeRound = function(x) {
          return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function(x) {
          if (!arguments.length)
            return clamp;
          clamp = x;
          return rescale();
        };
        scale.interpolate = function(x) {
          if (!arguments.length)
            return interpolate;
          interpolate = x;
          return rescale();
        };
        scale.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
          d3_scale_linearNice(domain, m);
          return rescale();
        };
        scale.copy = function() {
          return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
      }
      function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
      }
      function d3_scale_linearNice(domain, m) {
        return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
      }
      function d3_scale_linearTickRange(domain, m) {
        if (m == null)
          m = 10;
        var extent = d3_scaleExtent(domain),
            span = extent[1] - extent[0],
            step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),
            err = m / span * step;
        if (err <= .15)
          step *= 10;
        else if (err <= .35)
          step *= 5;
        else if (err <= .75)
          step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
      }
      function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
      }
      function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
          var match = d3_format_re.exec(format);
          match.shift();
          if (match[8] === "s") {
            var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
            if (!match[7])
              match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
            match[8] = "f";
            format = d3.format(match.join(""));
            return function(d) {
              return format(prefix.scale(d)) + prefix.symbol;
            };
          }
          if (!match[7])
            match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
          format = match.join("");
        } else {
          format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        }
        return d3.format(format);
      }
      var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
      };
      function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + .01);
      }
      function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
      }
      d3.scale.log = function() {
        return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);
      };
      function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
          return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
          return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
          return linear(log(x));
        }
        scale.invert = function(x) {
          return pow(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          positive = x[0] >= 0;
          linear.domain((domain = x.map(Number)).map(log));
          return scale;
        };
        scale.base = function(_) {
          if (!arguments.length)
            return base;
          base = +_;
          linear.domain(domain.map(log));
          return scale;
        };
        scale.nice = function() {
          var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
          linear.domain(niced);
          domain = niced.map(pow);
          return scale;
        };
        scale.ticks = function() {
          var extent = d3_scaleExtent(domain),
              ticks = [],
              u = extent[0],
              v = extent[1],
              i = Math.floor(log(u)),
              j = Math.ceil(log(v)),
              n = base % 1 ? 2 : base;
          if (isFinite(j - i)) {
            if (positive) {
              for (; i < j; i++)
                for (var k = 1; k < n; k++)
                  ticks.push(pow(i) * k);
              ticks.push(pow(i));
            } else {
              ticks.push(pow(i));
              for (; i++ < j; )
                for (var k = n - 1; k > 0; k--)
                  ticks.push(pow(i) * k);
            }
            for (i = 0; ticks[i] < u; i++) {}
            for (j = ticks.length; ticks[j - 1] > v; j--) {}
            ticks = ticks.slice(i, j);
          }
          return ticks;
        };
        scale.tickFormat = function(n, format) {
          if (!arguments.length)
            return d3_scale_logFormat;
          if (arguments.length < 2)
            format = d3_scale_logFormat;
          else if (typeof format !== "function")
            format = d3.format(format);
          var k = Math.max(.1, n / scale.ticks().length),
              f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor),
              e;
          return function(d) {
            return d / pow(f(log(d) + e)) <= k ? format(d) : "";
          };
        };
        scale.copy = function() {
          return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      var d3_scale_logFormat = d3.format(".0e"),
          d3_scale_logNiceNegative = {
            floor: function(x) {
              return -Math.ceil(-x);
            },
            ceil: function(x) {
              return -Math.floor(-x);
            }
          };
      d3.scale.pow = function() {
        return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);
      };
      function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent),
            powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
          return linear(powp(x));
        }
        scale.invert = function(x) {
          return powb(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          linear.domain((domain = x.map(Number)).map(powp));
          return scale;
        };
        scale.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
          return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function(x) {
          if (!arguments.length)
            return exponent;
          powp = d3_scale_powPow(exponent = x);
          powb = d3_scale_powPow(1 / exponent);
          linear.domain(domain.map(powp));
          return scale;
        };
        scale.copy = function() {
          return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_scale_powPow(e) {
        return function(x) {
          return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
      }
      d3.scale.sqrt = function() {
        return d3.scale.pow().exponent(.5);
      };
      d3.scale.ordinal = function() {
        return d3_scale_ordinal([], {
          t: "range",
          a: [[]]
        });
      };
      function d3_scale_ordinal(domain, ranger) {
        var index,
            range,
            rangeBand;
        function scale(x) {
          return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
          return d3.range(domain.length).map(function(i) {
            return start + step * i;
          });
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = [];
          index = new d3_Map();
          var i = -1,
              n = x.length,
              xi;
          while (++i < n)
            if (!index.has(xi = x[i]))
              index.set(xi, domain.push(xi));
          return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          rangeBand = 0;
          ranger = {
            t: "range",
            a: arguments
          };
          return scale;
        };
        scale.rangePoints = function(x, padding) {
          if (arguments.length < 2)
            padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
          range = steps(start + step * padding / 2, step);
          rangeBand = 0;
          ranger = {
            t: "rangePoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundPoints = function(x, padding) {
          if (arguments.length < 2)
            padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
          range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
          rangeBand = 0;
          ranger = {
            t: "rangeRoundPoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeBands = function(x, padding, outerPadding) {
          if (arguments.length < 2)
            padding = 0;
          if (arguments.length < 3)
            outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = (stop - start) / (domain.length - padding + 2 * outerPadding);
          range = steps(start + step * outerPadding, step);
          if (reverse)
            range.reverse();
          rangeBand = step * (1 - padding);
          ranger = {
            t: "rangeBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundBands = function(x, padding, outerPadding) {
          if (arguments.length < 2)
            padding = 0;
          if (arguments.length < 3)
            outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
          range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
          if (reverse)
            range.reverse();
          rangeBand = Math.round(step * (1 - padding));
          ranger = {
            t: "rangeRoundBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeBand = function() {
          return rangeBand;
        };
        scale.rangeExtent = function() {
          return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function() {
          return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
      }
      d3.scale.category10 = function() {
        return d3.scale.ordinal().range(d3_category10);
      };
      d3.scale.category20 = function() {
        return d3.scale.ordinal().range(d3_category20);
      };
      d3.scale.category20b = function() {
        return d3.scale.ordinal().range(d3_category20b);
      };
      d3.scale.category20c = function() {
        return d3.scale.ordinal().range(d3_category20c);
      };
      var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
      var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
      var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
      var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
      d3.scale.quantile = function() {
        return d3_scale_quantile([], []);
      };
      function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
          var k = 0,
              q = range.length;
          thresholds = [];
          while (++k < q)
            thresholds[k - 1] = d3.quantile(domain, k / q);
          return scale;
        }
        function scale(x) {
          if (!isNaN(x = +x))
            return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.quantiles = function() {
          return thresholds;
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];
        };
        scale.copy = function() {
          return d3_scale_quantile(domain, range);
        };
        return rescale();
      }
      d3.scale.quantize = function() {
        return d3_scale_quantize(0, 1, [0, 1]);
      };
      function d3_scale_quantize(x0, x1, range) {
        var kx,
            i;
        function scale(x) {
          return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
          kx = range.length / (x1 - x0);
          i = range.length - 1;
          return scale;
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return [x0, x1];
          x0 = +x[0];
          x1 = +x[x.length - 1];
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          y = y < 0 ? NaN : y / kx + x0;
          return [y, y + 1 / kx];
        };
        scale.copy = function() {
          return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
      }
      d3.scale.threshold = function() {
        return d3_scale_threshold([.5], [0, 1]);
      };
      function d3_scale_threshold(domain, range) {
        function scale(x) {
          if (x <= x)
            return range[d3.bisect(domain, x)];
        }
        scale.domain = function(_) {
          if (!arguments.length)
            return domain;
          domain = _;
          return scale;
        };
        scale.range = function(_) {
          if (!arguments.length)
            return range;
          range = _;
          return scale;
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          return [domain[y - 1], domain[y]];
        };
        scale.copy = function() {
          return d3_scale_threshold(domain, range);
        };
        return scale;
      }
      d3.scale.identity = function() {
        return d3_scale_identity([0, 1]);
      };
      function d3_scale_identity(domain) {
        function identity(x) {
          return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(identity);
          return identity;
        };
        identity.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function() {
          return d3_scale_identity(domain);
        };
        return identity;
      }
      d3.svg = {};
      function d3_zero() {
        return 0;
      }
      d3.svg.arc = function() {
        var innerRadius = d3_svg_arcInnerRadius,
            outerRadius = d3_svg_arcOuterRadius,
            cornerRadius = d3_zero,
            padRadius = d3_svg_arcAuto,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle,
            padAngle = d3_svg_arcPadAngle;
        function arc() {
          var r0 = Math.max(0, +innerRadius.apply(this, arguments)),
              r1 = Math.max(0, +outerRadius.apply(this, arguments)),
              a0 = startAngle.apply(this, arguments) - halfπ,
              a1 = endAngle.apply(this, arguments) - halfπ,
              da = Math.abs(a1 - a0),
              cw = a0 > a1 ? 0 : 1;
          if (r1 < r0)
            rc = r1, r1 = r0, r0 = rc;
          if (da >= τε)
            return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
          var rc,
              cr,
              rp,
              ap,
              p0 = 0,
              p1 = 0,
              x0,
              y0,
              x1,
              y1,
              x2,
              y2,
              x3,
              y3,
              path = [];
          if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
            rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
            if (!cw)
              p1 *= -1;
            if (r1)
              p1 = d3_asin(rp / r1 * Math.sin(ap));
            if (r0)
              p0 = d3_asin(rp / r0 * Math.sin(ap));
          }
          if (r1) {
            x0 = r1 * Math.cos(a0 + p1);
            y0 = r1 * Math.sin(a0 + p1);
            x1 = r1 * Math.cos(a1 - p1);
            y1 = r1 * Math.sin(a1 - p1);
            var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
            if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
              var h1 = (a0 + a1) / 2;
              x0 = r1 * Math.cos(h1);
              y0 = r1 * Math.sin(h1);
              x1 = y1 = null;
            }
          } else {
            x0 = y0 = 0;
          }
          if (r0) {
            x2 = r0 * Math.cos(a1 - p0);
            y2 = r0 * Math.sin(a1 - p0);
            x3 = r0 * Math.cos(a0 + p0);
            y3 = r0 * Math.sin(a0 + p0);
            var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
            if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
              var h0 = (a0 + a1) / 2;
              x2 = r0 * Math.cos(h0);
              y2 = r0 * Math.sin(h0);
              x3 = y3 = null;
            }
          } else {
            x2 = y2 = 0;
          }
          if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
            cr = r0 < r1 ^ cw ? 0 : 1;
            var oc = x3 == null ? [x2, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]),
                ax = x0 - oc[0],
                ay = y0 - oc[1],
                bx = x1 - oc[0],
                by = y1 - oc[1],
                kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
                lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            if (x1 != null) {
              var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)),
                  t30 = d3_svg_arcCornerTangents(x3 == null ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw),
                  t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
              if (rc === rc1) {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
              } else {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
              }
            } else {
              path.push("M", x0, ",", y0);
            }
            if (x3 != null) {
              var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)),
                  t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw),
                  t21 = d3_svg_arcCornerTangents([x2, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);
              if (rc === rc0) {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              } else {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              }
            } else {
              path.push("L", x2, ",", y2);
            }
          } else {
            path.push("M", x0, ",", y0);
            if (x1 != null)
              path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
            path.push("L", x2, ",", y2);
            if (x3 != null)
              path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
          }
          path.push("Z");
          return path.join("");
        }
        function circleSegment(r1, cw) {
          return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }
        arc.innerRadius = function(v) {
          if (!arguments.length)
            return innerRadius;
          innerRadius = d3_functor(v);
          return arc;
        };
        arc.outerRadius = function(v) {
          if (!arguments.length)
            return outerRadius;
          outerRadius = d3_functor(v);
          return arc;
        };
        arc.cornerRadius = function(v) {
          if (!arguments.length)
            return cornerRadius;
          cornerRadius = d3_functor(v);
          return arc;
        };
        arc.padRadius = function(v) {
          if (!arguments.length)
            return padRadius;
          padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
          return arc;
        };
        arc.startAngle = function(v) {
          if (!arguments.length)
            return startAngle;
          startAngle = d3_functor(v);
          return arc;
        };
        arc.endAngle = function(v) {
          if (!arguments.length)
            return endAngle;
          endAngle = d3_functor(v);
          return arc;
        };
        arc.padAngle = function(v) {
          if (!arguments.length)
            return padAngle;
          padAngle = d3_functor(v);
          return arc;
        };
        arc.centroid = function() {
          var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
              a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
          return [Math.cos(a) * r, Math.sin(a) * r];
        };
        return arc;
      };
      var d3_svg_arcAuto = "auto";
      function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
      }
      function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
      }
      function d3_svg_arcStartAngle(d) {
        return d.startAngle;
      }
      function d3_svg_arcEndAngle(d) {
        return d.endAngle;
      }
      function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
      }
      function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
      }
      function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0],
            y01 = p0[1] - p1[1],
            lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
            ox = lo * y01,
            oy = -lo * x01,
            x1 = p0[0] + ox,
            y1 = p0[1] + oy,
            x2 = p1[0] + ox,
            y2 = p1[1] + oy,
            x3 = (x1 + x2) / 2,
            y3 = (y1 + y2) / 2,
            dx = x2 - x1,
            dy = y2 - y1,
            d2 = dx * dx + dy * dy,
            r = r1 - rc,
            D = x1 * y2 - x2 * y1,
            d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D),
            cx0 = (D * dy - dx * d) / d2,
            cy0 = (-D * dx - dy * d) / d2,
            cx1 = (D * dy + dx * d) / d2,
            cy1 = (-D * dx + dy * d) / d2,
            dx0 = cx0 - x3,
            dy0 = cy0 - y3,
            dx1 = cx1 - x3,
            dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
          cx0 = cx1, cy0 = cy1;
        return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];
      }
      function d3_svg_line(projection) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            tension = .7;
        function line(data) {
          var segments = [],
              points = [],
              i = -1,
              n = data.length,
              d,
              fx = d3_functor(x),
              fy = d3_functor(y);
          function segment() {
            segments.push("M", interpolate(projection(points), tension));
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
            } else if (points.length) {
              segment();
              points = [];
            }
          }
          if (points.length)
            segment();
          return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
          if (!arguments.length)
            return x;
          x = _;
          return line;
        };
        line.y = function(_) {
          if (!arguments.length)
            return y;
          y = _;
          return line;
        };
        line.defined = function(_) {
          if (!arguments.length)
            return defined;
          defined = _;
          return line;
        };
        line.interpolate = function(_) {
          if (!arguments.length)
            return interpolateKey;
          if (typeof _ === "function")
            interpolateKey = interpolate = _;
          else
            interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          return line;
        };
        line.tension = function(_) {
          if (!arguments.length)
            return tension;
          tension = _;
          return line;
        };
        return line;
      }
      d3.svg.line = function() {
        return d3_svg_line(d3_identity);
      };
      var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
      });
      d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
      });
      function d3_svg_lineLinear(points) {
        return points.join("L");
      }
      function d3_svg_lineLinearClosed(points) {
        return d3_svg_lineLinear(points) + "Z";
      }
      function d3_svg_lineStep(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1)
          path.push("H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepBefore(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepAfter(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
      }
      function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
      }
      function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
          return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length,
            path = "",
            p0 = points[0],
            p = points[1],
            t0 = tangents[0],
            t = t0,
            pi = 1;
        if (quad) {
          path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
          p0 = points[1];
          pi = 2;
        }
        if (tangents.length > 1) {
          t = tangents[1];
          p = points[pi];
          pi++;
          path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          for (var i = 2; i < tangents.length; i++, pi++) {
            p = points[pi];
            t = tangents[i];
            path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          }
        }
        if (quad) {
          var lp = points[pi];
          path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
      }
      function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [],
            a = (1 - tension) / 2,
            p0,
            p1 = points[0],
            p2 = points[1],
            i = 1,
            n = points.length;
        while (++i < n) {
          p0 = p1;
          p1 = p2;
          p2 = points[i];
          tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
        }
        return tangents;
      }
      function d3_svg_lineBasis(points) {
        if (points.length < 3)
          return d3_svg_lineLinear(points);
        var i = 1,
            n = points.length,
            pi = points[0],
            x0 = pi[0],
            y0 = pi[1],
            px = [x0, x0, x0, (pi = points[1])[0]],
            py = [y0, y0, y0, pi[1]],
            path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        points.push(points[n - 1]);
        while (++i <= n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
      }
      function d3_svg_lineBasisOpen(points) {
        if (points.length < 4)
          return d3_svg_lineLinear(points);
        var path = [],
            i = -1,
            n = points.length,
            pi,
            px = [0],
            py = [0];
        while (++i < 3) {
          pi = points[i];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBasisClosed(points) {
        var path,
            i = -1,
            n = points.length,
            m = n + 4,
            pi,
            px = [],
            py = [];
        while (++i < 4) {
          pi = points[i % n];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        --i;
        while (++i < m) {
          pi = points[i % n];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
          var x0 = points[0][0],
              y0 = points[0][1],
              dx = points[n][0] - x0,
              dy = points[n][1] - y0,
              i = -1,
              p,
              t;
          while (++i <= n) {
            p = points[i];
            t = i / n;
            p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
            p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
          }
        }
        return d3_svg_lineBasis(points);
      }
      function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
      }
      var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0],
          d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0],
          d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
      function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
      }
      function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
      }
      function d3_svg_lineFiniteDifferences(points) {
        var i = 0,
            j = points.length - 1,
            m = [],
            p0 = points[0],
            p1 = points[1],
            d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
          m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
      }
      function d3_svg_lineMonotoneTangents(points) {
        var tangents = [],
            d,
            a,
            b,
            s,
            m = d3_svg_lineFiniteDifferences(points),
            i = -1,
            j = points.length - 1;
        while (++i < j) {
          d = d3_svg_lineSlope(points[i], points[i + 1]);
          if (abs(d) < ε) {
            m[i] = m[i + 1] = 0;
          } else {
            a = m[i] / d;
            b = m[i + 1] / d;
            s = a * a + b * b;
            if (s > 9) {
              s = d * 3 / Math.sqrt(s);
              m[i] = s * a;
              m[i + 1] = s * b;
            }
          }
        }
        i = -1;
        while (++i <= j) {
          s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
          tangents.push([s || 0, m[i] * s || 0]);
        }
        return tangents;
      }
      function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
      }
      d3.svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
      };
      function d3_svg_lineRadial(points) {
        var point,
            i = -1,
            n = points.length,
            r,
            a;
        while (++i < n) {
          point = points[i];
          r = point[0];
          a = point[1] - halfπ;
          point[0] = r * Math.cos(a);
          point[1] = r * Math.sin(a);
        }
        return points;
      }
      function d3_svg_area(projection) {
        var x0 = d3_geom_pointX,
            x1 = d3_geom_pointX,
            y0 = 0,
            y1 = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            interpolateReverse = interpolate,
            L = "L",
            tension = .7;
        function area(data) {
          var segments = [],
              points0 = [],
              points1 = [],
              i = -1,
              n = data.length,
              d,
              fx0 = d3_functor(x0),
              fy0 = d3_functor(y0),
              fx1 = x0 === x1 ? function() {
                return x;
              } : d3_functor(x1),
              fy1 = y0 === y1 ? function() {
                return y;
              } : d3_functor(y1),
              x,
              y;
          function segment() {
            segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
              points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
            } else if (points0.length) {
              segment();
              points0 = [];
              points1 = [];
            }
          }
          if (points0.length)
            segment();
          return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
          if (!arguments.length)
            return x1;
          x0 = x1 = _;
          return area;
        };
        area.x0 = function(_) {
          if (!arguments.length)
            return x0;
          x0 = _;
          return area;
        };
        area.x1 = function(_) {
          if (!arguments.length)
            return x1;
          x1 = _;
          return area;
        };
        area.y = function(_) {
          if (!arguments.length)
            return y1;
          y0 = y1 = _;
          return area;
        };
        area.y0 = function(_) {
          if (!arguments.length)
            return y0;
          y0 = _;
          return area;
        };
        area.y1 = function(_) {
          if (!arguments.length)
            return y1;
          y1 = _;
          return area;
        };
        area.defined = function(_) {
          if (!arguments.length)
            return defined;
          defined = _;
          return area;
        };
        area.interpolate = function(_) {
          if (!arguments.length)
            return interpolateKey;
          if (typeof _ === "function")
            interpolateKey = interpolate = _;
          else
            interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          interpolateReverse = interpolate.reverse || interpolate;
          L = interpolate.closed ? "M" : "L";
          return area;
        };
        area.tension = function(_) {
          if (!arguments.length)
            return tension;
          tension = _;
          return area;
        };
        return area;
      }
      d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
      d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
      d3.svg.area = function() {
        return d3_svg_area(d3_identity);
      };
      d3.svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
      };
      d3.svg.chord = function() {
        var source = d3_source,
            target = d3_target,
            radius = d3_svg_chordRadius,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
          var s = subgroup(this, source, d, i),
              t = subgroup(this, target, d, i);
          return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
          var subgroup = f.call(self, d, i),
              r = radius.call(self, subgroup, i),
              a0 = startAngle.call(self, subgroup, i) - halfπ,
              a1 = endAngle.call(self, subgroup, i) - halfπ;
          return {
            r: r,
            a0: a0,
            a1: a1,
            p0: [r * Math.cos(a0), r * Math.sin(a0)],
            p1: [r * Math.cos(a1), r * Math.sin(a1)]
          };
        }
        function equals(a, b) {
          return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
          return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
          return "Q 0,0 " + p1;
        }
        chord.radius = function(v) {
          if (!arguments.length)
            return radius;
          radius = d3_functor(v);
          return chord;
        };
        chord.source = function(v) {
          if (!arguments.length)
            return source;
          source = d3_functor(v);
          return chord;
        };
        chord.target = function(v) {
          if (!arguments.length)
            return target;
          target = d3_functor(v);
          return chord;
        };
        chord.startAngle = function(v) {
          if (!arguments.length)
            return startAngle;
          startAngle = d3_functor(v);
          return chord;
        };
        chord.endAngle = function(v) {
          if (!arguments.length)
            return endAngle;
          endAngle = d3_functor(v);
          return chord;
        };
        return chord;
      };
      function d3_svg_chordRadius(d) {
        return d.radius;
      }
      d3.svg.diagonal = function() {
        var source = d3_source,
            target = d3_target,
            projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
          var p0 = source.call(this, d, i),
              p3 = target.call(this, d, i),
              m = (p0.y + p3.y) / 2,
              p = [p0, {
                x: p0.x,
                y: m
              }, {
                x: p3.x,
                y: m
              }, p3];
          p = p.map(projection);
          return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
          if (!arguments.length)
            return source;
          source = d3_functor(x);
          return diagonal;
        };
        diagonal.target = function(x) {
          if (!arguments.length)
            return target;
          target = d3_functor(x);
          return diagonal;
        };
        diagonal.projection = function(x) {
          if (!arguments.length)
            return projection;
          projection = x;
          return diagonal;
        };
        return diagonal;
      };
      function d3_svg_diagonalProjection(d) {
        return [d.x, d.y];
      }
      d3.svg.diagonal.radial = function() {
        var diagonal = d3.svg.diagonal(),
            projection = d3_svg_diagonalProjection,
            projection_ = diagonal.projection;
        diagonal.projection = function(x) {
          return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
      };
      function d3_svg_diagonalRadialProjection(projection) {
        return function() {
          var d = projection.apply(this, arguments),
              r = d[0],
              a = d[1] - halfπ;
          return [r * Math.cos(a), r * Math.sin(a)];
        };
      }
      d3.svg.symbol = function() {
        var type = d3_svg_symbolType,
            size = d3_svg_symbolSize;
        function symbol(d, i) {
          return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function(x) {
          if (!arguments.length)
            return type;
          type = d3_functor(x);
          return symbol;
        };
        symbol.size = function(x) {
          if (!arguments.length)
            return size;
          size = d3_functor(x);
          return symbol;
        };
        return symbol;
      };
      function d3_svg_symbolSize() {
        return 64;
      }
      function d3_svg_symbolType() {
        return "circle";
      }
      function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
      }
      var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function(size) {
          var r = Math.sqrt(size / 5) / 2;
          return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function(size) {
          var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
              rx = ry * d3_svg_symbolTan30;
          return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function(size) {
          var r = Math.sqrt(size) / 2;
          return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function(size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function(size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
      });
      d3.svg.symbolTypes = d3_svg_symbols.keys();
      var d3_svg_symbolSqrt3 = Math.sqrt(3),
          d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
      d3_selectionPrototype.transition = function(name) {
        var id = d3_transitionInheritId || ++d3_transitionId,
            ns = d3_transitionNamespace(name),
            subgroups = [],
            subgroup,
            node,
            transition = d3_transitionInherit || {
              time: Date.now(),
              ease: d3_ease_cubicInOut,
              delay: 0,
              duration: 250
            };
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i])
              d3_transitionNode(node, i, ns, id, transition);
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_selectionPrototype.interrupt = function(name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
      };
      var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
      function d3_selection_interruptNS(ns) {
        return function() {
          var lock,
              active;
          if ((lock = this[ns]) && (active = lock[lock.active])) {
            if (--lock.count)
              delete lock[lock.active];
            else
              delete this[ns];
            lock.active += .5;
            active.event && active.event.interrupt.call(this, this.__data__, active.index);
          }
        };
      }
      function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
      }
      var d3_transitionPrototype = [],
          d3_transitionId = 0,
          d3_transitionInheritId,
          d3_transitionInherit;
      d3_transitionPrototype.call = d3_selectionPrototype.call;
      d3_transitionPrototype.empty = d3_selectionPrototype.empty;
      d3_transitionPrototype.node = d3_selectionPrototype.node;
      d3_transitionPrototype.size = d3_selectionPrototype.size;
      d3.transition = function(selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
      };
      d3.transition.prototype = d3_transitionPrototype;
      d3_transitionPrototype.select = function(selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnode,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
              if ("__data__" in node)
                subnode.__data__ = node.__data__;
              d3_transitionNode(subnode, i, ns, id, node[ns][id]);
              subgroup.push(subnode);
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.selectAll = function(selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnodes,
            node,
            subnode,
            transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              transition = node[ns][id];
              subnodes = selector.call(node, node.__data__, i, j);
              subgroups.push(subgroup = []);
              for (var k = -1,
                  o = subnodes.length; ++k < o; ) {
                if (subnode = subnodes[k])
                  d3_transitionNode(subnode, k, ns, id, transition);
                subgroup.push(subnode);
              }
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.filter = function(filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function")
          filter = d3_selection_filter(filter);
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_transition(subgroups, this.namespace, this.id);
      };
      d3_transitionPrototype.tween = function(name, tween) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2)
          return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function(node) {
          node[ns][id].tween.remove(name);
        } : function(node) {
          node[ns][id].tween.set(name, tween);
        });
      };
      function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id,
            ns = groups.namespace;
        return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
          node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function(node) {
          node[ns][id].tween.set(name, value);
        }));
      }
      d3_transitionPrototype.attr = function(nameNS, value) {
        if (arguments.length < 2) {
          for (value in nameNS)
            this.attr(value, nameNS[value]);
          return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate,
            name = d3.ns.qualify(nameNS);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
          return b == null ? attrNull : (b += "", function() {
            var a = this.getAttribute(name),
                i;
            return a !== b && (i = interpolate(a, b), function(t) {
              this.setAttribute(name, i(t));
            });
          });
        }
        function attrTweenNS(b) {
          return b == null ? attrNullNS : (b += "", function() {
            var a = this.getAttributeNS(name.space, name.local),
                i;
            return a !== b && (i = interpolate(a, b), function(t) {
              this.setAttributeNS(name.space, name.local, i(t));
            });
          });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.attrTween = function(nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
          var f = tween.call(this, d, i, this.getAttribute(name));
          return f && function(t) {
            this.setAttribute(name, f(t));
          };
        }
        function attrTweenNS(d, i) {
          var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
          return f && function(t) {
            this.setAttributeNS(name.space, name.local, f(t));
          };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2)
              value = "";
            for (priority in name)
              this.style(priority, name[priority], value);
            return this;
          }
          priority = "";
        }
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleString(b) {
          return b == null ? styleNull : (b += "", function() {
            var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name),
                i;
            return a !== b && (i = d3_interpolate(a, b), function(t) {
              this.style.setProperty(name, i(t), priority);
            });
          });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
      };
      d3_transitionPrototype.styleTween = function(name, tween, priority) {
        if (arguments.length < 3)
          priority = "";
        function styleTween(d, i) {
          var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
          return f && function(t) {
            this.style.setProperty(name, f(t), priority);
          };
        }
        return this.tween("style." + name, styleTween);
      };
      d3_transitionPrototype.text = function(value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
      };
      function d3_transition_text(b) {
        if (b == null)
          b = "";
        return function() {
          this.textContent = b;
        };
      }
      d3_transitionPrototype.remove = function() {
        var ns = this.namespace;
        return this.each("end.transition", function() {
          var p;
          if (this[ns].count < 2 && (p = this.parentNode))
            p.removeChild(this);
        });
      };
      d3_transitionPrototype.ease = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].ease;
        if (typeof value !== "function")
          value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function(node) {
          node[ns][id].ease = value;
        });
      };
      d3_transitionPrototype.delay = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
          node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function(node) {
          node[ns][id].delay = value;
        }));
      };
      d3_transitionPrototype.duration = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
          node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function(node) {
          node[ns][id].duration = value;
        }));
      };
      d3_transitionPrototype.each = function(type, listener) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2) {
          var inherit = d3_transitionInherit,
              inheritId = d3_transitionInheritId;
          try {
            d3_transitionInheritId = id;
            d3_selection_each(this, function(node, i, j) {
              d3_transitionInherit = node[ns][id];
              type.call(node, node.__data__, i, j);
            });
          } finally {
            d3_transitionInherit = inherit;
            d3_transitionInheritId = inheritId;
          }
        } else {
          d3_selection_each(this, function(node) {
            var transition = node[ns][id];
            (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
          });
        }
        return this;
      };
      d3_transitionPrototype.transition = function() {
        var id0 = this.id,
            id1 = ++d3_transitionId,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            group,
            node,
            transition;
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            if (node = group[i]) {
              transition = node[ns][id0];
              d3_transitionNode(node, i, ns, id1, {
                time: transition.time,
                ease: transition.ease,
                delay: transition.delay + transition.duration,
                duration: transition.duration
              });
            }
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id1);
      };
      function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
      }
      function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
          active: 0,
          count: 0
        }),
            transition = lock[id];
        if (!transition) {
          var time = inherit.time;
          transition = lock[id] = {
            tween: new d3_Map(),
            time: time,
            delay: inherit.delay,
            duration: inherit.duration,
            ease: inherit.ease,
            index: i
          };
          inherit = null;
          ++lock.count;
          d3.timer(function(elapsed) {
            var delay = transition.delay,
                duration,
                ease,
                timer = d3_timer_active,
                tweened = [];
            timer.t = delay + time;
            if (delay <= elapsed)
              return start(elapsed - delay);
            timer.c = start;
            function start(elapsed) {
              if (lock.active > id)
                return stop();
              var active = lock[lock.active];
              if (active) {
                --lock.count;
                delete lock[lock.active];
                active.event && active.event.interrupt.call(node, node.__data__, active.index);
              }
              lock.active = id;
              transition.event && transition.event.start.call(node, node.__data__, i);
              transition.tween.forEach(function(key, value) {
                if (value = value.call(node, node.__data__, i)) {
                  tweened.push(value);
                }
              });
              ease = transition.ease;
              duration = transition.duration;
              d3.timer(function() {
                timer.c = tick(elapsed || 1) ? d3_true : tick;
                return 1;
              }, 0, time);
            }
            function tick(elapsed) {
              if (lock.active !== id)
                return 1;
              var t = elapsed / duration,
                  e = ease(t),
                  n = tweened.length;
              while (n > 0) {
                tweened[--n].call(node, e);
              }
              if (t >= 1) {
                transition.event && transition.event.end.call(node, node.__data__, i);
                return stop();
              }
            }
            function stop() {
              if (--lock.count)
                delete lock[id];
              else
                delete node[ns];
              return 1;
            }
          }, 0, time);
        }
      }
      d3.svg.axis = function() {
        var scale = d3.scale.linear(),
            orient = d3_svg_axisDefaultOrient,
            innerTickSize = 6,
            outerTickSize = 6,
            tickPadding = 3,
            tickArguments_ = [10],
            tickValues = null,
            tickFormat_;
        function axis(g) {
          g.each(function() {
            var g = d3.select(this);
            var scale0 = this.__chart__ || scale,
                scale1 = this.__chart__ = scale.copy();
            var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues,
                tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_,
                tick = g.selectAll(".tick").data(ticks, scale1),
                tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε),
                tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(),
                tickUpdate = d3.transition(tick.order()).style("opacity", 1),
                tickSpacing = Math.max(innerTickSize, 0) + tickPadding,
                tickTransform;
            var range = d3_scaleRange(scale1),
                path = g.selectAll(".domain").data([0]),
                pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path));
            tickEnter.append("line");
            tickEnter.append("text");
            var lineEnter = tickEnter.select("line"),
                lineUpdate = tickUpdate.select("line"),
                text = tick.select("text").text(tickFormat),
                textEnter = tickEnter.select("text"),
                textUpdate = tickUpdate.select("text"),
                sign = orient === "top" || orient === "left" ? -1 : 1,
                x1,
                x2,
                y1,
                y2;
            if (orient === "bottom" || orient === "top") {
              tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
              text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
              pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
            } else {
              tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
              text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
              pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
            }
            lineEnter.attr(y2, sign * innerTickSize);
            textEnter.attr(y1, sign * tickSpacing);
            lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
            textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
            if (scale1.rangeBand) {
              var x = scale1,
                  dx = x.rangeBand() / 2;
              scale0 = scale1 = function(d) {
                return x(d) + dx;
              };
            } else if (scale0.rangeBand) {
              scale0 = scale1;
            } else {
              tickExit.call(tickTransform, scale1, scale0);
            }
            tickEnter.call(tickTransform, scale0, scale1);
            tickUpdate.call(tickTransform, scale1, scale1);
          });
        }
        axis.scale = function(x) {
          if (!arguments.length)
            return scale;
          scale = x;
          return axis;
        };
        axis.orient = function(x) {
          if (!arguments.length)
            return orient;
          orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
          return axis;
        };
        axis.ticks = function() {
          if (!arguments.length)
            return tickArguments_;
          tickArguments_ = arguments;
          return axis;
        };
        axis.tickValues = function(x) {
          if (!arguments.length)
            return tickValues;
          tickValues = x;
          return axis;
        };
        axis.tickFormat = function(x) {
          if (!arguments.length)
            return tickFormat_;
          tickFormat_ = x;
          return axis;
        };
        axis.tickSize = function(x) {
          var n = arguments.length;
          if (!n)
            return innerTickSize;
          innerTickSize = +x;
          outerTickSize = +arguments[n - 1];
          return axis;
        };
        axis.innerTickSize = function(x) {
          if (!arguments.length)
            return innerTickSize;
          innerTickSize = +x;
          return axis;
        };
        axis.outerTickSize = function(x) {
          if (!arguments.length)
            return outerTickSize;
          outerTickSize = +x;
          return axis;
        };
        axis.tickPadding = function(x) {
          if (!arguments.length)
            return tickPadding;
          tickPadding = +x;
          return axis;
        };
        axis.tickSubdivide = function() {
          return arguments.length && axis;
        };
        return axis;
      };
      var d3_svg_axisDefaultOrient = "bottom",
          d3_svg_axisOrients = {
            top: 1,
            right: 1,
            bottom: 1,
            left: 1
          };
      function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function(d) {
          var v0 = x0(d);
          return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
        });
      }
      function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function(d) {
          var v0 = y0(d);
          return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
        });
      }
      d3.svg.brush = function() {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"),
            x = null,
            y = null,
            xExtent = [0, 0],
            yExtent = [0, 0],
            xExtentDomain,
            yExtentDomain,
            xClamp = true,
            yClamp = true,
            resizes = d3_svg_brushResizes[0];
        function brush(g) {
          g.each(function() {
            var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
            var background = g.selectAll(".background").data([0]);
            background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
            g.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
            var resize = g.selectAll(".resize").data(resizes, d3_identity);
            resize.exit().remove();
            resize.enter().append("g").attr("class", function(d) {
              return "resize " + d;
            }).style("cursor", function(d) {
              return d3_svg_brushCursor[d];
            }).append("rect").attr("x", function(d) {
              return /[ew]$/.test(d) ? -3 : null;
            }).attr("y", function(d) {
              return /^[ns]/.test(d) ? -3 : null;
            }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
            resize.style("display", brush.empty() ? "none" : null);
            var gUpdate = d3.transition(g),
                backgroundUpdate = d3.transition(background),
                range;
            if (x) {
              range = d3_scaleRange(x);
              backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
              redrawX(gUpdate);
            }
            if (y) {
              range = d3_scaleRange(y);
              backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
              redrawY(gUpdate);
            }
            redraw(gUpdate);
          });
        }
        brush.event = function(g) {
          g.each(function() {
            var event_ = event.of(this, arguments),
                extent1 = {
                  x: xExtent,
                  y: yExtent,
                  i: xExtentDomain,
                  j: yExtentDomain
                },
                extent0 = this.__chart__ || extent1;
            this.__chart__ = extent1;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.brush", function() {
                xExtentDomain = extent0.i;
                yExtentDomain = extent0.j;
                xExtent = extent0.x;
                yExtent = extent0.y;
                event_({type: "brushstart"});
              }).tween("brush:brush", function() {
                var xi = d3_interpolateArray(xExtent, extent1.x),
                    yi = d3_interpolateArray(yExtent, extent1.y);
                xExtentDomain = yExtentDomain = null;
                return function(t) {
                  xExtent = extent1.x = xi(t);
                  yExtent = extent1.y = yi(t);
                  event_({
                    type: "brush",
                    mode: "resize"
                  });
                };
              }).each("end.brush", function() {
                xExtentDomain = extent1.i;
                yExtentDomain = extent1.j;
                event_({
                  type: "brush",
                  mode: "resize"
                });
                event_({type: "brushend"});
              });
            } else {
              event_({type: "brushstart"});
              event_({
                type: "brush",
                mode: "resize"
              });
              event_({type: "brushend"});
            }
          });
        };
        function redraw(g) {
          g.selectAll(".resize").attr("transform", function(d) {
            return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
          });
        }
        function redrawX(g) {
          g.select(".extent").attr("x", xExtent[0]);
          g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
          g.select(".extent").attr("y", yExtent[0]);
          g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
          var target = this,
              eventTarget = d3.select(d3.event.target),
              event_ = event.of(target, arguments),
              g = d3.select(target),
              resizing = eventTarget.datum(),
              resizingX = !/^(n|s)$/.test(resizing) && x,
              resizingY = !/^(e|w)$/.test(resizing) && y,
              dragging = eventTarget.classed("extent"),
              dragRestore = d3_event_dragSuppress(target),
              center,
              origin = d3.mouse(target),
              offset;
          var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
          if (d3.event.changedTouches) {
            w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
          } else {
            w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
          }
          g.interrupt().selectAll("*").interrupt();
          if (dragging) {
            origin[0] = xExtent[0] - origin[0];
            origin[1] = yExtent[0] - origin[1];
          } else if (resizing) {
            var ex = +/w$/.test(resizing),
                ey = +/^n/.test(resizing);
            offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
            origin[0] = xExtent[ex];
            origin[1] = yExtent[ey];
          } else if (d3.event.altKey)
            center = origin.slice();
          g.style("pointer-events", "none").selectAll(".resize").style("display", null);
          d3.select("body").style("cursor", eventTarget.style("cursor"));
          event_({type: "brushstart"});
          brushmove();
          function keydown() {
            if (d3.event.keyCode == 32) {
              if (!dragging) {
                center = null;
                origin[0] -= xExtent[1];
                origin[1] -= yExtent[1];
                dragging = 2;
              }
              d3_eventPreventDefault();
            }
          }
          function keyup() {
            if (d3.event.keyCode == 32 && dragging == 2) {
              origin[0] += xExtent[1];
              origin[1] += yExtent[1];
              dragging = 0;
              d3_eventPreventDefault();
            }
          }
          function brushmove() {
            var point = d3.mouse(target),
                moved = false;
            if (offset) {
              point[0] += offset[0];
              point[1] += offset[1];
            }
            if (!dragging) {
              if (d3.event.altKey) {
                if (!center)
                  center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                origin[0] = xExtent[+(point[0] < center[0])];
                origin[1] = yExtent[+(point[1] < center[1])];
              } else
                center = null;
            }
            if (resizingX && move1(point, x, 0)) {
              redrawX(g);
              moved = true;
            }
            if (resizingY && move1(point, y, 1)) {
              redrawY(g);
              moved = true;
            }
            if (moved) {
              redraw(g);
              event_({
                type: "brush",
                mode: dragging ? "move" : "resize"
              });
            }
          }
          function move1(point, scale, i) {
            var range = d3_scaleRange(scale),
                r0 = range[0],
                r1 = range[1],
                position = origin[i],
                extent = i ? yExtent : xExtent,
                size = extent[1] - extent[0],
                min,
                max;
            if (dragging) {
              r0 -= position;
              r1 -= size + position;
            }
            min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
            if (dragging) {
              max = (min += position) + size;
            } else {
              if (center)
                position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
              if (position < min) {
                max = min;
                min = position;
              } else {
                max = position;
              }
            }
            if (extent[0] != min || extent[1] != max) {
              if (i)
                yExtentDomain = null;
              else
                xExtentDomain = null;
              extent[0] = min;
              extent[1] = max;
              return true;
            }
          }
          function brushend() {
            brushmove();
            g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
            d3.select("body").style("cursor", null);
            w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
            dragRestore();
            event_({type: "brushend"});
          }
        }
        brush.x = function(z) {
          if (!arguments.length)
            return x;
          x = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.y = function(z) {
          if (!arguments.length)
            return y;
          y = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.clamp = function(z) {
          if (!arguments.length)
            return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;
          if (x && y)
            xClamp = !!z[0], yClamp = !!z[1];
          else if (x)
            xClamp = !!z;
          else if (y)
            yClamp = !!z;
          return brush;
        };
        brush.extent = function(z) {
          var x0,
              x1,
              y0,
              y1,
              t;
          if (!arguments.length) {
            if (x) {
              if (xExtentDomain) {
                x0 = xExtentDomain[0], x1 = xExtentDomain[1];
              } else {
                x0 = xExtent[0], x1 = xExtent[1];
                if (x.invert)
                  x0 = x.invert(x0), x1 = x.invert(x1);
                if (x1 < x0)
                  t = x0, x0 = x1, x1 = t;
              }
            }
            if (y) {
              if (yExtentDomain) {
                y0 = yExtentDomain[0], y1 = yExtentDomain[1];
              } else {
                y0 = yExtent[0], y1 = yExtent[1];
                if (y.invert)
                  y0 = y.invert(y0), y1 = y.invert(y1);
                if (y1 < y0)
                  t = y0, y0 = y1, y1 = t;
              }
            }
            return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
          }
          if (x) {
            x0 = z[0], x1 = z[1];
            if (y)
              x0 = x0[0], x1 = x1[0];
            xExtentDomain = [x0, x1];
            if (x.invert)
              x0 = x(x0), x1 = x(x1);
            if (x1 < x0)
              t = x0, x0 = x1, x1 = t;
            if (x0 != xExtent[0] || x1 != xExtent[1])
              xExtent = [x0, x1];
          }
          if (y) {
            y0 = z[0], y1 = z[1];
            if (x)
              y0 = y0[1], y1 = y1[1];
            yExtentDomain = [y0, y1];
            if (y.invert)
              y0 = y(y0), y1 = y(y1);
            if (y1 < y0)
              t = y0, y0 = y1, y1 = t;
            if (y0 != yExtent[0] || y1 != yExtent[1])
              yExtent = [y0, y1];
          }
          return brush;
        };
        brush.clear = function() {
          if (!brush.empty()) {
            xExtent = [0, 0], yExtent = [0, 0];
            xExtentDomain = yExtentDomain = null;
          }
          return brush;
        };
        brush.empty = function() {
          return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, "on");
      };
      var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
      };
      var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
      var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
      var d3_time_formatUtc = d3_time_format.utc;
      var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
      d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
      function d3_time_formatIsoNative(date) {
        return date.toISOString();
      }
      d3_time_formatIsoNative.parse = function(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
      };
      d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
      d3_time.second = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 1e3) * 1e3);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
      }, function(date) {
        return date.getSeconds();
      });
      d3_time.seconds = d3_time.second.range;
      d3_time.seconds.utc = d3_time.second.utc.range;
      d3_time.minute = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 6e4) * 6e4);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
      }, function(date) {
        return date.getMinutes();
      });
      d3_time.minutes = d3_time.minute.range;
      d3_time.minutes.utc = d3_time.minute.utc.range;
      d3_time.hour = d3_time_interval(function(date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
      }, function(date) {
        return date.getHours();
      });
      d3_time.hours = d3_time.hour.range;
      d3_time.hours.utc = d3_time.hour.utc.range;
      d3_time.month = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
      }, function(date, offset) {
        date.setMonth(date.getMonth() + offset);
      }, function(date) {
        return date.getMonth();
      });
      d3_time.months = d3_time.month.range;
      d3_time.months.utc = d3_time.month.utc.range;
      function d3_time_scale(linear, methods, format) {
        function scale(x) {
          return linear(x);
        }
        scale.invert = function(x) {
          return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return linear.domain().map(d3_time_scaleDate);
          linear.domain(x);
          return scale;
        };
        function tickMethod(extent, count) {
          var span = extent[1] - extent[0],
              target = span / count,
              i = d3.bisect(d3_time_scaleSteps, target);
          return i == d3_time_scaleSteps.length ? [methods.year, d3_scale_linearTickRange(extent.map(function(d) {
            return d / 31536e6;
          }), count)[2]] : !i ? [d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2]] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function(interval, skip) {
          var domain = scale.domain(),
              extent = d3_scaleExtent(domain),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
          if (method)
            interval = method[0], skip = method[1];
          function skipped(date) {
            return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
          }
          return scale.domain(d3_scale_nice(domain, skip > 1 ? {
            floor: function(date) {
              while (skipped(date = interval.floor(date)))
                date = d3_time_scaleDate(date - 1);
              return date;
            },
            ceil: function(date) {
              while (skipped(date = interval.ceil(date)))
                date = d3_time_scaleDate(+date + 1);
              return date;
            }
          } : interval));
        };
        scale.ticks = function(interval, skip) {
          var extent = d3_scaleExtent(scale.domain()),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [{range: interval}, skip];
          if (method)
            interval = method[0], skip = method[1];
          return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function() {
          return format;
        };
        scale.copy = function() {
          return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_time_scaleDate(t) {
        return new Date(t);
      }
      var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];
      var d3_time_scaleLocalMethods = [[d3_time.second, 1], [d3_time.second, 5], [d3_time.second, 15], [d3_time.second, 30], [d3_time.minute, 1], [d3_time.minute, 5], [d3_time.minute, 15], [d3_time.minute, 30], [d3_time.hour, 1], [d3_time.hour, 3], [d3_time.hour, 6], [d3_time.hour, 12], [d3_time.day, 1], [d3_time.day, 2], [d3_time.week, 1], [d3_time.month, 1], [d3_time.month, 3], [d3_time.year, 1]];
      var d3_time_scaleLocalFormat = d3_time_format.multi([[".%L", function(d) {
        return d.getMilliseconds();
      }], [":%S", function(d) {
        return d.getSeconds();
      }], ["%I:%M", function(d) {
        return d.getMinutes();
      }], ["%I %p", function(d) {
        return d.getHours();
      }], ["%a %d", function(d) {
        return d.getDay() && d.getDate() != 1;
      }], ["%b %d", function(d) {
        return d.getDate() != 1;
      }], ["%B", function(d) {
        return d.getMonth();
      }], ["%Y", d3_true]]);
      var d3_time_scaleMilliseconds = {
        range: function(start, stop, step) {
          return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
      };
      d3_time_scaleLocalMethods.year = d3_time.year;
      d3_time.scale = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
      };
      var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
        return [m[0].utc, m[1]];
      });
      var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([[".%L", function(d) {
        return d.getUTCMilliseconds();
      }], [":%S", function(d) {
        return d.getUTCSeconds();
      }], ["%I:%M", function(d) {
        return d.getUTCMinutes();
      }], ["%I %p", function(d) {
        return d.getUTCHours();
      }], ["%a %d", function(d) {
        return d.getUTCDay() && d.getUTCDate() != 1;
      }], ["%b %d", function(d) {
        return d.getUTCDate() != 1;
      }], ["%B", function(d) {
        return d.getUTCMonth();
      }], ["%Y", d3_true]]);
      d3_time_scaleUtcMethods.year = d3_time.year.utc;
      d3_time.scale.utc = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
      };
      d3.text = d3_xhrType(function(request) {
        return request.responseText;
      });
      d3.json = function(url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
      };
      function d3_json(request) {
        return JSON.parse(request.responseText);
      }
      d3.html = function(url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
      };
      function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
      }
      d3.xml = d3_xhrType(function(request) {
        return request.responseXML;
      });
      if (typeof define === "function" && define.amd)
        define(d3);
      else if (typeof module === "object" && module.exports)
        module.exports = d3;
      this.d3 = d3;
    }();
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, "d3");
});



System.register("lib/components/deps/common/axes-aligned", ["react", "d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  var d3 = require('d3');
  exports.XAxis = React.createClass({
    displayName: "XAxis",
    propTypes: {
      xAxisClassName: React.PropTypes.string.isRequired,
      xOrient: React.PropTypes.oneOf(['top', 'bottom']),
      xZeroAligned: React.PropTypes.bool,
      xScale: React.PropTypes.func.isRequired,
      yScale: React.PropTypes.func.isRequired,
      xHideOrigin: React.PropTypes.bool,
      height: React.PropTypes.number.isRequired,
      fill: React.PropTypes.string,
      stroke: React.PropTypes.string,
      tickStroke: React.PropTypes.string,
      strokeWidth: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        xAxisClassName: 'x axis',
        xOrient: 'bottom',
        xHideOrigin: false,
        xZeroAligned: false,
        fill: "none",
        stroke: "none",
        tickStroke: "#000",
        strokeWidth: "none",
        hideOrigin: false
      };
    },
    componentDidMount: function() {
      this._renderAxis(this.props);
    },
    componentWillReceiveProps: function(props) {
      this._renderAxis(props);
    },
    _renderAxis: function(props) {
      var xAxis = d3.svg.axis().scale(props.xScale).orient(props.xOrient);
      if (props.xAxisTickInterval) {
        xAxis.ticks(d3.time[props.xAxisTickInterval.unit], props.xAxisTickInterval.interval);
      } else if (props.xAxisTickCount) {
        xAxis.ticks(props.xAxisTickCount);
      }
      var xAxisClassSelect = props.xAxisClassName.replace(/ /g, '.');
      if (xAxisClassSelect[0] != '.') {
        xAxisClassSelect = '.' + xAxisClassSelect;
      }
      var node = this.refs.xaxis.getDOMNode();
      d3.select(node).attr("class", props.xAxisClassName).call(xAxis);
      d3.selectAll(xAxisClassSelect).selectAll('line').attr("shape-rendering", "crispEdges").attr("stroke", props.tickStroke);
      d3.selectAll(xAxisClassSelect).select('path').attr("shape-rendering", "crispEdges").attr("fill", props.fill).attr("stroke", props.stroke).attr("stroke-width", props.strokeWidth);
      if (props.xHideOrigin) {
        var originSelect = xAxisClassSelect + ' g:first-child';
        d3.selectAll(originSelect).style("opacity", "0");
      }
    },
    render: function() {
      var props = this.props;
      var t = "translate(0," + props.yScale(0) + ")";
      return (React.createElement("g", {
        ref: "xaxis",
        className: props.xAxisClassName,
        transform: t
      }));
    }
  });
  exports.YAxis = React.createClass({
    displayName: "YAxis",
    propTypes: {
      yAxisClassName: React.PropTypes.string,
      yOrient: React.PropTypes.oneOf(['left', 'right']),
      yScale: React.PropTypes.func.isRequired,
      yHideOrigin: React.PropTypes.bool,
      fill: React.PropTypes.string,
      stroke: React.PropTypes.string,
      tickStroke: React.PropTypes.string,
      strokeWidth: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        yAxisClassName: 'y axis',
        yOrient: 'left',
        yHideOrigin: false,
        fill: "none",
        stroke: "#000",
        tickStroke: "#000",
        strokeWidth: "none"
      };
    },
    componentDidMount: function() {
      this._renderAxis(this.props);
    },
    componentWillReceiveProps: function(props) {
      this._renderAxis(props);
    },
    _renderAxis: function(props) {
      var yAxis = d3.svg.axis().ticks(props.yAxisTickCount).scale(props.yScale).orient(this.props.yOrient);
      if (props.yAxisTickCount) {
        yAxis.ticks(props.yAxisTickCount);
      } else if (props.yAxisTickInterval) {
        yAxis.ticks(d3.time[props.yAxisTickInterval.unit], props.yAxisTickInterval.interval);
      }
      var yAxisClassSelect = props.yAxisClassName.replace(/ /g, '.');
      if (yAxisClassSelect[0] != '.') {
        yAxisClassSelect = '.' + yAxisClassSelect;
      }
      var node = this.refs.yaxis.getDOMNode();
      d3.select(node).attr("class", props.yAxisClassName).call(yAxis);
      d3.selectAll(yAxisClassSelect).selectAll('line').attr("shape-rendering", "crispEdges").attr("stroke", props.tickStroke);
      d3.selectAll(yAxisClassSelect).select('path').attr("shape-rendering", "crispEdges").attr("fill", props.fill).attr("stroke", props.stroke);
      if (props.yHideOrigin) {
        var originSelect = yAxisClassSelect + ' g:first-child';
        d3.selectAll(originSelect).style("opacity", "0");
      }
    },
    render: function() {
      var props = this.props;
      return (React.createElement("g", {
        ref: "yaxis",
        className: props.yAxisClassName
      }));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("lib/components/deps/common/legend", ["react", "d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  var d3 = require('d3');
  exports.Legend = React.createClass({
    displayName: "Legend",
    propTypes: {
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      margins: React.PropTypes.object,
      text: React.PropTypes.string,
      colors: React.PropTypes.func
    },
    getDefaultProps: function() {
      return {
        text: "#000",
        colors: d3.scale.category20c()
      };
    },
    render: function() {
      var props = this.props;
      var textStyle = {
        'color': 'black',
        'fontSize': '50%',
        'verticalAlign': 'top'
      };
      var legendItems = [];
      props.data.forEach(function(series, idx) {
        var itemStyle = {
          'color': props.colors(idx),
          'lineHeight': '60%',
          'fontSize': '200%'
        };
        legendItems.push(React.createElement("li", {
          style: itemStyle,
          key: idx
        }, React.createElement("span", {style: textStyle}, series.name)));
      });
      var legendFloat = 'right';
      var topMargin = props.margins.top;
      var legendBlockStyle = {
        'wordWrap': 'break-word',
        'width': props.sideOffset,
        'paddingLeft': '0',
        'marginBottom': '0',
        'marginTop': topMargin,
        'float': legendFloat
      };
      return React.createElement("ul", {style: legendBlockStyle}, legendItems);
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("lib/components/deps/common/voronoi", ["react", "d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  var d3 = require('d3');
  var Polygon = React.createClass({
    displayName: "Polygon",
    _animateCircle: function() {
      this.props.pubsub.emit('animate', this.props.id);
    },
    _restoreCircle: function() {
      this.props.pubsub.emit('restore', this.props.id);
    },
    _drawPath: function(d) {
      if (d === undefined) {
        return;
      }
      return 'M' + d.join(',') + 'Z';
    },
    render: function() {
      return React.createElement("path", {
        onMouseOver: this._animateCircle,
        onMouseOut: this._restoreCircle,
        fill: "white",
        opacity: "0",
        d: this._drawPath(this.props.vnode)
      });
    }
  });
  exports.Voronoi = React.createClass({
    displayName: "Voronoi",
    render: function() {
      var xScale = this.props.xScale;
      var yScale = this.props.yScale;
      var voronoi = d3.geom.voronoi().x(function(d) {
        return xScale(d.coord.x);
      }).y(function(d) {
        return yScale(d.coord.y);
      }).clipExtent([[0, 0], [this.props.width, this.props.height]]);
      var regions = voronoi(this.props.data).map(function(vnode, idx) {
        return React.createElement(Polygon, {
          pubsub: this.props.pubsub,
          key: idx,
          id: vnode.point.id,
          vnode: vnode
        });
      }.bind(this));
      return (React.createElement("g", null, regions));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:events-browserify@0.0.1/events", ["process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    if (!process.EventEmitter)
      process.EventEmitter = function() {};
    var EventEmitter = exports.EventEmitter = process.EventEmitter;
    var isArray = typeof Array.isArray === 'function' ? Array.isArray : function(xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };
    ;
    var defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!this._events)
        this._events = {};
      this._events.maxListeners = n;
    };
    EventEmitter.prototype.emit = function(type) {
      if (type === 'error') {
        if (!this._events || !this._events.error || (isArray(this._events.error) && !this._events.error.length)) {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
          return false;
        }
      }
      if (!this._events)
        return false;
      var handler = this._events[type];
      if (!handler)
        return false;
      if (typeof handler == 'function') {
        switch (arguments.length) {
          case 1:
            handler.call(this);
            break;
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          default:
            var args = Array.prototype.slice.call(arguments, 1);
            handler.apply(this, args);
        }
        return true;
      } else if (isArray(handler)) {
        var args = Array.prototype.slice.call(arguments, 1);
        var listeners = handler.slice();
        for (var i = 0,
            l = listeners.length; i < l; i++) {
          listeners[i].apply(this, args);
        }
        return true;
      } else {
        return false;
      }
    };
    EventEmitter.prototype.addListener = function(type, listener) {
      if ('function' !== typeof listener) {
        throw new Error('addListener only takes instances of Function');
      }
      if (!this._events)
        this._events = {};
      this.emit('newListener', type, listener);
      if (!this._events[type]) {
        this._events[type] = listener;
      } else if (isArray(this._events[type])) {
        if (!this._events[type].warned) {
          var m;
          if (this._events.maxListeners !== undefined) {
            m = this._events.maxListeners;
          } else {
            m = defaultMaxListeners;
          }
          if (m && m > 0 && this._events[type].length > m) {
            this._events[type].warned = true;
            console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
            console.trace();
          }
        }
        this._events[type].push(listener);
      } else {
        this._events[type] = [this._events[type], listener];
      }
      return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function(type, listener) {
      var self = this;
      self.on(type, function g() {
        self.removeListener(type, g);
        listener.apply(this, arguments);
      });
      return this;
    };
    EventEmitter.prototype.removeListener = function(type, listener) {
      if ('function' !== typeof listener) {
        throw new Error('removeListener only takes instances of Function');
      }
      if (!this._events || !this._events[type])
        return this;
      var list = this._events[type];
      if (isArray(list)) {
        var i = list.indexOf(listener);
        if (i < 0)
          return this;
        list.splice(i, 1);
        if (list.length == 0)
          delete this._events[type];
      } else if (this._events[type] === listener) {
        delete this._events[type];
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function(type) {
      if (type && this._events && this._events[type])
        this._events[type] = null;
      return this;
    };
    EventEmitter.prototype.listeners = function(type) {
      if (!this._events)
        this._events = {};
      if (!this._events[type])
        this._events[type] = [];
      if (!isArray(this._events[type])) {
        this._events[type] = [this._events[type]];
      }
      return this._events[type];
    };
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("lib/components/deps/utils", ["d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var d3 = require('d3');
  exports.calculateScales = function(chartWidth, chartHeight, xValues, yValues) {
    var xScale,
        yScale;
    if (xValues.length > 0 && Object.prototype.toString.call(xValues[0]) === '[object Date]') {
      xScale = d3.time.scale().range([0, chartWidth]);
    } else {
      xScale = d3.scale.linear().range([0, chartWidth]);
    }
    xScale.domain(d3.extent(xValues));
    if (yValues.length > 0 && Object.prototype.toString.call(yValues[0]) === '[object Date]') {
      yScale = d3.time.scale().range([chartHeight, 0]);
    } else {
      yScale = d3.scale.linear().range([chartHeight, 0]);
    }
    yScale.domain(d3.extent(yValues));
    return {
      xScale: xScale,
      yScale: yScale
    };
  };
  exports.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this,
          args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow)
        func.apply(context, args);
    };
  };
  exports.flattenData = function(data, xAccessor, yAccessor) {
    var allValues = [];
    var xValues = [];
    var yValues = [];
    var coincidentCoordinateCheck = {};
    data.forEach(function(series) {
      series.values.forEach(function(item, idx) {
        if (isNaN(xAccessor(item)) || isNaN(yAccessor(item))) {
          return;
        }
        var x = xAccessor(item);
        var y = yAccessor(item);
        xValues.push(x);
        yValues.push(y);
        var xyCoords = (x + "-" + y);
        if (xyCoords in coincidentCoordinateCheck) {
          return;
        }
        coincidentCoordinateCheck[xyCoords] = '';
        var pointItem = {
          coord: {
            x: x,
            y: y
          },
          id: (series.name + "-" + idx)
        };
        allValues.push(pointItem);
      });
    });
    return {
      allValues: allValues,
      xValues: xValues,
      yValues: yValues
    };
  };
  exports.shade = function(hex, percent) {
    var R,
        G,
        B,
        red,
        green,
        blue,
        number;
    var min = Math.min,
        round = Math.round;
    if (hex.length !== 7) {
      return hex;
    }
    number = parseInt(hex.slice(1), 16);
    R = number >> 16;
    G = number >> 8 & 0xFF;
    B = number & 0xFF;
    red = min(255, round((1 + percent) * R)).toString(16);
    green = min(255, round((1 + percent) * G)).toString(16);
    blue = min(255, round((1 + percent) * B)).toString(16);
    return ("#" + red + green + blue);
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:base64-js@0.0.8/lib/b64", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  ;
  (function(exports) {
    'use strict';
    var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
    var PLUS = '+'.charCodeAt(0);
    var SLASH = '/'.charCodeAt(0);
    var NUMBER = '0'.charCodeAt(0);
    var LOWER = 'a'.charCodeAt(0);
    var UPPER = 'A'.charCodeAt(0);
    var PLUS_URL_SAFE = '-'.charCodeAt(0);
    var SLASH_URL_SAFE = '_'.charCodeAt(0);
    function decode(elt) {
      var code = elt.charCodeAt(0);
      if (code === PLUS || code === PLUS_URL_SAFE)
        return 62;
      if (code === SLASH || code === SLASH_URL_SAFE)
        return 63;
      if (code < NUMBER)
        return -1;
      if (code < NUMBER + 10)
        return code - NUMBER + 26 + 26;
      if (code < UPPER + 26)
        return code - UPPER;
      if (code < LOWER + 26)
        return code - LOWER + 26;
    }
    function b64ToByteArray(b64) {
      var i,
          j,
          l,
          tmp,
          placeHolders,
          arr;
      if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      var len = b64.length;
      placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
      arr = new Arr(b64.length * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? b64.length - 4 : b64.length;
      var L = 0;
      function push(v) {
        arr[L++] = v;
      }
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
        push((tmp & 0xFF0000) >> 16);
        push((tmp & 0xFF00) >> 8);
        push(tmp & 0xFF);
      }
      if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
        push(tmp & 0xFF);
      } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
        push((tmp >> 8) & 0xFF);
        push(tmp & 0xFF);
      }
      return arr;
    }
    function uint8ToBase64(uint8) {
      var i,
          extraBytes = uint8.length % 3,
          output = "",
          temp,
          length;
      function encode(num) {
        return lookup.charAt(num);
      }
      function tripletToBase64(num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
      }
      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output += tripletToBase64(temp);
      }
      switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode((temp << 4) & 0x3F);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
          output += encode(temp >> 10);
          output += encode((temp >> 4) & 0x3F);
          output += encode((temp << 2) & 0x3F);
          output += '=';
          break;
      }
      return output;
    }
    exports.toByteArray = b64ToByteArray;
    exports.fromByteArray = uint8ToBase64;
  }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  global.define = __define;
  return module.exports;
});



System.register("npm:ieee754@1.1.4/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e,
        m,
        eLen = nBytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        nBits = -7,
        i = isLE ? (nBytes - 1) : 0,
        d = isLE ? -1 : 1,
        s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
      ;
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
      ;
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e,
        m,
        c,
        eLen = nBytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
        i = isLE ? 0 : (nBytes - 1),
        d = isLE ? 1 : -1,
        s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8)
      ;
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8)
      ;
    buffer[offset + i - d] |= s * 128;
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:is-array@1.0.1/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var isArray = Array.isArray;
  var str = Object.prototype.toString;
  module.exports = isArray || function(val) {
    return !!val && '[object Array]' == str.call(val);
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:crypt@0.0.1/crypt", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function() {
    var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        crypt = {
          rotl: function(n, b) {
            return (n << b) | (n >>> (32 - b));
          },
          rotr: function(n, b) {
            return (n << (32 - b)) | (n >>> b);
          },
          endian: function(n) {
            if (n.constructor == Number) {
              return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
            }
            for (var i = 0; i < n.length; i++)
              n[i] = crypt.endian(n[i]);
            return n;
          },
          randomBytes: function(n) {
            for (var bytes = []; n > 0; n--)
              bytes.push(Math.floor(Math.random() * 256));
            return bytes;
          },
          bytesToWords: function(bytes) {
            for (var words = [],
                i = 0,
                b = 0; i < bytes.length; i++, b += 8)
              words[b >>> 5] |= bytes[i] << (24 - b % 32);
            return words;
          },
          wordsToBytes: function(words) {
            for (var bytes = [],
                b = 0; b < words.length * 32; b += 8)
              bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
            return bytes;
          },
          bytesToHex: function(bytes) {
            for (var hex = [],
                i = 0; i < bytes.length; i++) {
              hex.push((bytes[i] >>> 4).toString(16));
              hex.push((bytes[i] & 0xF).toString(16));
            }
            return hex.join('');
          },
          hexToBytes: function(hex) {
            for (var bytes = [],
                c = 0; c < hex.length; c += 2)
              bytes.push(parseInt(hex.substr(c, 2), 16));
            return bytes;
          },
          bytesToBase64: function(bytes) {
            for (var base64 = [],
                i = 0; i < bytes.length; i += 3) {
              var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
              for (var j = 0; j < 4; j++)
                if (i * 8 + j * 6 <= bytes.length * 8)
                  base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
                else
                  base64.push('=');
            }
            return base64.join('');
          },
          base64ToBytes: function(base64) {
            base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');
            for (var bytes = [],
                i = 0,
                imod4 = 0; i < base64.length; imod4 = ++i % 4) {
              if (imod4 == 0)
                continue;
              bytes.push(((base64map.indexOf(base64.charAt(i - 1)) & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2)) | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
            }
            return bytes;
          }
        };
    module.exports = crypt;
  })();
  global.define = __define;
  return module.exports;
});



System.register("npm:charenc@0.0.1/charenc", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var charenc = {
    utf8: {
      stringToBytes: function(str) {
        return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
      },
      bytesToString: function(bytes) {
        return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
      }
    },
    bin: {
      stringToBytes: function(str) {
        for (var bytes = [],
            i = 0; i < str.length; i++)
          bytes.push(str.charCodeAt(i) & 0xFF);
        return bytes;
      },
      bytesToString: function(bytes) {
        for (var str = [],
            i = 0; i < bytes.length; i++)
          str.push(String.fromCharCode(bytes[i]));
        return str.join('');
      }
    }
  };
  module.exports = charenc;
  global.define = __define;
  return module.exports;
});



System.register("npm:escape-html@1.0.1/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = function(html) {
    return String(html).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:valid-media-queries@0.0.3/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function isValidRatio(ratio) {
    var re = /\d+\/\d+/;
    return !!ratio.match(re);
  }
  function isValidInteger(integer) {
    var re = /\d+/;
    return !!integer.match(re);
  }
  function isValidLength(length) {
    var re = /\d+(?:ex|em|ch|rem|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc)?$/;
    return !!length.match(re);
  }
  function isValidOrientation(orientation) {
    return orientation === 'landscape' || orientation === 'portrait';
  }
  function isValidScan(scan) {
    return scan === 'progressive' || scan === 'interlace';
  }
  function isValidResolution(resolution) {
    var re = /(?:\+|-)?(?:\d+|\d*\.\d+)(?:e\d+)?(?:dpi|dpcm|dppx)$/;
    return !!resolution.match(re);
  }
  function isValidValue(value) {
    return value != null && typeof value !== 'boolean' && value !== '';
  }
  var _mediaFeatureValidator = {
    'width': isValidLength,
    'min-width': isValidLength,
    'max-width': isValidLength,
    'height': isValidLength,
    'min-height': isValidLength,
    'max-height': isValidLength,
    'device-width': isValidLength,
    'min-device-width': isValidLength,
    'max-device-width': isValidLength,
    'device-height': isValidLength,
    'min-device-height': isValidLength,
    'max-device-height': isValidLength,
    'aspect-ratio': isValidRatio,
    'min-aspect-ratio': isValidRatio,
    'max-aspect-ratio': isValidRatio,
    'device-aspect-ratio': isValidRatio,
    'min-device-aspect-ratio': isValidRatio,
    'max-device-aspect-ratio': isValidRatio,
    'color': isValidValue,
    'min-color': isValidValue,
    'max-color': isValidValue,
    'color-index': isValidInteger,
    'min-color-index': isValidInteger,
    'max-color-index': isValidInteger,
    'monochrome': isValidInteger,
    'min-monochrome': isValidInteger,
    'max-monochrome': isValidInteger,
    'resolution': isValidResolution,
    'min-resolution': isValidResolution,
    'max-resolution': isValidResolution,
    'scan': isValidScan,
    'grid': isValidInteger,
    'orientation': isValidOrientation
  };
  var _validMediaFeatures = {
    'width': true,
    'min-width': true,
    'max-width': true,
    'height': true,
    'min-height': true,
    'max-height': true,
    'device-width': true,
    'min-device-width': true,
    'max-device-width': true,
    'device-height': true,
    'min-device-height': true,
    'max-device-height': true,
    'aspect-ratio': true,
    'min-aspect-ratio': true,
    'max-aspect-ratio': true,
    'device-aspect-ratio': true,
    'min-device-aspect-ratio': true,
    'max-device-aspect-ratio': true,
    'color': true,
    'min-color': true,
    'max-color': true,
    'color-index': true,
    'min-color-index': true,
    'max-color-index': true,
    'monochrome': true,
    'min-monochrome': true,
    'max-monochrome': true,
    'resolution': true,
    'min-resolution': true,
    'max-resolution': true,
    'scan': true,
    'grid': true,
    'orientation': true
  };
  var _validMediaTypes = {
    'all': true,
    'aural': true,
    'braille': true,
    'handheld': true,
    'print': true,
    'projection': true,
    'screen': true,
    'tty': true,
    'tv': true,
    'embossed': true
  };
  var _validQualifiers = {
    'not': true,
    'only': true
  };
  function isValidFeature(feature) {
    return !!_validMediaFeatures[feature];
  }
  function isValidQualifier(qualifier) {
    return !!_validQualifiers[qualifier];
  }
  function isValidMediaType(mediaType) {
    return !!_validMediaTypes[mediaType];
  }
  function isValidQualifiedMediaType(mediaType) {
    var terms = mediaType.trim().split(/\s+/);
    switch (terms.length) {
      case 1:
        return isValidMediaType(terms[0]);
      case 2:
        return isValidQualifier(terms[0]) && isValidMediaType(terms[1]);
      default:
        return false;
    }
  }
  function isValidExpression(expression) {
    if (expression.length < 2) {
      return false;
    }
    if (expression[0] !== '(' || expression[expression.length - 1] !== ')') {
      return false;
    }
    expression = expression.substring(1, expression.length - 1);
    var featureAndValue = expression.split(/\s*:\s*/);
    switch (featureAndValue.length) {
      case 1:
        var feature = featureAndValue[0].trim();
        return isValidFeature(feature);
      case 2:
        var feature = featureAndValue[0].trim();
        var value = featureAndValue[1].trim();
        return isValidFeature(feature) && _mediaFeatureValidator[feature](value);
      default:
        return false;
    }
  }
  function isValidMediaQuery(query) {
    var andSplitter = /\s+and\s+/;
    var queryTerms = query.split(andSplitter);
    return (isValidQualifiedMediaType(queryTerms[0]) || isValidExpression(queryTerms[0])) && queryTerms.slice(1).every(isValidExpression);
  }
  function isValidMediaQueryList(mediaQuery) {
    mediaQuery = mediaQuery.toLowerCase();
    if (mediaQuery.substring(0, 6) !== '@media') {
      return false;
    }
    var commaSplitter = /\s*,\s*/;
    var queryList = mediaQuery.substring(7, mediaQuery.length).split(commaSplitter);
    return queryList.every(isValidMediaQuery);
  }
  module.exports = isValidMediaQueryList;
  global.define = __define;
  return module.exports;
});



System.register("npm:valid-css-props@0.0.5/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var _validCSSProps = {
    'align-content': true,
    'align-items': true,
    'align-self': true,
    'alignment-adjust': true,
    'alignment-baseline': true,
    'animation': true,
    'animation-delay': true,
    'animation-direction': true,
    'animation-duration': true,
    'animation-iteration-count': true,
    'animation-name': true,
    'animation-play-state': true,
    'animation-timing-function': true,
    'appearance': true,
    'backface-visibility': true,
    'background': true,
    'background-attachment': true,
    'background-clip': true,
    'background-color': true,
    'background-image': true,
    'background-origin': true,
    'background-position': true,
    'background-repeat': true,
    'background-size': true,
    'baseline-shift': true,
    'bookmark-label': true,
    'bookmark-level': true,
    'bookmark-target': true,
    'border': true,
    'border-bottom': true,
    'border-bottom-color': true,
    'border-bottom-left-radius': true,
    'border-bottom-right-radius': true,
    'border-bottom-style': true,
    'border-bottom-width': true,
    'border-collapse': true,
    'border-color': true,
    'border-image': true,
    'border-image-outset': true,
    'border-image-repeat': true,
    'border-image-slice': true,
    'border-image-source': true,
    'border-image-width': true,
    'border-left': true,
    'border-left-color': true,
    'border-left-style': true,
    'border-left-width': true,
    'border-radius': true,
    'border-right': true,
    'border-right-color': true,
    'border-right-style': true,
    'border-right-width': true,
    'border-spacing': true,
    'border-style': true,
    'border-top': true,
    'border-top-color': true,
    'border-top-left-radius': true,
    'border-top-right-radius': true,
    'border-top-style': true,
    'border-top-width': true,
    'border-width': true,
    'bottom': true,
    'box-align': true,
    'box-decoration-break': true,
    'box-direction': true,
    'box-flex': true,
    'box-flex-group': true,
    'box-lines': true,
    'box-ordinal-group': true,
    'box-orient': true,
    'box-pack': true,
    'box-shadow': true,
    'box-sizing': true,
    'caption-side': true,
    'clear': true,
    'clip': true,
    'color': true,
    'color-profile': true,
    'column-count': true,
    'column-fill': true,
    'column-gap': true,
    'column-rule': true,
    'column-rule-color': true,
    'column-rule-style': true,
    'column-rule-width': true,
    'column-span': true,
    'column-width': true,
    'columns': true,
    'content': true,
    'counter-increment': true,
    'counter-reset': true,
    'crop': true,
    'cursor': true,
    'direction': true,
    'display': true,
    'dominant-baseline': true,
    'drop-initial-after-adjust': true,
    'drop-initial-after-align': true,
    'drop-initial-before-adjust': true,
    'drop-initial-before-align': true,
    'drop-initial-size': true,
    'drop-initial-value': true,
    'empty-cells': true,
    'fit': true,
    'fit-position': true,
    'flex': true,
    'flex-basis': true,
    'flex-direction': true,
    'flex-flow': true,
    'flex-grow': true,
    'flex-shrink': true,
    'flex-wrap': true,
    'float': true,
    'float-offset': true,
    'font': true,
    'font-family': true,
    'font-size': true,
    'font-size-adjust': true,
    'font-stretch': true,
    'font-style': true,
    'font-variant': true,
    'font-weight': true,
    'grid-columns': true,
    'grid-rows': true,
    'hanging-punctuation': true,
    'height': true,
    'hyphenate-after': true,
    'hyphenate-before': true,
    'hyphenate-character': true,
    'hyphenate-lines': true,
    'hyphenate-resource': true,
    'hyphens': true,
    'icon': true,
    'image-orientation': true,
    'image-resolution': true,
    'inline-box-align': true,
    'justify-content': true,
    'left': true,
    'letter-spacing': true,
    'line-height': true,
    'line-stacking': true,
    'line-stacking-ruby': true,
    'line-stacking-shift': true,
    'line-stacking-strategy': true,
    'list-style': true,
    'list-style-image': true,
    'list-style-position': true,
    'list-style-type': true,
    'margin': true,
    'margin-bottom': true,
    'margin-left': true,
    'margin-right': true,
    'margin-top': true,
    'mark': true,
    'mark-after': true,
    'mark-before': true,
    'marks': true,
    'marquee-direction': true,
    'marquee-play-count': true,
    'marquee-speed': true,
    'marquee-style': true,
    'max-height': true,
    'max-width': true,
    'min-height': true,
    'min-width': true,
    'move-to': true,
    'nav-down': true,
    'nav-index': true,
    'nav-left': true,
    'nav-right': true,
    'nav-up': true,
    'opacity': true,
    'order': true,
    'orphans': true,
    'outline': true,
    'outline-color': true,
    'outline-offset': true,
    'outline-style': true,
    'outline-width': true,
    'overflow': true,
    'overflow-scrolling': true,
    'overflow-style': true,
    'overflow-x': true,
    'overflow-y': true,
    'padding': true,
    'padding-bottom': true,
    'padding-left': true,
    'padding-right': true,
    'padding-top': true,
    'page': true,
    'page-break-after': true,
    'page-break-before': true,
    'page-break-inside': true,
    'page-policy': true,
    'perspective': true,
    'perspective-origin': true,
    'phonemes': true,
    'pointer-events': true,
    'position': true,
    'punctuation-trim': true,
    'quotes': true,
    'rendering-intent': true,
    'resize': true,
    'rest': true,
    'rest-after': true,
    'rest-before': true,
    'right': true,
    'rotation': true,
    'rotation-point': true,
    'ruby-align': true,
    'ruby-overhang': true,
    'ruby-position': true,
    'ruby-span': true,
    'size': true,
    'string-set': true,
    'table-layout': true,
    'target': true,
    'target-name': true,
    'target-new': true,
    'target-position': true,
    'text-align': true,
    'text-align-last': true,
    'text-decoration': true,
    'text-height': true,
    'text-indent': true,
    'text-justify': true,
    'text-outline': true,
    'text-overflow': true,
    'text-shadow': true,
    'text-transform': true,
    'text-wrap': true,
    'top': true,
    'transform': true,
    'transform-origin': true,
    'transform-style': true,
    'transition': true,
    'transition-delay': true,
    'transition-duration': true,
    'transition-property': true,
    'transition-timing-function': true,
    'unicode-bidi': true,
    'user-select': true,
    'vertical-align': true,
    'visibility': true,
    'voice-balance': true,
    'voice-duration': true,
    'voice-pitch': true,
    'voice-pitch-range': true,
    'voice-rate': true,
    'voice-stress': true,
    'voice-volume': true,
    'white-space': true,
    'widows': true,
    'width': true,
    'word-break': true,
    'word-spacing': true,
    'word-wrap': true,
    'z-index': true
  };
  var vendorPrefixRegEx = /^-.+-/;
  module.exports = function(prop) {
    if (prop[0] === '-') {
      return !!_validCSSProps[prop.replace(vendorPrefixRegEx, '')];
    }
    return !!_validCSSProps[prop];
  };
  global.define = __define;
  return module.exports;
});



System.register("lib/components/react-checkbox-group.jsx!github:floatdrop/plugin-jsx@0.1.1", ["react", "lodash"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require('react');
  var _ = require('lodash');
  var CheckboxGroup = module.exports = React.createClass({
    displayName: "exports",
    getInitialState: function() {
      return {
        defaultValue: this.props.defaultValue || [],
        checkedBoxes: []
      };
    },
    componentDidMount: function() {
      this.setCheckboxNames();
      this.setCheckedBoxes();
    },
    componentDidUpdate: function() {
      this.setCheckboxNames();
      this.setCheckedBoxes();
    },
    render: function() {
      return this.transferPropsTo(React.createElement("div", {onChange: this.props.onChange}, this.props.children));
    },
    setCheckboxNames: function() {
      var $checkboxes = this.getCheckboxes();
      for (var i = 0,
          length = $checkboxes.length; i < length; i++) {
        $checkboxes[i].setAttribute('name', this.props.name);
      }
    },
    getCheckboxes: function() {
      return this.getDOMNode().querySelectorAll('input[type="checkbox"]');
    },
    setCheckedBoxes: function() {
      var $checkboxes = this.getCheckboxes();
      var destinationValue = this.props.value != null ? this.props.value : this.state.defaultValue;
      var oldstate = this.state.checkedBoxes;
      var checkedunsorted = [];
      for (var i = 0,
          length = $checkboxes.length; i < length; i++) {
        var $checkbox = $checkboxes[i];
        if (destinationValue.indexOf($checkbox.value) >= 0) {
          $checkbox.checked = true;
          checkedunsorted.push($checkbox.value);
        }
      }
      var newchecked = _.difference(checkedunsorted, oldstate);
      var unchecked = _.difference(oldstate, checkedunsorted);
      var newstate = oldstate.concat(newchecked);
      var stateintersect = _.intersection(oldstate, checkedunsorted);
      if (unchecked.length > 0) {
        newstate = stateintersect;
      }
      var is_same = (newstate.length == oldstate.length) && newstate.every(function(element, index) {
        return element === oldstate[index];
      });
      if (!is_same) {
        this.setState({'checkedBoxes': newstate});
      }
    },
    getCheckedValues: function() {
      var $checkboxes = this.getCheckboxes();
      var checkedunsorted = [];
      for (var i = 0,
          length = $checkboxes.length; i < length; i++) {
        if ($checkboxes[i].checked) {
          checkedunsorted.push($checkboxes[i].value);
        }
      }
      var oldstate = this.state.checkedBoxes;
      if (checkedunsorted.length < oldstate.length) {
        var stateintersect = _.intersection(oldstate, checkedunsorted);
        return stateintersect;
      }
      if (checkedunsorted.length > oldstate.length) {
        var newchecked = _.difference(checkedunsorted, oldstate);
        return oldstate.concat(newchecked);
      }
      return oldstate;
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:classnames@1.1.4/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function classNames() {
    var args = arguments;
    var classes = [];
    for (var i = 0; i < args.length; i++) {
      var arg = args[i];
      if (!arg) {
        continue;
      }
      if ('string' === typeof arg || 'number' === typeof arg) {
        classes.push(arg);
      } else if ('object' === typeof arg) {
        for (var key in arg) {
          if (!arg.hasOwnProperty(key) || !arg[key]) {
            continue;
          }
          classes.push(key);
        }
      }
    }
    return classes.join(' ');
  }
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = classNames;
  }
  global.define = __define;
  return module.exports;
});



System.register("lib/components/bid-lp-solver.jsx!github:floatdrop/plugin-jsx@0.1.1", ["d3", "lodash", "immutable"], function($__export) {
  "use strict";
  var __moduleName = "lib/components/bid-lp-solver.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var d3,
      _,
      Immutable,
      LPResultRef,
      OrderBookRef,
      job,
      logText,
      Auctioneer;
  function transpose(a) {
    return a[0].map(function(_, c) {
      return a.map(function(r) {
        return r[c];
      });
    });
  }
  function roundToTwo(decimal_num) {
    return Math.round(100 * decimal_num) / 100;
  }
  function genIDMatrix(states) {
    var id_matrix = states.map((function(q, i) {
      return states.map((function(l, j) {
        return (i == j) ? 1 : 0;
      }));
    }));
    return id_matrix;
  }
  function generateBidLine(states, quantity, price_offset) {
    var uniform_price = 1 / states.length;
    var bid_prices = states.map((function(q) {
      return roundToTwo(uniform_price - price_offset);
    }));
    var bid_quantities = bid_prices.map((function(p, i) {
      return quantity;
    }));
    return {
      'prices': bid_prices,
      'quantities': bid_quantities
    };
  }
  function generateMMbids(bid_vector) {
    var states = new Array(bid_vector.length).fill(0);
    var bid_matrix = genIDMatrix(states);
    var line_price_offsets = d3.range(0, 20, 3).map((function(p) {
      return p / 100;
    }));
    var bid_quantity = 20;
    var line_count = line_price_offsets.length;
    var bid_lines = line_price_offsets.map((function(price_offset, i) {
      return generateBidLine(states, bid_quantity, price_offset);
    }));
    var mm_bid_matrix = bid_lines.reduce((function(memo, bl, i) {
      var id_matrix = genIDMatrix(states);
      return memo.concat(id_matrix);
    }), []);
    var mm_bid_prices = bid_lines.reduce((function(memo, bid_line, i) {
      return memo.concat(bid_line.prices);
    }), []);
    var mm_bid_quantities = bid_lines.reduce((function(memo, bid_line, i) {
      return memo.concat(bid_line.quantities);
    }), []);
    return {
      'bid_matrix': mm_bid_matrix,
      'bid_prices': mm_bid_prices,
      'bid_quantities': mm_bid_quantities
    };
  }
  function transformBidLinesToDataSeries(mm_bid_obj) {
    var num_of_states = mm_bid_obj.bid_matrix[0].length;
    var data_series_by_state = d3.range(0, num_of_states, 1).map((function(i) {
      return [];
    }));
    var ask_series_by_state = d3.range(0, num_of_states, 1).map((function(i) {
      return [];
    }));
    mm_bid_obj.bid_matrix.forEach((function(bid_vector, row_i) {
      var bundle_price = mm_bid_obj.bid_prices[row_i];
      var bundle_quantity = mm_bid_obj.bid_quantities[row_i];
      bid_vector.forEach((function(col_val, state_j) {
        var bid_data_point = {};
        var shares_amount = col_val;
        bid_data_point.price = shares_amount * bundle_price;
        bid_data_point.quantity = bundle_quantity;
        if (bid_data_point.price > 0 && bid_data_point.quantity > 0) {
          data_series_by_state[state_j].push({
            'x': bid_data_point.price,
            'y': bid_data_point.quantity,
            'bid_i': row_i
          });
          var atomic_bid_price = bid_data_point.price;
          var uniform_bid_price = 1 / (bid_vector.length);
          uniform_bid_price = Math.round(1000 * uniform_bid_price) / 1000;
          var diff_from_uni = Math.abs(uniform_bid_price - atomic_bid_price);
          var uniform_ask_price = diff_from_uni * (bid_vector.length - 1) + uniform_bid_price;
          var uniform_ask_quantity = bid_data_point.quantity;
          bid_vector.forEach((function(b, i) {
            if (i !== state_j) {
              var new_ask = {
                'x': uniform_ask_price,
                'y': uniform_ask_quantity,
                'bid_i': row_i
              };
              if (ask_series_by_state[i].findIndex((function(ask) {
                return (ask.x == new_ask.x && ask.y == new_ask.y);
              })) == -1) {
                ask_series_by_state[i].push(new_ask);
              }
            }
          }));
        }
      }));
    }));
    var data_cum_depth = data_series_by_state.map((function(state_series) {
      var new_series = state_series.map((function(bid, point_i) {
        var cum_depth = state_series.slice(0, point_i).reduce((function(memo, bp) {
          return bp.y + memo;
        }), 0);
        var new_bid = {};
        new_bid.y = bid.y + cum_depth;
        new_bid.x = bid.x;
        new_bid.bid_i = bid.bid_i;
        return new_bid;
      }));
      return new_series;
    }));
    var ask_cum_depth = ask_series_by_state.map((function(ask_series) {
      var new_series = ask_series.map((function(ask, point_i) {
        var cum_depth = ask_series.slice(0, point_i).reduce((function(memo, ap) {
          return ap.y + memo;
        }), 0);
        var new_ask = {};
        new_ask.y = ask.y + cum_depth;
        new_ask.x = ask.x;
        new_ask.bid_i = ask.bid_i;
        return new_ask;
      }));
      return new_series;
    }));
    var depth_line_data = data_cum_depth.map((function(series, i) {
      var y_max = d3.max(series, (function(d) {
        return d.y;
      }));
      var x_max = d3.max(series, (function(d) {
        return d.x;
      }));
      var series_plus = series.concat({
        'x': 0,
        'y': y_max,
        'endpoint': true
      });
      series_plus.splice(0, 0, {
        'x': x_max,
        'y': 0,
        'endpoint': true
      });
      var x_min = d3.min(ask_cum_depth[i], (function(d) {
        return d.x;
      }));
      var y_max = d3.max(ask_cum_depth[i], (function(d) {
        return d.y;
      }));
      ask_cum_depth[i].splice(0, 0, {
        'x': x_min,
        'y': 0,
        'endpoint': true
      });
      ask_cum_depth[i] = ask_cum_depth[i].concat({
        'x': 1,
        'y': y_max,
        'endpoint': true
      });
      return [{
        name: 'bid depth',
        values: series_plus
      }, {
        name: 'ask depth',
        values: ask_cum_depth[i]
      }];
    }));
    return depth_line_data;
  }
  function toCplexDefinition(bid_table) {
    var bid_vec = bid_table[0].bid_portfolio;
    var mm_bids = generateMMbids(bid_vec);
    var mm_bids_chart_series = transformBidLinesToDataSeries(mm_bids);
    var bid_prices = mm_bids.bid_prices.concat(bid_table.map((function(bid) {
      return bid.bid_price;
    })));
    var bid_quantities = mm_bids.bid_quantities.concat(bid_table.map((function(b) {
      return b.bid_quantity;
    })));
    var bid_matrix = transpose(mm_bids.bid_matrix.concat(bid_table.map((function(b) {
      return b.bid_portfolio;
    }))));
    var Objective = "obj:" + bid_prices.map((function(p, i) {
      return (" + " + p + "x" + (i + 1));
    })).join("") + " - 1y1";
    var Bounds = bid_quantities.map((function(q, i) {
      return ("0 <= x" + (i + 1) + " <= " + q);
    })).join("\n");
    Bounds = Bounds + "\n" + "0 <= y1";
    var Constraints = bid_matrix.map((function(row, i) {
      var line = ("lim_" + (i + 1) + ": ") + row.map((function(col, j) {
        return (" + " + bid_matrix[i][j] + "x" + (j + 1));
      })).join("");
      line = line + " - 1y1 <= 0";
      return line;
    })).join("\n");
    var Generals = bid_prices.map((function(q, i) {
      return ("x" + (i + 1));
    })).join("\n") + "\n" + "y1";
    var cplexDef = "Maximize\n" + Objective + "\n\n" + "Subject To\n" + Constraints + "\n\n" + "Bounds\n" + Bounds + "\n\n" + "Generals\n" + Generals + "\n\n" + "End" + "\n";
    console.log('CPLEX LP Problem Definition:');
    console.log(cplexDef);
    return cplexDef;
  }
  function generateAndRunCplex(ob_ref) {
    OrderBookRef = ob_ref;
    var bid_table_obj = ob_ref.cursor().deref().toJS();
    var bid_matrix = bid_table_obj.bid_table;
    var bid_prices = bid_table_obj.bid_prices;
    var bid_quantities = bid_table_obj.bid_quantities;
    var cplex_input = bid_matrix.map((function(bundle, row_i) {
      return {
        'bid_portfolio': bundle,
        'bid_price': bid_prices[row_i],
        'bid_quantity': bid_quantities[row_i]
      };
    }));
    var bid_matching_cplex = toCplexDefinition(cplex_input);
    run(bid_matching_cplex);
  }
  function log(value) {
    console.log(value);
    logText = logText + value + "\n";
  }
  function run(cplex_def) {
    job = new Worker("lib/components/deps/glpk-main.js");
    job.onmessage = function(e) {
      var obj = e.data;
      switch (obj.action) {
        case 'log':
          log(obj.message);
          break;
        case 'done':
          stop();
          log(JSON.stringify(obj.result));
          console.log('glpk worker job done. result:', obj.result);
          LPResultRef.cursor().update('bids_lp_result', (function(oldVec) {
            return Immutable.fromJS(obj.result);
          }));
          break;
      }
    };
    logText = '';
    console.log('running glpk worker.');
    job.postMessage({
      action: 'load',
      data: cplex_def,
      mip: false
    });
  }
  function stop() {
    if (job != null) {
      job.terminate();
      job = null;
    }
  }
  return {
    setters: [function(m) {
      d3 = m.default;
    }, function(m) {
      _ = m.default;
    }, function(m) {
      Immutable = m.default;
    }],
    execute: function() {
      logText = '';
      Auctioneer = (function() {
        var Auctioneer = function Auctioneer() {
          this.generateMMbids = generateMMbids;
          this.transformBidLinesToDataSeries = transformBidLinesToDataSeries;
        };
        return ($traceurRuntime.createClass)(Auctioneer, {init: function(orderbook_ref, bid_table_ref, lp_result_ref) {
            orderbook_ref.observe(function(test_val) {
              generateAndRunCplex(orderbook_ref);
            });
            LPResultRef = lp_result_ref;
            generateAndRunCplex(orderbook_ref);
          }}, {});
      }());
      $__export('default', new Auctioneer());
    }
  };
});



System.register("lib/components/msr-functions.jsx!github:floatdrop/plugin-jsx@0.1.1", ["d3", "lodash"], function($__export) {
  "use strict";
  var __moduleName = "lib/components/msr-functions.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var d3,
      _,
      MSR;
  function costLMSR(b, state_vector) {
    var lmsr_sum = state_vector.reduce((function(memo, q) {
      return memo + Math.exp(q / b);
    }), 0);
    var cost = b * Math.log(lmsr_sum);
    return cost;
  }
  function priceLMSR(b, state_vector, q_i) {
    var lmsr_sum = state_vector.reduce((function(memo, q) {
      return memo + Math.exp(q / b);
    }), 0);
    var prices;
    if (q_i === undefined) {
      prices = state_vector.map((function(q) {
        return Math.exp(q / b) / lmsr_sum;
      }));
    } else {
      prices = Math.exp(state_vector[q_i] / b) / lmsr_sum;
    }
    return prices;
  }
  function depthLMSR(b, state_vector, p) {
    var prices = priceLMSR(b, state_vector);
    var depths = state_vector.map((function(q_state, q_i) {
      var lmsr_sum = state_vector.reduce((function(memo, q, i) {
        return (i == q_i) ? memo + 0 : memo + Math.exp(q / b);
      }), 0);
      var depth_q_i = b * Math.log(lmsr_sum * p / (1 - p));
      var additional_shares_needed = depth_q_i - q_state;
      return additional_shares_needed;
    }));
    var costs = depths.map((function(q_i_shares, i) {
      var q_bundle = Array.from(state_vector);
      q_bundle[i] += q_i_shares;
      var cost = costLMSR(b, q_bundle) - costLMSR(b, state_vector);
      return cost;
    }));
    return costs;
  }
  function depthShortLMSR(b, state_vector, p, q_i) {
    var q_range = d3.range(0, 4, 0.25).map((function(i) {
      return i * b;
    }));
    var costs_and_prices = q_range.map((function(q_add) {
      var q_bundle = state_vector.map((function(q, i) {
        return (i == q_i) ? q : q + q_add;
      }));
      var cost = costLMSR(b, q_bundle) - costLMSR(b, state_vector);
      var qi_price = priceLMSR(b, q_bundle, q_i);
      return {
        'cost': cost,
        'price': qi_price
      };
    }));
    return costs_and_prices;
  }
  function getSharesAmountFromCost(cost_to_spend, q_i, b, state_vector) {
    var lmsr_sum_all = state_vector.reduce((function(memo, q) {
      return memo + Math.exp(q / b);
    }), 0);
    var lmsr_sum_qj = state_vector.reduce((function(memo, q, i) {
      return (i == q_i) ? memo + 0 : memo + Math.exp(q / b);
    }), 0);
    var shares_amount = state_vector[q_i] - b * Math.log((Math.exp(cost_to_spend / b) * lmsr_sum_all) - lmsr_sum_qj);
    return Math.abs(shares_amount);
  }
  return {
    setters: [function(m) {
      d3 = m.default;
    }, function(m) {
      _ = m.default;
    }],
    execute: function() {
      MSR = (function() {
        var MSR = function MSR() {
          this.costLMSR = costLMSR;
          this.priceLMSR = priceLMSR;
          this.depthLMSR = depthLMSR;
          this.getSharesAmountFromCost = getSharesAmountFromCost;
          this.depthShortLMSR = depthShortLMSR;
        };
        return ($traceurRuntime.createClass)(MSR, {init: function(orderbook_ref, bid_table_ref, lp_result_ref) {}}, {});
      }());
      $__export('default', new MSR());
    }
  };
});



System.register("lib/components/react-tangle-nodiv.jsx!github:floatdrop/plugin-jsx@0.1.1", ["react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require('react');
  var TangleText = React.createClass({
    displayName: "TangleText",
    propTypes: {
      value: React.PropTypes.number.isRequired,
      onChange: React.PropTypes.func.isRequired,
      min: React.PropTypes.number,
      max: React.PropTypes.number,
      step: React.PropTypes.number,
      pixelDistance: React.PropTypes.number,
      className: React.PropTypes.string,
      onInput: React.PropTypes.func,
      format: React.PropTypes.func
    },
    getDefaultProps: function() {
      return {
        min: -Infinity,
        max: Infinity,
        step: 1,
        pixelDistance: null,
        className: 'react-tangle-input',
        format: function(x) {
          return x;
        },
        onInput: function() {}
      };
    },
    componentWillMount: function() {
      this.__isMouseDown = false;
    },
    componentWillReceiveProps: function(nextProps) {
      this.setState({value: nextProps.value});
    },
    getInitialState: function() {
      return {value: this.props.value};
    },
    bounds: function(num) {
      num = Math.max(num, this.props.min);
      num = Math.min(num, this.props.max);
      return num;
    },
    onChange: function(e) {
      this.setState({value: e.target.value});
    },
    onBlur: function(e) {
      var parsed = parseFloat(this.state.value);
      if (isNaN(parsed)) {
        this.setState({value: this.props.value});
      } else {
        this.props.onChange(this.bounds(parsed));
        this.setState({value: this.bounds(parsed)});
      }
    },
    onMouseMove: function(e) {
      var change;
      if (this.props.pixelDistance > 0) {
        change = Math.floor((this.startX - e.screenX) / this.props.pixelDistance);
      } else {
        change = this.startX - e.screenX;
      }
      this.dragged = true;
      var value = this.bounds(this.startValue - (change * this.props.step));
      this.setState({value: value});
      this.props.onInput(value);
    },
    onMouseDown: function(e) {
      if (e.target === document.activeElement || e.button !== 0)
        return;
      this.__isMouseDown = true;
      e.preventDefault();
      this.dragged = false;
      this.startX = e.screenX;
      this.startValue = this.state.value;
      window.addEventListener('mousemove', this.onMouseMove);
      window.addEventListener('mouseup', this.onMouseUp);
    },
    onMouseUp: function(e) {
      if (this.__isMouseDown) {
        e.preventDefault();
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('mouseup', this.onMouseUp);
        if (this.dragged)
          this.onBlur();
        this.__isMouseDown = false;
      }
    },
    onDoubleClick: function(e) {
      e.target.focus();
    },
    onKeyDown: function(e) {
      var value;
      if (e.which == 38) {
        e.preventDefault();
        value = this.state.value + this.props.step;
        this.setState({value: value});
        this.props.onInput(value);
      } else if (e.which == 40) {
        e.preventDefault();
        value = this.state.value - this.props.step;
        this.setState({value: value});
        this.props.onInput(value);
      } else if (e.which == 13) {
        this.onBlur(e);
        e.target.blur();
      }
    },
    render: function() {
      return (React.createElement("input", {
        className: this.props.className,
        disabled: this.props.disabled,
        type: "text",
        onChange: this.onChange,
        onMouseDown: this.onMouseDown,
        onKeyDown: this.onKeyDown,
        onMouseUp: this.onMouseUp,
        onDoubleClick: this.onDoubleClick,
        onBlur: this.onBlur,
        value: this.props.format(this.state.value)
      }));
    }
  });
  module.exports = TangleText;
  global.define = __define;
  return module.exports;
});



System.register("lib/components/deps/common.js!github:floatdrop/plugin-jsx@0.1.1", ["react", "d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require('react');
  var d3 = require('d3');
  exports.Chart = React.createClass({
    displayName: "Chart",
    render: function() {
      return (React.createElement("svg", {
        width: this.props.width,
        height: this.props.height
      }, this.props.children));
    }
  });
  exports.XAxis = React.createClass({
    displayName: "XAxis",
    componentWillReceiveProps: function(props) {
      var unit = props.xAxisTickInterval.unit;
      var interval = props.xAxisTickInterval.interval;
      var xAxis = d3.svg.axis().ticks(props.xAxisTickCount).ticks(d3.time[unit], interval).scale(props.xScale).orient("bottom");
      var node = this.refs.xaxis.getDOMNode();
      d3.select(node).attr("class", "x axis").call(xAxis);
      d3.select('.x.axis').selectAll('line').attr("shape-rendering", "crispEdges").attr("stroke", "#000");
      d3.select('.x.axis').select('path').attr("shape-rendering", "crispEdges").attr("fill", "none").attr("stroke", "#000");
    },
    render: function() {
      var t = "translate(0," + this.props.height + ")";
      return (React.createElement("g", {
        ref: "xaxis",
        className: "x axis",
        transform: t
      }));
    }
  });
  exports.YAxis = React.createClass({
    displayName: "YAxis",
    componentWillReceiveProps: function(props) {
      var yAxis = d3.svg.axis().ticks(props.yAxisTickCount).scale(props.yScale).orient("left");
      var node = this.refs.yaxis.getDOMNode();
      d3.select(node).attr("class", "y axis").call(yAxis);
    },
    render: function() {
      return (React.createElement("g", {
        ref: "yaxis",
        className: "y axis"
      }));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("lib/components/deps/stackedbarchart.js!github:floatdrop/plugin-jsx@0.1.1", ["react", "d3", "./common.js!jsx", "lodash"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require('react');
  var d3 = require('d3');
  var Chart = require('./common.js!jsx').Chart;
  var _ = require('lodash');
  var Bar = React.createClass({
    displayName: "Bar",
    propTypes: {
      fill: React.PropTypes.string,
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      offset: React.PropTypes.number
    },
    getDefaultProps: function() {
      return {offset: 0};
    },
    render: function() {
      return (React.createElement("rect", {
        fill: this.props.fill,
        width: this.props.width,
        height: this.props.height,
        x: this.props.x,
        y: this.props.y
      }));
    }
  });
  var XAxis = React.createClass({
    displayName: "XAxis",
    styleAxis: function() {
      var props = this.props;
      var xAxis = d3.svg.axis().scale(props.xScale).orient("bottom");
      var node = d3.select(this.refs.barxaxis.getDOMNode());
      node.attr("class", "barx axis").call(xAxis);
      node.selectAll('line').attr("shape-rendering", "crispEdges").attr("stroke", "#000");
      node.select('path').attr("shape-rendering", "crispEdges").attr("fill", "none").attr("stroke", "none");
    },
    componentDidMount: function() {
      this.styleAxis();
    },
    componentDidUpdate: function() {
      this.styleAxis();
    },
    render: function() {
      var t = "translate(0," + this.props.height + ")";
      return (React.createElement("g", {
        ref: "barxaxis",
        className: "barx axis",
        transform: t
      }));
    }
  });
  var YAxis = React.createClass({
    displayName: "YAxis",
    styleAxis: function() {
      var props = this.props;
      var yAxis = d3.svg.axis().ticks(props.yAxisTickCount).scale(props.yScale).orient("left");
      var node = this.refs.baryaxis.getDOMNode();
      d3.select(node).attr("class", "bary axis").call(yAxis);
      d3.selectAll('.bary.axis').selectAll('line').attr("shape-rendering", "crispEdges").attr("stroke", "#000");
      d3.selectAll('.bary.axis').select('path').attr("shape-rendering", "crispEdges").attr("fill", "none").attr("stroke", "#000");
    },
    componentDidMount: function() {
      this.styleAxis();
    },
    componentDidUpdate: function() {
      this.styleAxis();
    },
    render: function() {
      return (React.createElement("g", {
        ref: "baryaxis",
        className: "bary axis"
      }));
    }
  });
  var DataSeries = React.createClass({
    displayName: "DataSeries",
    propTypes: {
      fill: React.PropTypes.string,
      title: React.PropTypes.string,
      padding: React.PropTypes.number,
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      offset: React.PropTypes.number
    },
    getDefaultProps: function() {
      return {
        padding: 0.1,
        data: []
      };
    },
    render: function() {
      var props = this.props;
      var self = this;
      var refs = this._owner.refs;
      var xScale = d3.scale.ordinal().domain(d3.range(props.data.length)).rangeRoundBands([0, this.props.width], this.props.padding);
      var yScale = props.yScale;
      var seriesIndex = parseInt(self._currentElement.key.slice(-1));
      var otherSeries = _.chain(refs).values().reject(function(component, i) {
        var otherIndex = parseInt(component._currentElement.key.slice(-1));
        return (seriesIndex <= otherIndex);
      }).value();
      var memo = null;
      var yOffset = null;
      var bars = null;
      bars = _.map(props.data, function(point, i) {
        var yOffset = _.reduce(otherSeries, function(memo, series) {
          return memo + series.props.data[i];
        }, 0);
        return (React.createElement(Bar, {
          height: yScale(point),
          y: props.height - yScale(yOffset) - yScale(point),
          width: xScale.rangeBand(),
          x: xScale(i),
          fill: props.fill,
          key: self._rootNodeID + i
        }));
      });
      return (React.createElement("g", null, bars));
    }
  });
  var StackedBarChart = React.createClass({
    displayName: "StackedBarChart",
    getDefaultProps: function() {
      return {
        data: [],
        yAxisTickCount: 4,
        width: 500,
        height: 200,
        margins: {
          top: 20,
          right: 30,
          bottom: 30,
          left: 50
        },
        fill: "cornflowerblue"
      };
    },
    render: function() {
      var datavalues = this.props.data.series1;
      var labels = this.props.data.labels;
      var colors = this.props.data.colors;
      var margins = this.props.margins;
      var sideMargins = margins.left + margins.right;
      var topBottomMargins = margins.top + margins.bottom;
      var zipped = _.zip(this.props.data.series1, this.props.data.series2);
      var totals = _.map(zipped, function(values) {
        return _.reduce(values, function(memo, value) {
          return memo + value;
        }, 0);
      });
      var y_domain = [0, d3.max(totals)];
      if (this.props.yAxis) {
        y_domain = [this.props.yAxis[0], this.props.yAxis[1]];
      }
      var yScale = d3.scale.linear().domain(y_domain).range([this.props.height - topBottomMargins, 0]);
      var yScaleStacked = d3.scale.linear().domain(y_domain).range([0, this.props.height - topBottomMargins]);
      var xScale = d3.scale.ordinal().domain(labels).rangeRoundBands([0, this.props.width - sideMargins], 0.1);
      var trans = "translate(" + margins.left + "," + margins.top + ")";
      return (React.createElement(Chart, {
        width: this.props.width,
        height: this.props.height
      }, React.createElement("g", {transform: trans}, React.createElement(DataSeries, {
        ref: "series1",
        key: "series1",
        yScale: yScaleStacked,
        xScale: xScale,
        margins: margins,
        data: this.props.data.series1,
        width: this.props.width - sideMargins,
        height: this.props.height - topBottomMargins,
        fill: colors[0],
        color: colors[0]
      }), React.createElement(DataSeries, {
        ref: "series2",
        key: "series2",
        yScale: yScaleStacked,
        xScale: xScale,
        margins: margins,
        data: this.props.data.series2,
        width: this.props.width - sideMargins,
        height: this.props.height - topBottomMargins,
        fill: colors[1],
        color: colors[1]
      }), React.createElement(YAxis, {
        yScale: yScale,
        margins: margins,
        yAxisTickCount: this.props.yAxisTickCount,
        width: this.props.width - sideMargins,
        height: this.props.height - topBottomMargins
      }), React.createElement(XAxis, {
        xScale: xScale,
        margins: margins,
        width: this.props.width - sideMargins,
        height: this.props.height - topBottomMargins
      }))));
    }
  });
  exports.StackedBarChart = StackedBarChart;
  global.define = __define;
  return module.exports;
});



System.register("npm:process@0.10.1", ["npm:process@0.10.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.10.1/browser");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/warning", ["./emptyFunction", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyFunction = require("./emptyFunction");
    var warning = emptyFunction;
    if ("production" !== process.env.NODE_ENV) {
      warning = function(condition, format) {
        for (var args = [],
            $__0 = 2,
            $__1 = arguments.length; $__0 < $__1; $__0++)
          args.push(arguments[$__0]);
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          var argIndex = 0;
          console.warn('Warning: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
        }
      };
    }
    module.exports = warning;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventConstants", ["./keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyMirror = require("./keyMirror");
  var PropagationPhases = keyMirror({
    bubbled: null,
    captured: null
  });
  var topLevelTypes = keyMirror({
    topBlur: null,
    topChange: null,
    topClick: null,
    topCompositionEnd: null,
    topCompositionStart: null,
    topCompositionUpdate: null,
    topContextMenu: null,
    topCopy: null,
    topCut: null,
    topDoubleClick: null,
    topDrag: null,
    topDragEnd: null,
    topDragEnter: null,
    topDragExit: null,
    topDragLeave: null,
    topDragOver: null,
    topDragStart: null,
    topDrop: null,
    topError: null,
    topFocus: null,
    topInput: null,
    topKeyDown: null,
    topKeyPress: null,
    topKeyUp: null,
    topLoad: null,
    topMouseDown: null,
    topMouseMove: null,
    topMouseOut: null,
    topMouseOver: null,
    topMouseUp: null,
    topPaste: null,
    topReset: null,
    topScroll: null,
    topSelectionChange: null,
    topSubmit: null,
    topTextInput: null,
    topTouchCancel: null,
    topTouchEnd: null,
    topTouchMove: null,
    topTouchStart: null,
    topWheel: null
  });
  var EventConstants = {
    topLevelTypes: topLevelTypes,
    PropagationPhases: PropagationPhases
  };
  module.exports = EventConstants;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactContext", ["./Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var assign = require("./Object.assign");
  var ReactContext = {
    current: {},
    withContext: function(newContext, scopedCallback) {
      var result;
      var previousContext = ReactContext.current;
      ReactContext.current = assign({}, previousContext, newContext);
      try {
        result = scopedCallback();
      } finally {
        ReactContext.current = previousContext;
      }
      return result;
    }
  };
  module.exports = ReactContext;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactInstanceHandles", ["./ReactRootIndex", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactRootIndex = require("./ReactRootIndex");
    var invariant = require("./invariant");
    var SEPARATOR = '.';
    var SEPARATOR_LENGTH = SEPARATOR.length;
    var MAX_TREE_DEPTH = 100;
    function getReactRootIDString(index) {
      return SEPARATOR + index.toString(36);
    }
    function isBoundary(id, index) {
      return id.charAt(index) === SEPARATOR || index === id.length;
    }
    function isValidID(id) {
      return id === '' || (id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR);
    }
    function isAncestorIDOf(ancestorID, descendantID) {
      return (descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length));
    }
    function getParentID(id) {
      return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
    }
    function getNextDescendantID(ancestorID, destinationID) {
      ("production" !== process.env.NODE_ENV ? invariant(isValidID(ancestorID) && isValidID(destinationID), 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(isValidID(ancestorID) && isValidID(destinationID)));
      ("production" !== process.env.NODE_ENV ? invariant(isAncestorIDOf(ancestorID, destinationID), 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(isAncestorIDOf(ancestorID, destinationID)));
      if (ancestorID === destinationID) {
        return ancestorID;
      }
      var start = ancestorID.length + SEPARATOR_LENGTH;
      for (var i = start; i < destinationID.length; i++) {
        if (isBoundary(destinationID, i)) {
          break;
        }
      }
      return destinationID.substr(0, i);
    }
    function getFirstCommonAncestorID(oneID, twoID) {
      var minLength = Math.min(oneID.length, twoID.length);
      if (minLength === 0) {
        return '';
      }
      var lastCommonMarkerIndex = 0;
      for (var i = 0; i <= minLength; i++) {
        if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
          lastCommonMarkerIndex = i;
        } else if (oneID.charAt(i) !== twoID.charAt(i)) {
          break;
        }
      }
      var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
      ("production" !== process.env.NODE_ENV ? invariant(isValidID(longestCommonID), 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(isValidID(longestCommonID)));
      return longestCommonID;
    }
    function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
      start = start || '';
      stop = stop || '';
      ("production" !== process.env.NODE_ENV ? invariant(start !== stop, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(start !== stop));
      var traverseUp = isAncestorIDOf(stop, start);
      ("production" !== process.env.NODE_ENV ? invariant(traverseUp || isAncestorIDOf(start, stop), 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(traverseUp || isAncestorIDOf(start, stop)));
      var depth = 0;
      var traverse = traverseUp ? getParentID : getNextDescendantID;
      for (var id = start; ; id = traverse(id, stop)) {
        var ret;
        if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
          ret = cb(id, traverseUp, arg);
        }
        if (ret === false || id === stop) {
          break;
        }
        ("production" !== process.env.NODE_ENV ? invariant(depth++ < MAX_TREE_DEPTH, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop) : invariant(depth++ < MAX_TREE_DEPTH));
      }
    }
    var ReactInstanceHandles = {
      createReactRootID: function() {
        return getReactRootIDString(ReactRootIndex.createReactRootIndex());
      },
      createReactID: function(rootID, name) {
        return rootID + name;
      },
      getReactRootIDFromNodeID: function(id) {
        if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
          var index = id.indexOf(SEPARATOR, 1);
          return index > -1 ? id.substr(0, index) : id;
        }
        return null;
      },
      traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
        var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
        if (ancestorID !== leaveID) {
          traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
        }
        if (ancestorID !== enterID) {
          traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
        }
      },
      traverseTwoPhase: function(targetID, cb, arg) {
        if (targetID) {
          traverseParentPath('', targetID, cb, arg, true, false);
          traverseParentPath(targetID, '', cb, arg, false, true);
        }
      },
      traverseAncestors: function(targetID, cb, arg) {
        traverseParentPath('', targetID, cb, arg, true, false);
      },
      _getFirstCommonAncestorID: getFirstCommonAncestorID,
      _getNextDescendantID: getNextDescendantID,
      isAncestorIDOf: isAncestorIDOf,
      SEPARATOR: SEPARATOR
    };
    module.exports = ReactInstanceHandles;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactOwner", ["./emptyObject", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyObject = require("./emptyObject");
    var invariant = require("./invariant");
    var ReactOwner = {
      isValidOwner: function(object) {
        return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
      },
      addComponentAsRefTo: function(component, ref, owner) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactOwner.isValidOwner(owner), 'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to add a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(ReactOwner.isValidOwner(owner)));
        owner.attachRef(ref, component);
      },
      removeComponentAsRefFrom: function(component, ref, owner) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactOwner.isValidOwner(owner), 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to remove a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(ReactOwner.isValidOwner(owner)));
        if (owner.refs[ref] === component) {
          owner.detachRef(ref);
        }
      },
      Mixin: {
        construct: function() {
          this.refs = emptyObject;
        },
        attachRef: function(ref, component) {
          ("production" !== process.env.NODE_ENV ? invariant(component.isOwnedBy(this), 'attachRef(%s, ...): Only a component\'s owner can store a ref to it.', ref) : invariant(component.isOwnedBy(this)));
          var refs = this.refs === emptyObject ? (this.refs = {}) : this.refs;
          refs[ref] = component;
        },
        detachRef: function(ref) {
          delete this.refs[ref];
        }
      }
    };
    module.exports = ReactOwner;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactUpdates", ["./CallbackQueue", "./PooledClass", "./ReactCurrentOwner", "./ReactPerf", "./Transaction", "./Object.assign", "./invariant", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CallbackQueue = require("./CallbackQueue");
    var PooledClass = require("./PooledClass");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var ReactPerf = require("./ReactPerf");
    var Transaction = require("./Transaction");
    var assign = require("./Object.assign");
    var invariant = require("./invariant");
    var warning = require("./warning");
    var dirtyComponents = [];
    var asapCallbackQueue = CallbackQueue.getPooled();
    var asapEnqueued = false;
    var batchingStrategy = null;
    function ensureInjected() {
      ("production" !== process.env.NODE_ENV ? invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));
    }
    var NESTED_UPDATES = {
      initialize: function() {
        this.dirtyComponentsLength = dirtyComponents.length;
      },
      close: function() {
        if (this.dirtyComponentsLength !== dirtyComponents.length) {
          dirtyComponents.splice(0, this.dirtyComponentsLength);
          flushBatchedUpdates();
        } else {
          dirtyComponents.length = 0;
        }
      }
    };
    var UPDATE_QUEUEING = {
      initialize: function() {
        this.callbackQueue.reset();
      },
      close: function() {
        this.callbackQueue.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
    function ReactUpdatesFlushTransaction() {
      this.reinitializeTransaction();
      this.dirtyComponentsLength = null;
      this.callbackQueue = CallbackQueue.getPooled();
      this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled();
    }
    assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      },
      destructor: function() {
        this.dirtyComponentsLength = null;
        CallbackQueue.release(this.callbackQueue);
        this.callbackQueue = null;
        ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
        this.reconcileTransaction = null;
      },
      perform: function(method, scope, a) {
        return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
      }
    });
    PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
    function batchedUpdates(callback, a, b) {
      ensureInjected();
      batchingStrategy.batchedUpdates(callback, a, b);
    }
    function mountDepthComparator(c1, c2) {
      return c1._mountDepth - c2._mountDepth;
    }
    function runBatchedUpdates(transaction) {
      var len = transaction.dirtyComponentsLength;
      ("production" !== process.env.NODE_ENV ? invariant(len === dirtyComponents.length, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(len === dirtyComponents.length));
      dirtyComponents.sort(mountDepthComparator);
      for (var i = 0; i < len; i++) {
        var component = dirtyComponents[i];
        if (component.isMounted()) {
          var callbacks = component._pendingCallbacks;
          component._pendingCallbacks = null;
          component.performUpdateIfNecessary(transaction.reconcileTransaction);
          if (callbacks) {
            for (var j = 0; j < callbacks.length; j++) {
              transaction.callbackQueue.enqueue(callbacks[j], component);
            }
          }
        }
      }
    }
    var flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', function() {
      while (dirtyComponents.length || asapEnqueued) {
        if (dirtyComponents.length) {
          var transaction = ReactUpdatesFlushTransaction.getPooled();
          transaction.perform(runBatchedUpdates, null, transaction);
          ReactUpdatesFlushTransaction.release(transaction);
        }
        if (asapEnqueued) {
          asapEnqueued = false;
          var queue = asapCallbackQueue;
          asapCallbackQueue = CallbackQueue.getPooled();
          queue.notifyAll();
          CallbackQueue.release(queue);
        }
      }
    });
    function enqueueUpdate(component, callback) {
      ("production" !== process.env.NODE_ENV ? invariant(!callback || typeof callback === "function", 'enqueueUpdate(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(!callback || typeof callback === "function"));
      ensureInjected();
      ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'enqueueUpdate(): Render methods should be a pure function of props ' + 'and state; triggering nested component updates from render is not ' + 'allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
      if (!batchingStrategy.isBatchingUpdates) {
        batchingStrategy.batchedUpdates(enqueueUpdate, component, callback);
        return;
      }
      dirtyComponents.push(component);
      if (callback) {
        if (component._pendingCallbacks) {
          component._pendingCallbacks.push(callback);
        } else {
          component._pendingCallbacks = [callback];
        }
      }
    }
    function asap(callback, context) {
      ("production" !== process.env.NODE_ENV ? invariant(batchingStrategy.isBatchingUpdates, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(batchingStrategy.isBatchingUpdates));
      asapCallbackQueue.enqueue(callback, context);
      asapEnqueued = true;
    }
    var ReactUpdatesInjection = {
      injectReconcileTransaction: function(ReconcileTransaction) {
        ("production" !== process.env.NODE_ENV ? invariant(ReconcileTransaction, 'ReactUpdates: must provide a reconcile transaction class') : invariant(ReconcileTransaction));
        ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
      },
      injectBatchingStrategy: function(_batchingStrategy) {
        ("production" !== process.env.NODE_ENV ? invariant(_batchingStrategy, 'ReactUpdates: must provide a batching strategy') : invariant(_batchingStrategy));
        ("production" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.batchedUpdates === 'function', 'ReactUpdates: must provide a batchedUpdates() function') : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));
        ("production" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean', 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));
        batchingStrategy = _batchingStrategy;
      }
    };
    var ReactUpdates = {
      ReactReconcileTransaction: null,
      batchedUpdates: batchedUpdates,
      enqueueUpdate: enqueueUpdate,
      flushBatchedUpdates: flushBatchedUpdates,
      injection: ReactUpdatesInjection,
      asap: asap
    };
    module.exports = ReactUpdates;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactElementValidator", ["./ReactElement", "./ReactPropTypeLocations", "./ReactCurrentOwner", "./monitorCodeUse", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var ReactPropTypeLocations = require("./ReactPropTypeLocations");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var monitorCodeUse = require("./monitorCodeUse");
    var warning = require("./warning");
    var ownerHasKeyUseWarning = {
      'react_key_warning': {},
      'react_numeric_key_warning': {}
    };
    var ownerHasMonitoredObjectMap = {};
    var loggedTypeFailures = {};
    var NUMERIC_PROPERTY_REGEX = /^\d+$/;
    function getCurrentOwnerDisplayName() {
      var current = ReactCurrentOwner.current;
      return current && current.constructor.displayName || undefined;
    }
    function validateExplicitKey(component, parentType) {
      if (component._store.validated || component.key != null) {
        return;
      }
      component._store.validated = true;
      warnAndMonitorForKeyUse('react_key_warning', 'Each child in an array should have a unique "key" prop.', component, parentType);
    }
    function validatePropertyKey(name, component, parentType) {
      if (!NUMERIC_PROPERTY_REGEX.test(name)) {
        return;
      }
      warnAndMonitorForKeyUse('react_numeric_key_warning', 'Child objects should have non-numeric keys so ordering is preserved.', component, parentType);
    }
    function warnAndMonitorForKeyUse(warningID, message, component, parentType) {
      var ownerName = getCurrentOwnerDisplayName();
      var parentName = parentType.displayName;
      var useName = ownerName || parentName;
      var memoizer = ownerHasKeyUseWarning[warningID];
      if (memoizer.hasOwnProperty(useName)) {
        return;
      }
      memoizer[useName] = true;
      message += ownerName ? (" Check the render method of " + ownerName + ".") : (" Check the renderComponent call using <" + parentName + ">.");
      var childOwnerName = null;
      if (component._owner && component._owner !== ReactCurrentOwner.current) {
        childOwnerName = component._owner.constructor.displayName;
        message += (" It was passed a child from " + childOwnerName + ".");
      }
      message += ' See http://fb.me/react-warning-keys for more information.';
      monitorCodeUse(warningID, {
        component: useName,
        componentOwner: childOwnerName
      });
      console.warn(message);
    }
    function monitorUseOfObjectMap() {
      var currentName = getCurrentOwnerDisplayName() || '';
      if (ownerHasMonitoredObjectMap.hasOwnProperty(currentName)) {
        return;
      }
      ownerHasMonitoredObjectMap[currentName] = true;
      monitorCodeUse('react_object_map_children');
    }
    function validateChildKeys(component, parentType) {
      if (Array.isArray(component)) {
        for (var i = 0; i < component.length; i++) {
          var child = component[i];
          if (ReactElement.isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (ReactElement.isValidElement(component)) {
        component._store.validated = true;
      } else if (component && typeof component === 'object') {
        monitorUseOfObjectMap();
        for (var name in component) {
          validatePropertyKey(name, component[name], parentType);
        }
      }
    }
    function checkPropTypes(componentName, propTypes, props, location) {
      for (var propName in propTypes) {
        if (propTypes.hasOwnProperty(propName)) {
          var error;
          try {
            error = propTypes[propName](props, propName, componentName, location);
          } catch (ex) {
            error = ex;
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            monitorCodeUse('react_failed_descriptor_type_check', {message: error.message});
          }
        }
      }
    }
    var ReactElementValidator = {
      createElement: function(type, props, children) {
        ("production" !== process.env.NODE_ENV ? warning(type != null, 'React.createElement: type should not be null or undefined. It should ' + 'be a string (for DOM elements) or a ReactClass (for composite ' + 'components).') : null);
        var element = ReactElement.createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
        if (type) {
          var name = type.displayName;
          if (type.propTypes) {
            checkPropTypes(name, type.propTypes, element.props, ReactPropTypeLocations.prop);
          }
          if (type.contextTypes) {
            checkPropTypes(name, type.contextTypes, element._context, ReactPropTypeLocations.context);
          }
        }
        return element;
      },
      createFactory: function(type) {
        var validatedFactory = ReactElementValidator.createElement.bind(null, type);
        validatedFactory.type = type;
        return validatedFactory;
      }
    };
    module.exports = ReactElementValidator;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTransferer", ["./Object.assign", "./emptyFunction", "./invariant", "./joinClasses", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var assign = require("./Object.assign");
    var emptyFunction = require("./emptyFunction");
    var invariant = require("./invariant");
    var joinClasses = require("./joinClasses");
    var warning = require("./warning");
    var didWarn = false;
    function createTransferStrategy(mergeStrategy) {
      return function(props, key, value) {
        if (!props.hasOwnProperty(key)) {
          props[key] = value;
        } else {
          props[key] = mergeStrategy(props[key], value);
        }
      };
    }
    var transferStrategyMerge = createTransferStrategy(function(a, b) {
      return assign({}, b, a);
    });
    var TransferStrategies = {
      children: emptyFunction,
      className: createTransferStrategy(joinClasses),
      style: transferStrategyMerge
    };
    function transferInto(props, newProps) {
      for (var thisKey in newProps) {
        if (!newProps.hasOwnProperty(thisKey)) {
          continue;
        }
        var transferStrategy = TransferStrategies[thisKey];
        if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
          transferStrategy(props, thisKey, newProps[thisKey]);
        } else if (!props.hasOwnProperty(thisKey)) {
          props[thisKey] = newProps[thisKey];
        }
      }
      return props;
    }
    var ReactPropTransferer = {
      TransferStrategies: TransferStrategies,
      mergeProps: function(oldProps, newProps) {
        return transferInto(assign({}, oldProps), newProps);
      },
      Mixin: {transferPropsTo: function(element) {
          ("production" !== process.env.NODE_ENV ? invariant(element._owner === this, '%s: You can\'t call transferPropsTo() on a component that you ' + 'don\'t own, %s. This usually means you are calling ' + 'transferPropsTo() on a component passed in as props or children.', this.constructor.displayName, typeof element.type === 'string' ? element.type : element.type.displayName) : invariant(element._owner === this));
          if ("production" !== process.env.NODE_ENV) {
            if (!didWarn) {
              didWarn = true;
              ("production" !== process.env.NODE_ENV ? warning(false, 'transferPropsTo is deprecated. ' + 'See http://fb.me/react-transferpropsto for more information.') : null);
            }
          }
          transferInto(element.props, this.props);
          return element;
        }}
    };
    module.exports = ReactPropTransferer;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/instantiateReactComponent", ["./warning", "./ReactElement", "./ReactLegacyElement", "./ReactNativeComponent", "./ReactEmptyComponent", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var warning = require("./warning");
    var ReactElement = require("./ReactElement");
    var ReactLegacyElement = require("./ReactLegacyElement");
    var ReactNativeComponent = require("./ReactNativeComponent");
    var ReactEmptyComponent = require("./ReactEmptyComponent");
    function instantiateReactComponent(element, parentCompositeType) {
      var instance;
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(element && (typeof element.type === 'function' || typeof element.type === 'string'), 'Only functions or strings can be mounted as React components.') : null);
        if (element.type._mockedReactClassConstructor) {
          ReactLegacyElement._isLegacyCallWarningEnabled = false;
          try {
            instance = new element.type._mockedReactClassConstructor(element.props);
          } finally {
            ReactLegacyElement._isLegacyCallWarningEnabled = true;
          }
          if (ReactElement.isValidElement(instance)) {
            instance = new instance.type(instance.props);
          }
          var render = instance.render;
          if (!render) {
            element = ReactEmptyComponent.getEmptyComponent();
          } else {
            if (render._isMockFunction && !render._getMockImplementation()) {
              render.mockImplementation(ReactEmptyComponent.getEmptyComponent);
            }
            instance.construct(element);
            return instance;
          }
        }
      }
      if (typeof element.type === 'string') {
        instance = ReactNativeComponent.createInstanceForTag(element.type, element.props, parentCompositeType);
      } else {
        instance = new element.type(element.props);
      }
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function', 'Only React Components can be mounted.') : null);
      }
      instance.construct(element);
      return instance;
    }
    module.exports = instantiateReactComponent;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/camelizeStyleName", ["./camelize"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var camelize = require("./camelize");
  var msPattern = /^-ms-/;
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, 'ms-'));
  }
  module.exports = camelizeStyleName;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/hyphenateStyleName", ["./hyphenate"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var hyphenate = require("./hyphenate");
  var msPattern = /^ms-/;
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, '-ms-');
  }
  module.exports = hyphenateStyleName;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPluginHub", ["./EventPluginRegistry", "./EventPluginUtils", "./accumulateInto", "./forEachAccumulated", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventPluginRegistry = require("./EventPluginRegistry");
    var EventPluginUtils = require("./EventPluginUtils");
    var accumulateInto = require("./accumulateInto");
    var forEachAccumulated = require("./forEachAccumulated");
    var invariant = require("./invariant");
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function(event) {
      if (event) {
        var executeDispatch = EventPluginUtils.executeDispatch;
        var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
        if (PluginModule && PluginModule.executeDispatch) {
          executeDispatch = PluginModule.executeDispatch;
        }
        EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);
        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var InstanceHandle = null;
    function validateInstanceHandle() {
      var invalid = !InstanceHandle || !InstanceHandle.traverseTwoPhase || !InstanceHandle.traverseEnterLeave;
      if (invalid) {
        throw new Error('InstanceHandle not injected before use!');
      }
    }
    var EventPluginHub = {
      injection: {
        injectMount: EventPluginUtils.injection.injectMount,
        injectInstanceHandle: function(InjectedInstanceHandle) {
          InstanceHandle = InjectedInstanceHandle;
          if ("production" !== process.env.NODE_ENV) {
            validateInstanceHandle();
          }
        },
        getInstanceHandle: function() {
          if ("production" !== process.env.NODE_ENV) {
            validateInstanceHandle();
          }
          return InstanceHandle;
        },
        injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
        injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
      },
      eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
      registrationNameModules: EventPluginRegistry.registrationNameModules,
      putListener: function(id, registrationName, listener) {
        ("production" !== process.env.NODE_ENV ? invariant(!listener || typeof listener === 'function', 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(!listener || typeof listener === 'function'));
        var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
        bankForRegistrationName[id] = listener;
      },
      getListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        return bankForRegistrationName && bankForRegistrationName[id];
      },
      deleteListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        if (bankForRegistrationName) {
          delete bankForRegistrationName[id];
        }
      },
      deleteAllListeners: function(id) {
        for (var registrationName in listenerBank) {
          delete listenerBank[registrationName][id];
        }
      },
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var events;
        var plugins = EventPluginRegistry.plugins;
        for (var i = 0,
            l = plugins.length; i < l; i++) {
          var possiblePlugin = plugins[i];
          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }
        return events;
      },
      enqueueEvents: function(events) {
        if (events) {
          eventQueue = accumulateInto(eventQueue, events);
        }
      },
      processEventQueue: function() {
        var processingEventQueue = eventQueue;
        eventQueue = null;
        forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
        ("production" !== process.env.NODE_ENV ? invariant(!eventQueue, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(!eventQueue));
      },
      __purge: function() {
        listenerBank = {};
      },
      __getListenerBank: function() {
        return listenerBank;
      }
    };
    module.exports = EventPluginHub;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ViewportMetrics", ["./getUnboundedScrollPosition"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");
  var ViewportMetrics = {
    currentScrollLeft: 0,
    currentScrollTop: 0,
    refreshScrollValues: function() {
      var scrollPosition = getUnboundedScrollPosition(window);
      ViewportMetrics.currentScrollLeft = scrollPosition.x;
      ViewportMetrics.currentScrollTop = scrollPosition.y;
    }
  };
  module.exports = ViewportMetrics;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isTextNode", ["./isNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var isNode = require("./isNode");
  function isTextNode(object) {
    return isNode(object) && object.nodeType == 3;
  }
  module.exports = isTextNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/flattenChildren", ["./ReactTextComponent", "./traverseAllChildren", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactTextComponent = require("./ReactTextComponent");
    var traverseAllChildren = require("./traverseAllChildren");
    var warning = require("./warning");
    function flattenSingleChildIntoContext(traverseContext, child, name) {
      var result = traverseContext;
      var keyUnique = !result.hasOwnProperty(name);
      ("production" !== process.env.NODE_ENV ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : null);
      if (keyUnique && child != null) {
        var type = typeof child;
        var normalizedValue;
        if (type === 'string') {
          normalizedValue = ReactTextComponent(child);
        } else if (type === 'number') {
          normalizedValue = ReactTextComponent('' + child);
        } else {
          normalizedValue = child;
        }
        result[name] = normalizedValue;
      }
    }
    function flattenChildren(children) {
      if (children == null) {
        return children;
      }
      var result = {};
      traverseAllChildren(children, flattenSingleChildIntoContext, result);
      return result;
    }
    module.exports = flattenChildren;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticEvent", ["./PooledClass", "./Object.assign", "./emptyFunction", "./getEventTarget"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var PooledClass = require("./PooledClass");
  var assign = require("./Object.assign");
  var emptyFunction = require("./emptyFunction");
  var getEventTarget = require("./getEventTarget");
  var EventInterface = {
    type: null,
    target: getEventTarget,
    currentTarget: emptyFunction.thatReturnsNull,
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };
  function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    this.dispatchConfig = dispatchConfig;
    this.dispatchMarker = dispatchMarker;
    this.nativeEvent = nativeEvent;
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (!Interface.hasOwnProperty(propName)) {
        continue;
      }
      var normalize = Interface[propName];
      if (normalize) {
        this[propName] = normalize(nativeEvent);
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
    if (defaultPrevented) {
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    } else {
      this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  }
  assign(SyntheticEvent.prototype, {
    preventDefault: function() {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      event.preventDefault ? event.preventDefault() : event.returnValue = false;
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    },
    stopPropagation: function() {
      var event = this.nativeEvent;
      event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
      this.isPropagationStopped = emptyFunction.thatReturnsTrue;
    },
    persist: function() {
      this.isPersistent = emptyFunction.thatReturnsTrue;
    },
    isPersistent: emptyFunction.thatReturnsFalse,
    destructor: function() {
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        this[propName] = null;
      }
      this.dispatchConfig = null;
      this.dispatchMarker = null;
      this.nativeEvent = null;
    }
  });
  SyntheticEvent.Interface = EventInterface;
  SyntheticEvent.augmentClass = function(Class, Interface) {
    var Super = this;
    var prototype = Object.create(Super.prototype);
    assign(prototype, Class.prototype);
    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.Interface = assign({}, Super.Interface, Interface);
    Class.augmentClass = Super.augmentClass;
    PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
  };
  PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);
  module.exports = SyntheticEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ChangeEventPlugin", ["./EventConstants", "./EventPluginHub", "./EventPropagators", "./ExecutionEnvironment", "./ReactUpdates", "./SyntheticEvent", "./isEventSupported", "./isTextInputElement", "./keyOf", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPluginHub = require("./EventPluginHub");
    var EventPropagators = require("./EventPropagators");
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var ReactUpdates = require("./ReactUpdates");
    var SyntheticEvent = require("./SyntheticEvent");
    var isEventSupported = require("./isEventSupported");
    var isTextInputElement = require("./isTextInputElement");
    var keyOf = require("./keyOf");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {change: {
        phasedRegistrationNames: {
          bubbled: keyOf({onChange: null}),
          captured: keyOf({onChangeCapture: null})
        },
        dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
      }};
    var activeElement = null;
    var activeElementID = null;
    var activeElementValue = null;
    var activeElementValueProp = null;
    function shouldUseChangeEvent(elem) {
      return (elem.nodeName === 'SELECT' || (elem.nodeName === 'INPUT' && elem.type === 'file'));
    }
    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
      doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
    }
    function manualDispatchChangeEvent(nativeEvent) {
      var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent);
      EventPropagators.accumulateTwoPhaseDispatches(event);
      ReactUpdates.batchedUpdates(runEventInBatch, event);
    }
    function runEventInBatch(event) {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue();
    }
    function startWatchingForChangeEventIE8(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElement.attachEvent('onchange', manualDispatchChangeEvent);
    }
    function stopWatchingForChangeEventIE8() {
      if (!activeElement) {
        return;
      }
      activeElement.detachEvent('onchange', manualDispatchChangeEvent);
      activeElement = null;
      activeElementID = null;
    }
    function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topChange) {
        return topLevelTargetID;
      }
    }
    function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForChangeEventIE8();
        startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForChangeEventIE8();
      }
    }
    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
      isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
    }
    var newValueProp = {
      get: function() {
        return activeElementValueProp.get.call(this);
      },
      set: function(val) {
        activeElementValue = '' + val;
        activeElementValueProp.set.call(this, val);
      }
    };
    function startWatchingForValueChange(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElementValue = target.value;
      activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
      Object.defineProperty(activeElement, 'value', newValueProp);
      activeElement.attachEvent('onpropertychange', handlePropertyChange);
    }
    function stopWatchingForValueChange() {
      if (!activeElement) {
        return;
      }
      delete activeElement.value;
      activeElement.detachEvent('onpropertychange', handlePropertyChange);
      activeElement = null;
      activeElementID = null;
      activeElementValue = null;
      activeElementValueProp = null;
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName !== 'value') {
        return;
      }
      var value = nativeEvent.srcElement.value;
      if (value === activeElementValue) {
        return;
      }
      activeElementValue = value;
      manualDispatchChangeEvent(nativeEvent);
    }
    function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topInput) {
        return topLevelTargetID;
      }
    }
    function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForValueChange();
        startWatchingForValueChange(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForValueChange();
      }
    }
    function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
        if (activeElement && activeElement.value !== activeElementValue) {
          activeElementValue = activeElement.value;
          return activeElementID;
        }
      }
    }
    function shouldUseClickEvent(elem) {
      return (elem.nodeName === 'INPUT' && (elem.type === 'checkbox' || elem.type === 'radio'));
    }
    function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topClick) {
        return topLevelTargetID;
      }
    }
    var ChangeEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var getTargetIDFunc,
            handleEventFunc;
        if (shouldUseChangeEvent(topLevelTarget)) {
          if (doesChangeEventBubble) {
            getTargetIDFunc = getTargetIDForChangeEvent;
          } else {
            handleEventFunc = handleEventsForChangeEventIE8;
          }
        } else if (isTextInputElement(topLevelTarget)) {
          if (isInputEventSupported) {
            getTargetIDFunc = getTargetIDForInputEvent;
          } else {
            getTargetIDFunc = getTargetIDForInputEventIE;
            handleEventFunc = handleEventsForInputEventIE;
          }
        } else if (shouldUseClickEvent(topLevelTarget)) {
          getTargetIDFunc = getTargetIDForClickEvent;
        }
        if (getTargetIDFunc) {
          var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
          if (targetID) {
            var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent);
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
        }
      }
    };
    module.exports = ChangeEventPlugin;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMSelection", ["./ExecutionEnvironment", "./getNodeForCharacterOffset", "./getTextContentAccessor"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  var getNodeForCharacterOffset = require("./getNodeForCharacterOffset");
  var getTextContentAccessor = require("./getTextContentAccessor");
  function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
    return anchorNode === focusNode && anchorOffset === focusOffset;
  }
  function getIEOffsets(node) {
    var selection = document.selection;
    var selectedRange = selection.createRange();
    var selectedLength = selectedRange.text.length;
    var fromStart = selectedRange.duplicate();
    fromStart.moveToElementText(node);
    fromStart.setEndPoint('EndToStart', selectedRange);
    var startOffset = fromStart.text.length;
    var endOffset = startOffset + selectedLength;
    return {
      start: startOffset,
      end: endOffset
    };
  }
  function getModernOffsets(node) {
    var selection = window.getSelection && window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null;
    }
    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    var currentRange = selection.getRangeAt(0);
    var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
    var tempRange = currentRange.cloneRange();
    tempRange.selectNodeContents(node);
    tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
    var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
    var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
    var end = start + rangeLength;
    var detectionRange = document.createRange();
    detectionRange.setStart(anchorNode, anchorOffset);
    detectionRange.setEnd(focusNode, focusOffset);
    var isBackward = detectionRange.collapsed;
    return {
      start: isBackward ? end : start,
      end: isBackward ? start : end
    };
  }
  function setIEOffsets(node, offsets) {
    var range = document.selection.createRange().duplicate();
    var start,
        end;
    if (typeof offsets.end === 'undefined') {
      start = offsets.start;
      end = start;
    } else if (offsets.start > offsets.end) {
      start = offsets.end;
      end = offsets.start;
    } else {
      start = offsets.start;
      end = offsets.end;
    }
    range.moveToElementText(node);
    range.moveStart('character', start);
    range.setEndPoint('EndToStart', range);
    range.moveEnd('character', end - start);
    range.select();
  }
  function setModernOffsets(node, offsets) {
    if (!window.getSelection) {
      return;
    }
    var selection = window.getSelection();
    var length = node[getTextContentAccessor()].length;
    var start = Math.min(offsets.start, length);
    var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
    if (!selection.extend && start > end) {
      var temp = end;
      end = start;
      start = temp;
    }
    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);
    if (startMarker && endMarker) {
      var range = document.createRange();
      range.setStart(startMarker.node, startMarker.offset);
      selection.removeAllRanges();
      if (start > end) {
        selection.addRange(range);
        selection.extend(endMarker.node, endMarker.offset);
      } else {
        range.setEnd(endMarker.node, endMarker.offset);
        selection.addRange(range);
      }
    }
  }
  var useIEOffsets = ExecutionEnvironment.canUseDOM && document.selection;
  var ReactDOMSelection = {
    getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
    setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
  };
  module.exports = ReactDOMSelection;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticMouseEvent", ["./SyntheticUIEvent", "./ViewportMetrics", "./getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("./SyntheticUIEvent");
  var ViewportMetrics = require("./ViewportMetrics");
  var getEventModifierState = require("./getEventModifierState");
  var MouseEventInterface = {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: function(event) {
      var button = event.button;
      if ('which' in event) {
        return button;
      }
      return button === 2 ? 2 : button === 4 ? 1 : 0;
    },
    buttons: null,
    relatedTarget: function(event) {
      return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
    },
    pageX: function(event) {
      return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
    },
    pageY: function(event) {
      return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
    }
  };
  function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
  module.exports = SyntheticMouseEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/createArrayFrom", ["./toArray"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var toArray = require("./toArray");
  function hasArrayNature(obj) {
    return (!!obj && (typeof obj == 'object' || typeof obj == 'function') && ('length' in obj) && !('setInterval' in obj) && (typeof obj.nodeType != 'number') && (((Array.isArray(obj) || ('callee' in obj) || 'item' in obj))));
  }
  function createArrayFrom(obj) {
    if (!hasArrayNature(obj)) {
      return [obj];
    } else if (Array.isArray(obj)) {
      return obj.slice();
    } else {
      return toArray(obj);
    }
  }
  module.exports = createArrayFrom;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMarkupChecksum", ["./adler32"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var adler32 = require("./adler32");
  var ReactMarkupChecksum = {
    CHECKSUM_ATTR_NAME: 'data-react-checksum',
    addChecksumToMarkup: function(markup) {
      var checksum = adler32(markup);
      return markup.replace('>', ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">');
    },
    canReuseMarkup: function(markup, element) {
      var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
      var markupChecksum = adler32(markup);
      return markupChecksum === existingChecksum;
    }
  };
  module.exports = ReactMarkupChecksum;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactReconcileTransaction", ["./CallbackQueue", "./PooledClass", "./ReactBrowserEventEmitter", "./ReactInputSelection", "./ReactPutListenerQueue", "./Transaction", "./Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var CallbackQueue = require("./CallbackQueue");
  var PooledClass = require("./PooledClass");
  var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
  var ReactInputSelection = require("./ReactInputSelection");
  var ReactPutListenerQueue = require("./ReactPutListenerQueue");
  var Transaction = require("./Transaction");
  var assign = require("./Object.assign");
  var SELECTION_RESTORATION = {
    initialize: ReactInputSelection.getSelectionInformation,
    close: ReactInputSelection.restoreSelection
  };
  var EVENT_SUPPRESSION = {
    initialize: function() {
      var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
      ReactBrowserEventEmitter.setEnabled(false);
      return currentlyEnabled;
    },
    close: function(previouslyEnabled) {
      ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
    }
  };
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: function() {
      this.reactMountReady.notifyAll();
    }
  };
  var PUT_LISTENER_QUEUEING = {
    initialize: function() {
      this.putListenerQueue.reset();
    },
    close: function() {
      this.putListenerQueue.putListeners();
    }
  };
  var TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
  function ReactReconcileTransaction() {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = false;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.putListenerQueue = ReactPutListenerQueue.getPooled();
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    getPutListenerQueue: function() {
      return this.putListenerQueue;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
      ReactPutListenerQueue.release(this.putListenerQueue);
      this.putListenerQueue = null;
    }
  };
  assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactReconcileTransaction);
  module.exports = ReactReconcileTransaction;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMButton", ["./AutoFocusMixin", "./ReactBrowserComponentMixin", "./ReactCompositeComponent", "./ReactElement", "./ReactDOM", "./keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var AutoFocusMixin = require("./AutoFocusMixin");
  var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("./ReactCompositeComponent");
  var ReactElement = require("./ReactElement");
  var ReactDOM = require("./ReactDOM");
  var keyMirror = require("./keyMirror");
  var button = ReactElement.createFactory(ReactDOM.button.type);
  var mouseListenerNames = keyMirror({
    onClick: true,
    onDoubleClick: true,
    onMouseDown: true,
    onMouseMove: true,
    onMouseUp: true,
    onClickCapture: true,
    onDoubleClickCapture: true,
    onMouseDownCapture: true,
    onMouseMoveCapture: true,
    onMouseUpCapture: true
  });
  var ReactDOMButton = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMButton',
    mixins: [AutoFocusMixin, ReactBrowserComponentMixin],
    render: function() {
      var props = {};
      for (var key in this.props) {
        if (this.props.hasOwnProperty(key) && (!this.props.disabled || !mouseListenerNames[key])) {
          props[key] = this.props[key];
        }
      }
      return button(props, this.props.children);
    }
  });
  module.exports = ReactDOMButton;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMForm", ["./EventConstants", "./LocalEventTrapMixin", "./ReactBrowserComponentMixin", "./ReactCompositeComponent", "./ReactElement", "./ReactDOM"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("./EventConstants");
  var LocalEventTrapMixin = require("./LocalEventTrapMixin");
  var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("./ReactCompositeComponent");
  var ReactElement = require("./ReactElement");
  var ReactDOM = require("./ReactDOM");
  var form = ReactElement.createFactory(ReactDOM.form.type);
  var ReactDOMForm = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMForm',
    mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
    render: function() {
      return form(this.props);
    },
    componentDidMount: function() {
      this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');
      this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');
    }
  });
  module.exports = ReactDOMForm;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/LinkedValueUtils", ["./ReactPropTypes", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactPropTypes = require("./ReactPropTypes");
    var invariant = require("./invariant");
    var hasReadOnlyValue = {
      'button': true,
      'checkbox': true,
      'image': true,
      'hidden': true,
      'radio': true,
      'reset': true,
      'submit': true
    };
    function _assertSingleLink(input) {
      ("production" !== process.env.NODE_ENV ? invariant(input.props.checkedLink == null || input.props.valueLink == null, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(input.props.checkedLink == null || input.props.valueLink == null));
    }
    function _assertValueLink(input) {
      _assertSingleLink(input);
      ("production" !== process.env.NODE_ENV ? invariant(input.props.value == null && input.props.onChange == null, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(input.props.value == null && input.props.onChange == null));
    }
    function _assertCheckedLink(input) {
      _assertSingleLink(input);
      ("production" !== process.env.NODE_ENV ? invariant(input.props.checked == null && input.props.onChange == null, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(input.props.checked == null && input.props.onChange == null));
    }
    function _handleLinkedValueChange(e) {
      this.props.valueLink.requestChange(e.target.value);
    }
    function _handleLinkedCheckChange(e) {
      this.props.checkedLink.requestChange(e.target.checked);
    }
    var LinkedValueUtils = {
      Mixin: {propTypes: {
          value: function(props, propName, componentName) {
            if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
              return;
            }
            return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
          },
          checked: function(props, propName, componentName) {
            if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
              return;
            }
            return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
          },
          onChange: ReactPropTypes.func
        }},
      getValue: function(input) {
        if (input.props.valueLink) {
          _assertValueLink(input);
          return input.props.valueLink.value;
        }
        return input.props.value;
      },
      getChecked: function(input) {
        if (input.props.checkedLink) {
          _assertCheckedLink(input);
          return input.props.checkedLink.value;
        }
        return input.props.checked;
      },
      getOnChange: function(input) {
        if (input.props.valueLink) {
          _assertValueLink(input);
          return _handleLinkedValueChange;
        } else if (input.props.checkedLink) {
          _assertCheckedLink(input);
          return _handleLinkedCheckChange;
        }
        return input.props.onChange;
      }
    };
    module.exports = LinkedValueUtils;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactEventListener", ["./EventListener", "./ExecutionEnvironment", "./PooledClass", "./ReactInstanceHandles", "./ReactMount", "./ReactUpdates", "./Object.assign", "./getEventTarget", "./getUnboundedScrollPosition", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventListener = require("./EventListener");
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var PooledClass = require("./PooledClass");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var ReactMount = require("./ReactMount");
    var ReactUpdates = require("./ReactUpdates");
    var assign = require("./Object.assign");
    var getEventTarget = require("./getEventTarget");
    var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");
    function findParent(node) {
      var nodeID = ReactMount.getID(node);
      var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
      var container = ReactMount.findReactContainerForID(rootID);
      var parent = ReactMount.getFirstReactDOM(container);
      return parent;
    }
    function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
      this.topLevelType = topLevelType;
      this.nativeEvent = nativeEvent;
      this.ancestors = [];
    }
    assign(TopLevelCallbackBookKeeping.prototype, {destructor: function() {
        this.topLevelType = null;
        this.nativeEvent = null;
        this.ancestors.length = 0;
      }});
    PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
    function handleTopLevelImpl(bookKeeping) {
      var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
      var ancestor = topLevelTarget;
      while (ancestor) {
        bookKeeping.ancestors.push(ancestor);
        ancestor = findParent(ancestor);
      }
      for (var i = 0,
          l = bookKeeping.ancestors.length; i < l; i++) {
        topLevelTarget = bookKeeping.ancestors[i];
        var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
        ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent);
      }
    }
    function scrollValueMonitor(cb) {
      var scrollPosition = getUnboundedScrollPosition(window);
      cb(scrollPosition);
    }
    var ReactEventListener = {
      _enabled: true,
      _handleTopLevel: null,
      WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
      setHandleTopLevel: function(handleTopLevel) {
        ReactEventListener._handleTopLevel = handleTopLevel;
      },
      setEnabled: function(enabled) {
        ReactEventListener._enabled = !!enabled;
      },
      isEnabled: function() {
        return ReactEventListener._enabled;
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return;
        }
        return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return;
        }
        return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      monitorScrollValue: function(refresh) {
        var callback = scrollValueMonitor.bind(null, refresh);
        EventListener.listen(window, 'scroll', callback);
        EventListener.listen(window, 'resize', callback);
      },
      dispatchEvent: function(topLevelType, nativeEvent) {
        if (!ReactEventListener._enabled) {
          return;
        }
        var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
        try {
          ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
        } finally {
          TopLevelCallbackBookKeeping.release(bookKeeping);
        }
      }
    };
    module.exports = ReactEventListener;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SelectEventPlugin", ["./EventConstants", "./EventPropagators", "./ReactInputSelection", "./SyntheticEvent", "./getActiveElement", "./isTextInputElement", "./keyOf", "./shallowEqual"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("./EventConstants");
  var EventPropagators = require("./EventPropagators");
  var ReactInputSelection = require("./ReactInputSelection");
  var SyntheticEvent = require("./SyntheticEvent");
  var getActiveElement = require("./getActiveElement");
  var isTextInputElement = require("./isTextInputElement");
  var keyOf = require("./keyOf");
  var shallowEqual = require("./shallowEqual");
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {select: {
      phasedRegistrationNames: {
        bubbled: keyOf({onSelect: null}),
        captured: keyOf({onSelectCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
    }};
  var activeElement = null;
  var activeElementID = null;
  var lastSelection = null;
  var mouseDown = false;
  function getSelection(node) {
    if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
      return {
        start: node.selectionStart,
        end: node.selectionEnd
      };
    } else if (window.getSelection) {
      var selection = window.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    } else if (document.selection) {
      var range = document.selection.createRange();
      return {
        parentElement: range.parentElement(),
        text: range.text,
        top: range.boundingTop,
        left: range.boundingLeft
      };
    }
  }
  function constructSelectEvent(nativeEvent) {
    if (mouseDown || activeElement == null || activeElement != getActiveElement()) {
      return;
    }
    var currentSelection = getSelection(activeElement);
    if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
      lastSelection = currentSelection;
      var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent);
      syntheticEvent.type = 'select';
      syntheticEvent.target = activeElement;
      EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
      return syntheticEvent;
    }
  }
  var SelectEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      switch (topLevelType) {
        case topLevelTypes.topFocus:
          if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
            activeElement = topLevelTarget;
            activeElementID = topLevelTargetID;
            lastSelection = null;
          }
          break;
        case topLevelTypes.topBlur:
          activeElement = null;
          activeElementID = null;
          lastSelection = null;
          break;
        case topLevelTypes.topMouseDown:
          mouseDown = true;
          break;
        case topLevelTypes.topContextMenu:
        case topLevelTypes.topMouseUp:
          mouseDown = false;
          return constructSelectEvent(nativeEvent);
        case topLevelTypes.topSelectionChange:
        case topLevelTypes.topKeyDown:
        case topLevelTypes.topKeyUp:
          return constructSelectEvent(nativeEvent);
      }
    }
  };
  module.exports = SelectEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticKeyboardEvent", ["./SyntheticUIEvent", "./getEventCharCode", "./getEventKey", "./getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("./SyntheticUIEvent");
  var getEventCharCode = require("./getEventCharCode");
  var getEventKey = require("./getEventKey");
  var getEventModifierState = require("./getEventModifierState");
  var KeyboardEventInterface = {
    key: getEventKey,
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      return 0;
    },
    keyCode: function(event) {
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    },
    which: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    }
  };
  function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
  module.exports = SyntheticKeyboardEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/performanceNow", ["./performance"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var performance = require("./performance");
  if (!performance || !performance.now) {
    performance = Date;
  }
  var performanceNow = performance.now.bind(performance);
  module.exports = performanceNow;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactServerRendering", ["./ReactElement", "./ReactInstanceHandles", "./ReactMarkupChecksum", "./ReactServerRenderingTransaction", "./instantiateReactComponent", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var ReactMarkupChecksum = require("./ReactMarkupChecksum");
    var ReactServerRenderingTransaction = require("./ReactServerRenderingTransaction");
    var instantiateReactComponent = require("./instantiateReactComponent");
    var invariant = require("./invariant");
    function renderToString(element) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(element), 'renderToString(): You must pass a valid ReactElement.') : invariant(ReactElement.isValidElement(element)));
      var transaction;
      try {
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(false);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          var markup = componentInstance.mountComponent(id, transaction, 0);
          return ReactMarkupChecksum.addChecksumToMarkup(markup);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
      }
    }
    function renderToStaticMarkup(element) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(element), 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(ReactElement.isValidElement(element)));
      var transaction;
      try {
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(true);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          return componentInstance.mountComponent(id, transaction, 0);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
      }
    }
    module.exports = {
      renderToString: renderToString,
      renderToStaticMarkup: renderToStaticMarkup
    };
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:immutable@3.7.2", ["npm:immutable@3.7.2/dist/immutable"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:immutable@3.7.2/dist/immutable");
  global.define = __define;
  return module.exports;
});



System.register("npm:eventemitter3@0.1.6", ["npm:eventemitter3@0.1.6/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:eventemitter3@0.1.6/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:inherits@2.0.1", ["npm:inherits@2.0.1/inherits_browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:inherits@2.0.1/inherits_browser");
  global.define = __define;
  return module.exports;
});



System.register("npm:deep-equal@0.2.2/index", ["./lib/keys", "./lib/is_arguments"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var pSlice = Array.prototype.slice;
  var objectKeys = require("./lib/keys");
  var isArguments = require("./lib/is_arguments");
  var deepEqual = module.exports = function(actual, expected, opts) {
    if (!opts)
      opts = {};
    if (actual === expected) {
      return true;
    } else if (actual instanceof Date && expected instanceof Date) {
      return actual.getTime() === expected.getTime();
    } else if (typeof actual != 'object' && typeof expected != 'object') {
      return opts.strict ? actual === expected : actual == expected;
    } else {
      return objEquiv(actual, expected, opts);
    }
  };
  function isUndefinedOrNull(value) {
    return value === null || value === undefined;
  }
  function isBuffer(x) {
    if (!x || typeof x !== 'object' || typeof x.length !== 'number')
      return false;
    if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
      return false;
    }
    if (x.length > 0 && typeof x[0] !== 'number')
      return false;
    return true;
  }
  function objEquiv(a, b, opts) {
    var i,
        key;
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
      return false;
    if (a.prototype !== b.prototype)
      return false;
    if (isArguments(a)) {
      if (!isArguments(b)) {
        return false;
      }
      a = pSlice.call(a);
      b = pSlice.call(b);
      return deepEqual(a, b, opts);
    }
    if (isBuffer(a)) {
      if (!isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length)
        return false;
      for (i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    try {
      var ka = objectKeys(a),
          kb = objectKeys(b);
    } catch (e) {
      return false;
    }
    if (ka.length != kb.length)
      return false;
    ka.sort();
    kb.sort();
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i])
        return false;
    }
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!deepEqual(a[key], b[key], opts))
        return false;
    }
    return typeof a === typeof b;
  }
  global.define = __define;
  return module.exports;
});



System.register("npm:lodash@2.4.1", ["npm:lodash@2.4.1/dist/lodash"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:lodash@2.4.1/dist/lodash");
  global.define = __define;
  return module.exports;
});



System.register("npm:d3@3.5.5", ["npm:d3@3.5.5/d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:d3@3.5.5/d3");
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/barchart/DataSeries", ["react", "d3", "./Bar"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var Bar = require("./Bar");
  module.exports = React.createClass({
    displayName: 'DataSeries',
    propTypes: {
      fill: React.PropTypes.string,
      title: React.PropTypes.string,
      padding: React.PropTypes.number,
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      offset: React.PropTypes.number
    },
    getDefaultProps: function() {
      return {
        padding: 0.1,
        data: []
      };
    },
    render: function() {
      var props = this.props;
      var xScale = d3.scale.ordinal().domain(d3.range(props.values.length)).rangeRoundBands([0, props.width], props.padding);
      var bars = props.values.map(function(point, i) {
        return (React.createElement(Bar, {
          height: props.yScale(0) - props.yScale(point),
          width: xScale.rangeBand(),
          offset: xScale(i),
          availableHeight: props.height,
          fill: props.fill,
          key: i
        }));
      });
      return (React.createElement("g", null, bars));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/axes/XAxis", ["react", "d3", "./AxisTicks", "./AxisLine", "./Label"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var AxisTicks = require("./AxisTicks");
  var AxisLine = require("./AxisLine");
  var Label = require("./Label");
  module.exports = React.createClass({
    displayName: 'XAxis',
    propTypes: {
      xAxisClassName: React.PropTypes.string.isRequired,
      xOrient: React.PropTypes.oneOf(['top', 'bottom']),
      xScale: React.PropTypes.func.isRequired,
      height: React.PropTypes.number.isRequired,
      fill: React.PropTypes.string,
      stroke: React.PropTypes.string,
      tickStroke: React.PropTypes.string,
      strokeWidth: React.PropTypes.string,
      xAxisOffset: React.PropTypes.number
    },
    getDefaultProps: function() {
      return {
        xAxisClassName: 'x axis',
        xAxisLabelOffset: 10,
        xOrient: 'bottom',
        fill: 'none',
        stroke: 'none',
        tickStroke: '#000',
        strokeWidth: 'none',
        xAxisOffset: 0,
        label: ''
      };
    },
    render: function() {
      var props = this.props;
      var t = ("translate(0," + (props.xAxisOffset + props.height) + ")");
      var tickArguments;
      if (typeof props.xAxisTickCount !== 'undefined') {
        tickArguments = [props.xAxisTickCount];
      }
      if (typeof props.xAxisTickInterval !== 'undefined') {
        tickArguments = [d3.time[props.xAxisTickInterval.unit], props.xAxisTickInterval.interval];
      }
      return (React.createElement("g", {
        className: props.xAxisClassName,
        transform: t
      }, React.createElement(Label, {
        label: props.xAxisLabel,
        offset: props.xAxisLabelOffset,
        orient: props.xOrient,
        margins: props.margins,
        width: props.width
      }), React.createElement(AxisTicks, {
        tickFormatting: props.tickFormatting,
        tickArguments: tickArguments,
        tickStroke: props.tickStroke,
        tickTextStroke: props.tickTextStroke,
        innerTickSize: props.tickSize,
        scale: props.xScale,
        orient: props.xOrient
      }), React.createElement(AxisLine, React.__spread({
        scale: props.xScale,
        stroke: props.stroke,
        orient: props.xOrient,
        outerTickSize: props.tickSize
      }, props))));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/charts/LegendChart", ["react", "../Legend"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var Legend = require("../Legend");
  module.exports = React.createClass({
    displayName: 'LegendChart',
    propTypes: {
      legend: React.PropTypes.bool,
      legendPosition: React.PropTypes.string,
      sideOffset: React.PropTypes.number,
      margins: React.PropTypes.object,
      data: React.PropTypes.oneOfType([React.PropTypes.object, React.PropTypes.array])
    },
    getDefaultProps: function() {
      return {
        data: {},
        legend: false,
        legendPosition: 'right',
        sideOffset: 90
      };
    },
    _renderLegend: function() {
      if (this.props.legend) {
        return (React.createElement(Legend, {
          legendPosition: this.props.legendPosition,
          margins: this.props.margins,
          colors: this.props.colors,
          data: this.props.data,
          width: this.props.width,
          height: this.props.height,
          sideOffset: this.props.sideOffset
        }));
      }
    },
    render: function() {
      return (React.createElement("div", {style: {
          'width': this.props.width,
          'height': this.props.height
        }}, React.createElement("h4", null, this.props.title), this._renderLegend(), React.createElement("svg", {
        viewBox: this.props.viewBox,
        width: this.props.width - this.props.sideOffset,
        height: this.props.height
      }, this.props.children)));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/mixins/index", ["./CartesianChartPropsMixin"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.CartesianChartPropsMixin = require("./CartesianChartPropsMixin");
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/linechart/Circle", ["react", "./Line-dotted"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require('react');
  var LineDotted = require("./Line-dotted");
  module.exports = React.createClass({
    displayName: 'Circle',
    propTypes: {
      cx: React.PropTypes.number,
      cy: React.PropTypes.number,
      r: React.PropTypes.number,
      fill: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        fill: '#1f77b4',
        className: 'rd3-linechart-circle'
      };
    },
    getInitialState: function() {
      return {
        circleRadius: this.props.r,
        circleColor: this.props.fill,
        isActive: false
      };
    },
    componentDidMount: function() {
      var props = this.props;
      if (props.point_hl) {}
      var unobserve = props.voronoiRef.observe(function() {
        var circleStatus = props.voronoiRef.cursor().deref();
        var seriesName = props.id.split('-')[0];
        if (circleStatus === 'active') {
          this._animateCircle(props.id);
          props.structure.cursor('voronoiSeries').cursor(seriesName).update(function() {
            return 'active';
          });
        } else if (circleStatus === 'inactive') {
          this._restoreCircle(props.id);
          props.structure.cursor('voronoiSeries').cursor(seriesName).update(function() {
            return 'inactive';
          });
        }
      }.bind(this));
    },
    componentWillUnmount: function() {
      this.props.voronoiRef.destroy();
    },
    render: function() {
      var props = this.props;
      var state = this.state;
      return ((props.point_hl) ? React.createElement("g", null, React.createElement("circle", {
        cx: props.cx,
        cy: props.cy,
        r: props.r,
        fill: this.state.circleColor,
        id: props.id,
        className: props.className
      }), React.createElement("line", {
        x1: props.cx,
        y1: props.cy,
        x2: props.maxx,
        y2: props.cy,
        stroke: (props.point_mid ? 'gray' : this.state.circleColor),
        strokeDasharray: 1,
        id: props.id,
        className: props.className
      }), React.createElement("line", {
        x1: props.cx,
        y1: props.cy,
        x2: props.cx,
        y2: props.zeroy,
        stroke: (props.point_mid ? 'gray' : this.state.circleColor),
        strokeDasharray: 1,
        id: props.id,
        className: props.className
      })) : React.createElement("g", null, React.createElement("circle", {
        cx: props.cx,
        cy: props.cy,
        r: props.r,
        fill: props.point_mid ? 'gray' : this.state.circleColor,
        id: props.id,
        className: props.className
      })));
    },
    _animateCircle: function(id) {
      this.setState({
        circleRadius: this.state.circleRadius * (5 / 4),
        isActive: true
      });
    },
    _restoreCircle: function(id) {
      this.setState({
        circleRadius: this.props.r,
        isActive: false
      });
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/piechart/DataSeries", ["react", "d3", "./Arc"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var Arc = require("./Arc");
  module.exports = React.createClass({
    displayName: 'DataSeries',
    propTypes: {
      transform: React.PropTypes.string,
      data: React.PropTypes.array,
      innerRadius: React.PropTypes.number,
      radius: React.PropTypes.number,
      colors: React.PropTypes.func
    },
    getDefaultProps: function() {
      return {
        innerRadius: 0,
        data: [],
        colors: d3.scale.category20c()
      };
    },
    render: function() {
      var props = this.props;
      var pie = d3.layout.pie().sort(null);
      var arcData = pie(props.data);
      var arcs = arcData.map(function(arc, i) {
        return (React.createElement(Arc, {
          startAngle: arc.startAngle,
          endAngle: arc.endAngle,
          outerRadius: props.radius,
          innerRadius: props.innerRadius,
          labelTextFill: props.labelTextFill,
          valueTextFill: props.valueTextFill,
          fill: props.colors(i),
          label: props.labels[i],
          value: props.data[i],
          key: i,
          width: props.width
        }));
      });
      return (React.createElement("g", {
        className: "rd3-piechart-pie",
        transform: props.transform
      }, arcs));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/areachart/DataSeries", ["react", "d3", "./Area"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var Area = require("./Area");
  module.exports = React.createClass({
    displayName: 'DataSeries',
    render: function() {
      var props = this.props;
      var area = d3.svg.area().x(function(d) {
        return props.xScale(props.xAccessor(d));
      }).y0(function(d) {
        return props.yScale(d.y0);
      }).y1(function(d) {
        return props.yScale(d.y0 + props.yAccessor(d));
      });
      var path = area(props.data);
      return (React.createElement(Area, {
        fill: props.colors(props.index),
        path: path
      }));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/treemap/DataSeries", ["react", "d3", "./Cell"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var Cell = require("./Cell");
  module.exports = React.createClass({
    displayName: 'DataSeries',
    propTypes: {
      data: React.PropTypes.array,
      value: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        data: [],
        value: 'value',
        label: 'label'
      };
    },
    render: function() {
      var props = this.props;
      var data = props.data;
      var value = props.value;
      var label = props.label;
      var colors = d3.scale.category20c();
      var treemap = d3.layout.treemap().children(function(d) {
        return d;
      }).size([props.width, props.height]).sticky(true).value(function(d) {
        return d[value];
      });
      var cells = treemap(data).map(function(node, i) {
        return (React.createElement(Cell, {
          x: node.x,
          y: node.y,
          width: node.dx,
          height: node.dy,
          fill: colors(i),
          label: node[label],
          fontSize: props.fontSize,
          textColor: props.textColor,
          key: i
        }));
      }, this);
      return (React.createElement("g", {
        transform: props.transform,
        className: "treemap"
      }, cells));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/scatterchart/DataSeries", ["react", "./Circle"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var Circle = require("./Circle");
  module.exports = React.createClass({
    displayName: 'DataSeries',
    propTypes: {
      data: React.PropTypes.array,
      fill: React.PropTypes.string,
      xAccessor: React.PropTypes.func,
      yAccessor: React.PropTypes.func
    },
    getDefaultProps: function() {
      return {
        data: [],
        fill: '#fff',
        xAccessor: function(d) {
          return d.x;
        },
        yAccessor: function(d) {
          return d.y;
        }
      };
    },
    render: function() {
      var props = this.props;
      var circles = props.data.map(function(point, i) {
        var xAccessor = props.xAccessor,
            yAccessor = props.yAccessor,
            cx,
            cy;
        if (Object.prototype.toString.call(xAccessor(point)) === '[object Date]') {
          cx = props.xScale(xAccessor(point).getTime());
        } else {
          cx = props.xScale(xAccessor(point));
        }
        if (Object.prototype.toString.call(yAccessor(point)) === '[object Date]') {
          cy = props.yScale(yAccessor(point).getTime());
        } else {
          cy = props.yScale(yAccessor(point));
        }
        var id = props.seriesName + '-' + i;
        props.structure.cursor('voronoi').set(id, 'inactive');
        var voronoiRef = props.structure.reference(['voronoi', id]);
        return (React.createElement(Circle, {
          voronoiRef: voronoiRef,
          cx: cx,
          cy: cy,
          r: props.pointRadius,
          fill: props.fill,
          key: props.seriesName + i,
          id: id
        }));
      }, this);
      return (React.createElement("g", null, circles));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/candlestick/DataSeries", ["react", "d3", "../utils/index", "./Candle", "./Wick"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var utils = require("../utils/index");
  var Candle = require("./Candle");
  var Wick = require("./Wick");
  module.exports = React.createClass({
    displayName: 'DataSeries',
    propTypes: {
      fillUp: React.PropTypes.string.isRequired,
      fillDown: React.PropTypes.string.isRequired
    },
    render: function() {
      var props = this.props;
      var xRange = this.props.xScale.range(),
          width = Math.abs(xRange[0] - xRange[1]),
          candleWidth = (width / (this.props.data.length + 2)) * 0.5;
      var dataSeries = this.props.data.map(function(d, idx) {
        var ohlc = this.props.yAccessor(d),
            x = this.props.xScale(this.props.xAccessor(d)) - 0.5 * candleWidth,
            y = this.props.yScale(Math.max(ohlc.open, ohlc.close)),
            height = Math.abs(this.props.yScale(ohlc.open) - this.props.yScale(ohlc.close)),
            y2 = this.props.yScale(ohlc.low),
            ohlcClass = (ohlc.open <= ohlc.close) ? 'up' : 'down',
            className = (ohlcClass + " rd3-candlestick-rect"),
            fill = (ohlc.open <= ohlc.close) ? this.props.fillUp : this.props.fillDown;
        var x1 = this.props.xScale(this.props.xAccessor(d)),
            y1 = this.props.yScale(ohlc.high),
            x2 = x1;
        var id = props.series.name + '-' + idx;
        props.structure.cursor('voronoi').set(id, 'inactive');
        var voronoiRef = props.structure.reference(['voronoi', id]);
        return (React.createElement("g", {key: idx}, React.createElement(Wick, {
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2
        }), React.createElement(Candle, {
          voronoiRef: voronoiRef,
          fill: fill,
          id: id,
          x: x,
          y: y,
          width: candleWidth,
          height: height
        })));
      }.bind(this), this);
      return (React.createElement("g", null, dataSeries));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("github:mbostock/d3@3.5.5", ["github:mbostock/d3@3.5.5/d3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:mbostock/d3@3.5.5/d3");
  global.define = __define;
  return module.exports;
});



System.register("lib/components/deps/common/chart", ["react", "./legend"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var Legend = require("./legend").Legend;
  var PlainChart = React.createClass({
    displayName: "PlainChart",
    render: function() {
      return (React.createElement("div", null, React.createElement("h4", null, this.props.title), React.createElement("svg", {
        width: this.props.width,
        height: this.props.height
      }, this.props.children)));
    }
  });
  var LegendChart = React.createClass({
    displayName: "LegendChart",
    propTypes: {
      legend: React.PropTypes.bool,
      legendPosition: React.PropTypes.string,
      sideOffset: React.PropTypes.number,
      margins: React.PropTypes.object,
      data: React.PropTypes.oneOfType([React.PropTypes.object, React.PropTypes.array])
    },
    getDefaultProps: function() {
      return {
        data: {},
        legend: false,
        legendPosition: 'right',
        sideOffset: 90
      };
    },
    _renderLegend: function() {
      if (this.props.legend) {
        return (React.createElement(Legend, {
          legendPosition: this.props.legendPosition,
          margins: this.props.margins,
          colors: this.props.colors,
          data: this.props.data,
          width: this.props.width,
          height: this.props.height,
          sideOffset: this.props.sideOffset
        }));
      }
    },
    render: function() {
      return (React.createElement("div", {style: {
          'width': this.props.width,
          'height': this.props.height
        }}, React.createElement("h4", null, this.props.title), this._renderLegend(), React.createElement("svg", {
        width: this.props.width - this.props.sideOffset,
        height: this.props.height
      }, this.props.children)));
    }
  });
  exports.LegendChart = LegendChart;
  exports.Chart = React.createClass({
    displayName: "Chart",
    propTypes: {legend: React.PropTypes.bool},
    getDefaultProps: function() {
      return {legend: false};
    },
    render: function() {
      if (this.props.legend) {
        return React.createElement(LegendChart, React.__spread({}, this.props));
      }
      return React.createElement(PlainChart, React.__spread({}, this.props));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:events-browserify@0.0.1", ["npm:events-browserify@0.0.1/events"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:events-browserify@0.0.1/events");
  global.define = __define;
  return module.exports;
});



System.register("npm:base64-js@0.0.8", ["npm:base64-js@0.0.8/lib/b64"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:base64-js@0.0.8/lib/b64");
  global.define = __define;
  return module.exports;
});



System.register("npm:ieee754@1.1.4", ["npm:ieee754@1.1.4/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:ieee754@1.1.4/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:is-array@1.0.1", ["npm:is-array@1.0.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:is-array@1.0.1/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:crypt@0.0.1", ["npm:crypt@0.0.1/crypt"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:crypt@0.0.1/crypt");
  global.define = __define;
  return module.exports;
});



System.register("npm:charenc@0.0.1", ["npm:charenc@0.0.1/charenc"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:charenc@0.0.1/charenc");
  global.define = __define;
  return module.exports;
});



System.register("npm:escape-html@1.0.1", ["npm:escape-html@1.0.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:escape-html@1.0.1/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:valid-media-queries@0.0.3", ["npm:valid-media-queries@0.0.3/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:valid-media-queries@0.0.3/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:valid-css-props@0.0.5", ["npm:valid-css-props@0.0.5/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:valid-css-props@0.0.5/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:classnames@1.1.4", ["npm:classnames@1.1.4/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:classnames@1.1.4/index");
  global.define = __define;
  return module.exports;
});



System.register("lib/components/lp-bundle-matching.jsx!github:floatdrop/plugin-jsx@0.1.1", ["react", "immstruct", "omniscient", "immutable", "./tangle-text.jsx!", "d3", "lodash", "react-d3", "./info-tip.jsx!", "./bid-lp-solver.jsx!", "./msr-functions.jsx!"], function($__export) {
  "use strict";
  var __moduleName = "lib/components/lp-bundle-matching.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      immstruct,
      component,
      Immutable,
      TangleText,
      d3,
      _,
      rd3,
      LineChart,
      InfoTip,
      Auctioneer,
      MSR,
      costLMSR,
      priceLMSR,
      depthLMSR,
      depthShortLMSR,
      getSharesAmountFromCost,
      initial_array,
      structure,
      ob_ref,
      bid_table_ref,
      lp_result_ref,
      market_lp_result,
      inputMixin,
      StateView,
      LPBundleWidget;
  function roundToTwo(decimal_num) {
    return Math.round(100 * decimal_num) / 100;
  }
  function insertBid(bid_point, data_series) {
    if (data_series[0].y === 0) {
      data_series.splice(0, 1);
    }
    var new_bid_i = data_series.findIndex((function(bp) {
      return (bid_point.x > bp.x);
    }));
    var cum_depth = 0;
    if (new_bid_i == 0) {
      cum_depth = 0;
    } else {
      cum_depth = data_series[new_bid_i - 1].y;
    }
    var bid_point_plus_y = bid_point.y;
    var new_bid_point = {};
    new_bid_point.x = bid_point.x;
    new_bid_point.y = bid_point.y + cum_depth;
    new_bid_point.bid_i = bid_point.bid_i;
    data_series.splice(new_bid_i, 0, new_bid_point);
    var new_series = data_series.map((function(bid, point_i) {
      if (point_i > new_bid_i) {
        var new_bid = {};
        new_bid.y = bid.y + bid_point_plus_y;
        new_bid.x = bid.x;
        if (!_.isUndefined(bid.bid_i)) {
          new_bid.bid_i = bid.bid_i;
        }
        if (!_.isUndefined(bid.endpoint)) {
          new_bid.endpoint = bid.endpoint;
        }
        return new_bid;
      }
      return bid;
    }));
    var x_max = d3.max(new_series, (function(d) {
      return d.x;
    }));
    var y_max = d3.max(new_series, (function(d) {
      return d.y;
    }));
    if (new_series[0].endpoint !== true) {
      new_series.splice(0, 0, {
        'x': x_max,
        'y': 0,
        'endpoint': true
      });
    }
    if (new_series[new_series.length - 1].endpoint !== true) {
      new_series = new_series.concat({
        'x': 0,
        'y': y_max,
        'endpoint': true
      });
    }
    return new_series;
  }
  function insertAsk(ask_point, data_series, q_i) {
    if (!(ask_point.x > 0 && ask_point.y > 0)) {
      return data_series;
    }
    if (data_series[0].y === 0) {
      data_series.splice(0, 1);
    }
    var new_ask_i = data_series.findIndex((function(ap) {
      return (ask_point.x < ap.x);
    }));
    var cum_depth = data_series.slice(0, new_ask_i).reduce((function(memo, ap) {
      return ap.y + memo;
    }), 0);
    var cum_depth_test = 0;
    if (new_ask_i > 0) {
      cum_depth_test = data_series[new_ask_i - 1].y;
    }
    var new_depth_add = ask_point.y;
    var adjusted_ask_point = {};
    adjusted_ask_point.x = ask_point.x;
    adjusted_ask_point.y = ask_point.y + cum_depth_test;
    adjusted_ask_point.bid_i = ask_point.bid_i;
    data_series.splice(new_ask_i, 0, adjusted_ask_point);
    var new_series = data_series.map((function(ask, point_i) {
      if (point_i > new_ask_i) {
        var new_ask = {};
        new_ask.y = ask.y + new_depth_add;
        new_ask.x = ask.x;
        if (!_.isUndefined(ask.bid_i)) {
          new_ask.bid_i = ask.bid_i;
        }
        if (!_.isUndefined(ask.endpoint)) {
          new_ask.endpoint = ask.endpoint;
        }
        return new_ask;
      }
      return ask;
    }));
    var x_min = d3.min(new_series, (function(d) {
      return d.x;
    }));
    new_series.splice(0, 0, {
      'x': x_min,
      'y': 0,
      'endpoint': true
    });
    return new_series;
  }
  return {
    setters: [function(m) {
      React = m.default;
    }, function(m) {
      immstruct = m.default;
    }, function(m) {
      component = m.default;
    }, function(m) {
      Immutable = m.default;
    }, function(m) {
      TangleText = m.default;
    }, function(m) {
      d3 = m.default;
    }, function(m) {
      _ = m.default;
    }, function(m) {
      rd3 = m.default;
    }, function(m) {
      InfoTip = m.InfoTip;
    }, function(m) {
      Auctioneer = m.default;
    }, function(m) {
      MSR = m.default;
    }],
    execute: function() {
      LineChart = rd3.LineChart;
      costLMSR = MSR.costLMSR;
      priceLMSR = MSR.priceLMSR;
      depthLMSR = MSR.depthLMSR;
      depthShortLMSR = MSR.depthShortLMSR;
      getSharesAmountFromCost = MSR.getSharesAmountFromCost;
      initial_array = [0, 0, 0, 0];
      structure = immstruct({market: {
          Bparam: 250,
          inventoryVector: initial_array,
          orderbook: {
            bid_table: [[1, 0, 0, 0], [0.4, 0.3, 0.2, 0.1], [0.1, 0.2, 0.3, 0.4]],
            bid_prices: [0, 0, 0],
            bid_quantities: [50, 50, 50]
          },
          bids_lp_result: {},
          bidMouseover: 0
        }});
      ob_ref = structure.reference(['market', 'orderbook']);
      bid_table_ref = structure.reference(['market', 'orderbook', 'bid_table']);
      lp_result_ref = structure.reference(['market', 'bids_lp_result']);
      market_lp_result = structure.reference(['market']);
      lp_result_ref.observe(function(val, val2) {
        var test_val = lp_result_ref.cursor().deref().toJS();
      });
      Auctioneer.init(ob_ref, bid_table_ref, market_lp_result);
      inputMixin = {
        onChangeLimitBid: function(indx, val) {
          var bid_table = this.props.cursor.cursor('orderbook').get('bid_table').deref().toJS();
          bid_table[indx.i][indx.j] = val;
          this.props.cursor.cursor('orderbook').update('bid_table', (function(old) {
            return Immutable.fromJS(bid_table);
          }));
        },
        onInputLimitPrice: function(row_i, val) {
          var limit_prices = this.props.cursor.cursor('orderbook').get('bid_prices').deref().toJS();
          limit_prices[row_i] = val;
          this.props.cursor.cursor('orderbook').update('bid_prices', (function() {
            return Immutable.fromJS(limit_prices);
          }));
        },
        onInputLimitQuantity: function(row_i, val) {
          var limit_quantities = this.props.cursor.cursor('orderbook').get('bid_quantities').deref().toJS();
          limit_quantities[row_i] = val;
          this.props.cursor.cursor('orderbook').update('bid_quantities', (function() {
            return Immutable.fromJS(limit_quantities);
          }));
        },
        handleAddNewBid: function(val) {
          var ob_obj = this.props.cursor.get('orderbook').deref().toJS();
          ob_obj.bid_table = ob_obj.bid_table.concat([new Array(ob_obj.bid_table[0].length).fill(0)]);
          ob_obj.bid_prices.push(0);
          ob_obj.bid_quantities.push(0);
          this.props.cursor.update('orderbook', (function(oldVec) {
            return Immutable.fromJS(ob_obj);
          }));
        },
        onBidMouseover: function(row_i, val) {
          this.props.cursor.update('bidMouseover', (function() {
            return row_i;
          }));
        },
        onBidMouseout: function(val) {
          this.props.cursor.update('bidMouseover', (function() {
            return 0;
          }));
        }
      };
      StateView = component(inputMixin, function(cursor) {
        var $__0 = this;
        var curs = cursor.cursor;
        var lp_auction_result = curs.get('bids_lp_result').deref().toJS();
        var thisComponent = this;
        var b_param = curs.get('Bparam');
        var inv_vec = curs.get('inventoryVector').deref().toArray();
        var msr_prices = priceLMSR(b_param, inv_vec);
        var MMBidsCount;
        var MMBidsTable;
        var MMBidsObject;
        function getSimpleDepthForAllOutcomes(num_outcomes) {
          var bid_vec = new Array(num_outcomes);
          var mm_bids = Auctioneer.generateMMbids(bid_vec);
          MMBidsObject = mm_bids;
          MMBidsTable = mm_bids.bid_matrix;
          MMBidsCount = mm_bids.bid_matrix.length;
          var mm_bids_chart_series = Auctioneer.transformBidLinesToDataSeries(mm_bids);
          return mm_bids_chart_series;
        }
        var MMBidsDataSeries = getSimpleDepthForAllOutcomes(msr_prices.length);
        var polyXscales = msr_prices.map((function(p) {
          return d3.scale.linear().domain([0.001, p, 0.99]);
        }));
        var regularPscale = d3.scale.linear().domain([0, 1]);
        var orderbookProps = this.props.cursor.get('orderbook').deref().toJS();
        var bidMatrix = orderbookProps.bid_table;
        var bidPrices = orderbookProps.bid_prices;
        var bidQuantities = orderbookProps.bid_quantities;
        var num_of_prices = bidMatrix[0].length;
        var lp_offset = MMBidsCount;
        var bidMouseIndex = this.props.cursor.get('bidMouseover');
        var ClearingResultsFills = bidMatrix.map((function(bid, row_i) {
          var key_fill = ("x" + (lp_offset + row_i + 1));
          return lp_auction_result[key_fill];
        }));
        ClearingResultsFills = ClearingResultsFills.map((function(q) {
          return (q !== undefined) ? q.toFixed(1) : 0;
        }));
        var BidComponentInputs = bidMatrix.map((function(bid_bundle, row_i) {
          var bid_i = MMBidsCount + row_i + 1;
          var class_name = "";
          if (bidMouseIndex === bid_i) {
            class_name = "mouse-hl";
          }
          var bid_component_inputs = bid_bundle.map((function(q, j) {
            return (React.createElement("div", {
              key: "q_" + j,
              style: {
                'display': 'inline-block',
                'marginLeft': '2px'
              }
            }, React.createElement(TangleText, {
              value: bidMatrix[row_i][j],
              min: 0,
              max: 1,
              step: 0.01,
              size: 2,
              onChange: thisComponent.onChangeLimitBid.bind($__0, {
                'i': row_i,
                'j': j
              })
            })));
          }));
          return (React.createElement("tr", {
            key: "bid_tr_" + row_i,
            onTouchStart: thisComponent.onBidMouseover.bind(thisComponent, bid_i),
            onMouseEnter: thisComponent.onBidMouseover.bind(thisComponent, bid_i)
          }, React.createElement("td", {
            className: class_name,
            style: {paddingRight: '10px'}
          }, bid_component_inputs), React.createElement("td", {className: class_name}, React.createElement(TangleText, {
            value: bidPrices[row_i],
            min: 0,
            max: 1,
            step: 0.01,
            size: 2,
            onChange: $__0.onInputLimitPrice.bind($__0, row_i)
          })), React.createElement("td", {className: class_name}, React.createElement(TangleText, {
            value: bidQuantities[row_i],
            min: 0,
            max: 1000,
            step: 1,
            size: 2,
            onChange: $__0.onInputLimitQuantity.bind($__0, row_i)
          })), React.createElement("td", {className: class_name}, React.createElement("span", {style: {fontSize: "12px"}}, ClearingResultsFills[row_i]))));
        }));
        var MMComponentTable = MMBidsTable.map((function(bid_vec, bid_i) {
          var fill_key = "x" + (bid_i + 1);
          var class_name = "";
          if (bidMouseIndex === bid_i + 1) {
            class_name = "mouse-hl";
          }
          return (React.createElement("tr", {
            key: "bid_" + bid_i,
            onClick: thisComponent.onBidMouseover.bind(thisComponent, bid_i + 1),
            onTouchStart: thisComponent.onBidMouseover.bind(thisComponent, bid_i + 1),
            onMouseEnter: thisComponent.onBidMouseover.bind(thisComponent, bid_i + 1)
          }, React.createElement("td", {className: class_name}, "#", bid_i), React.createElement("td", {className: class_name}, bid_vec.join(" ")), React.createElement("td", {
            className: class_name,
            style: {paddingLeft: '15px'}
          }, MMBidsObject.bid_prices[bid_i]), React.createElement("td", {
            className: class_name,
            style: {paddingLeft: '15px'}
          }, MMBidsObject.bid_quantities[bid_i]), React.createElement("td", {className: class_name}, lp_auction_result[fill_key])));
        }));
        var ClearResultsPrices = bidMatrix[0].map((function(state, col_j) {
          var key_price = ("x" + (col_j + 1) + "_dual");
          var clearing_price = lp_auction_result[key_price];
          return Math.round(1000 * clearing_price) / 1000;
        }));
        var LPClearingPrices = ClearResultsPrices.map((function(p) {
          return (p !== undefined) ? p.toFixed(2) : 0;
        })).join(", ");
        var UserBids = bidMatrix.map((function(user_bid_bundle, row_i) {
          var user_bid_i = MMBidsCount + row_i;
          var fill_key = "x" + (user_bid_i + 1);
          var user_bid_fill = lp_auction_result[fill_key];
          var bundle_with_fill = {};
          bundle_with_fill.bundle = user_bid_bundle;
          bundle_with_fill.quantity = bidQuantities[row_i];
          bundle_with_fill.price = bidPrices[row_i];
          bundle_with_fill.fill = user_bid_fill;
          bundle_with_fill.bid_i = user_bid_i;
          return bundle_with_fill;
        }));
        var UserBidsSorted = _.sortBy(UserBids, (function(user_bid) {
          if (user_bid.fill === user_bid.quantity) {
            return 0;
          }
          if (user_bid.fill < user_bid.quantity) {
            return 1;
          }
          if (user_bid.fill === 0) {
            return 2;
          }
        }));
        UserBidsSorted.forEach((function(user_bid, row_i) {
          var bid_bundle = user_bid.bundle;
          var new_bid_index = user_bid.bid_i;
          var shares_amount;
          var new_bid_point;
          if (bid_bundle.indexOf(1) !== -1 && user_bid.price > 0) {
            var state_i = bid_bundle.indexOf(1);
            var atomic_bid_price = user_bid.price;
            shares_amount = user_bid.quantity;
            new_bid_point = {
              'x': atomic_bid_price,
              'y': shares_amount,
              'bid_i': new_bid_index
            };
            MMBidsDataSeries[state_i][0].values = insertBid(new_bid_point, MMBidsDataSeries[state_i][0].values);
            var uniform_bid_price = 1 / (bid_bundle.length);
            uniform_bid_price = Math.round(1000 * uniform_bid_price) / 1000;
            var uniform_ask_price;
            var uniform_ask_quantity;
            if (atomic_bid_price > uniform_bid_price) {
              uniform_ask_price = ((1 - atomic_bid_price) / (bid_bundle.length - 1));
              uniform_ask_quantity = shares_amount;
            } else if (atomic_bid_price <= uniform_bid_price) {
              var diff_from_uni = Math.abs(uniform_bid_price - atomic_bid_price);
              uniform_ask_price = diff_from_uni * (bid_bundle.length - 1) + uniform_bid_price;
              uniform_ask_quantity = shares_amount;
            }
            var user_bid_fill = user_bid.fill;
            var plot_amount = shares_amount;
            bid_bundle.forEach((function(component_j, col_j) {
              if (col_j !== state_i) {
                console.log('plotting phantom ask for col_j:', col_j);
                var lp_clearing_price = ClearResultsPrices[col_j];
                lp_clearing_price = Math.round(1000 * lp_clearing_price) / 1000;
                var new_ask_point = {
                  'x': lp_clearing_price,
                  'y': plot_amount,
                  'bid_i': new_bid_index
                };
                console.log('adding new phantom ask for an atomic bid. new_ask_point:', new_ask_point);
                if (MMBidsDataSeries[col_j][1].values.findIndex((function(ask) {
                  return (ask.x == new_ask_point.x && ask.y == new_ask_point.y);
                })) == -1) {
                  MMBidsDataSeries[col_j][1].values = insertAsk(new_ask_point, MMBidsDataSeries[col_j][1].values);
                }
              }
            }));
          } else if (user_bid.price > 0) {
            var mixed_bundle_price = user_bid.price;
            var state_clearing_price;
            var bid_state_price;
            var mixed_bid_fill = user_bid.fill;
            var bid_bundle_copy = bid_bundle.map((function(qi) {
              return qi;
            }));
            bid_bundle.forEach((function(qi_shares, state_i) {
              if (qi_shares > 0) {
                shares_amount = qi_shares * user_bid.quantity;
                state_clearing_price = ClearResultsPrices[state_i];
                if (mixed_bid_fill > 0) {
                  if (mixed_bundle_price > state_clearing_price) {
                    bid_state_price = mixed_bundle_price;
                  } else {
                    bid_state_price = state_clearing_price;
                  }
                } else {
                  bid_state_price = mixed_bundle_price;
                }
                var new_mixed_bid_point = {
                  'x': bid_state_price,
                  'y': shares_amount,
                  'bid_i': new_bid_index
                };
                MMBidsDataSeries[state_i][0].values = insertBid(new_mixed_bid_point, MMBidsDataSeries[state_i][0].values);
                if (state_i === 0) {
                  var phantom_ask_amount = qi_shares * user_bid.quantity;
                  bid_bundle_copy.forEach((function(el, s_i) {
                    if (s_i !== state_i) {
                      var phantom_ask_price = ClearResultsPrices[s_i];
                      var phantom_ask = {
                        'x': phantom_ask_price,
                        'y': phantom_ask_amount,
                        'bid_i': new_bid_index
                      };
                      var find_existing_phantom = MMBidsDataSeries[s_i][1].values.findIndex((function(ask) {
                        return ask.bid_i == phantom_ask.bid_i;
                      }));
                      MMBidsDataSeries[s_i][1].values = insertAsk(phantom_ask, MMBidsDataSeries[s_i][1].values, s_i);
                    }
                  }));
                }
              }
            }));
          }
        }));
        var margins = {
          'top': 10,
          'right': 80,
          'bottom': 50,
          'left': 80
        };
        var i_sub_str = ['₀', '₁', '₂', '₃', '₄'];
        var priceCharts = inv_vec.map((function(q, i) {
          return (React.createElement("div", {
            key: "chart_" + i,
            style: {
              'border': '1px solid gray',
              'borderTop': '0px',
              'width': '450px',
              'height': '130px'
            }
          }, React.createElement("div", {style: {'marginTop': '-15px'}}, React.createElement(LineChart, {
            legend: false,
            data: MMBidsDataSeries[i],
            hoverAnimation: false,
            width: 450,
            height: 150,
            pointRadius: 2,
            interpolationType: "step-after",
            bidHlIndex: bidMouseIndex - 1,
            colors: d3.scale.ordinal().range(["green", "orange", "orange", "green"]),
            margins: margins,
            polyxScale: polyXscales[i],
            yOrient: "left",
            yAxisTickCount: 5,
            yAxisLabel: "bid amount r" + i + "\n (shares)",
            yAxisLabelOffset: 55,
            dualYscale: true
          }))));
        }));
        return (React.createElement("div", null, React.createElement("div", {className: "flex-row-spacearound"}, React.createElement("div", null, React.createElement("strong", null, "Batch Combinatorial Auction"), React.createElement("br", null), React.createElement("span", null, "Using Linear Programming (LP) to match bundle bids with uniform-price clearing"), React.createElement("br", null), React.createElement("br", null), "Number of atomic securities: ", inv_vec.length, React.createElement(InfoTip, {
          iconSize: "",
          width: "280px"
        }, React.createElement("span", null, "In this example, we use a combinatorial auction to trade bundles of binary options, or in other words, portfolios of atomic securities. Since there are four atomic securities, each bundle or portfolio is a vector ", React.createElement("b", null, "r"), " with four components (i.e. ", React.createElement("b", null, "r"), " = [r", React.createElement("sub", null, "0"), ", r", React.createElement("sub", null, "1"), ", r", React.createElement("sub", null, "2"), ", r", React.createElement("sub", null, "3"), "]). ")))), React.createElement("br", null), React.createElement("div", {
          className: "flex-row-spacebetween",
          style: {'height': '600px'}
        }, React.createElement("div", {style: {'marginTop': '15px'}}, React.createElement("span", {style: {fontSize: "1.1em"}}, "Combinatorial Order Book:"), React.createElement(InfoTip, {
          iconSize: "",
          width: "280px"
        }, React.createElement("span", null, "A combinatorial order book enables the trading of multiple related items through a single auction mechanism (a combinatorial auction). In our case, the items are atomic securities (i.e. binary options which span an outcome space). Since there are four atomic securities, we display four order books, one for each security: [r0, r1, r2, r3]. Note that the x-axes use a polylinear scale to center the plots on the initial state clearing prices.")), React.createElement("div", {
          className: "flex-column-start depthChartContainer",
          style: {
            'width': '450px',
            'height': '600px',
            'borderTop': '1px solid gray'
          }
        }, priceCharts)), React.createElement("div", {style: {
            "textAlign": "center",
            'width': '40%',
            'padding': '15px'
          }}, React.createElement("span", {style: {fontSize: "1.1em"}}, "Market Maker bids:"), React.createElement(InfoTip, {
          iconSize: "",
          width: "280px"
        }, React.createElement("span", null, "In order to calculate a unique solution for the state clearing prices, the LP auctioneer needs to be given a sufficient set of linearly independent bids. So at a minimum, we need a set of four bids, one for each atomic security (i.e. [1,0,0,0], [0,1,0,0], ..). We create multiple sets to fill in the order book with a staircase formation of bids at a ladder of seven price levels, starting from 0.25 and decreasing (0.25, 0.22, 0.19, ...). All bids have an arbitrary quantity of 20 units.")), React.createElement("div", {
          style: {
            height: '200px',
            'overflowY': 'scroll',
            border: "1px solid gray",
            display: "inline-block"
          },
          onMouseLeave: this.onBidMouseout,
          onTouchEnd: this.onBidMouseout
        }, React.createElement("table", {className: "bidsTable"}, React.createElement("tr", {style: {fontSize: "12px"}}, React.createElement("td", null, "i"), React.createElement("td", {colSpan: "1"}, "bundle"), React.createElement("td", null, "   price"), React.createElement("td", null, "quantity"), React.createElement("td", null, "fill")), MMComponentTable)), React.createElement("br", null), React.createElement("br", null), React.createElement("div", {style: {"textAlign": "center"}}, React.createElement("div", {style: {
            "textAlign": "center",
            display: "inline-block"
          }}, React.createElement("span", {style: {fontSize: "1.1em"}}, "Trader-entered bids:"), React.createElement("table", {
          onMouseLeave: this.onBidMouseout,
          onTouchEnd: this.onBidMouseout
        }, React.createElement("tr", {style: {fontSize: "12px"}}, React.createElement("td", null, "bundle"), React.createElement("td", null, "price"), React.createElement("td", null, "quantity"), React.createElement("td", null, "fill")), BidComponentInputs), React.createElement("button", {
          type: "button",
          onClick: this.handleAddNewBid
        }, "Add New Bid")), React.createElement("br", null), React.createElement("br", null), React.createElement("span", {style: {fontSize: "1.1em"}}, "LP", React.createElement("sup", null, "*"), " calculated state clearing prices:"), React.createElement("br", null), React.createElement("span", {style: {fontSize: "1em"}}, LPClearingPrices), React.createElement("br", null), React.createElement("br", null), React.createElement("span", null, React.createElement("sup", null, "*"), " The LP algorithm also determines the bid fills."))))));
      }).jsx;
      LPBundleWidget = (function() {
        var LPBundleWidget = function LPBundleWidget() {};
        return ($traceurRuntime.createClass)(LPBundleWidget, {init: function(el) {
            render(el);
            structure.on('swap', render);
            function render() {
              React.render(React.createElement(StateView, {cursor: structure.cursor('market')}), el);
            }
          }}, {});
      }());
      $__export('default', new LPBundleWidget());
    }
  };
});



System.register("lib/components/deps/barchart.js!github:floatdrop/plugin-jsx@0.1.1", ["react", "d3", "./common.js!jsx", "lodash"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require('react');
  var d3 = require('d3');
  var Chart = require('./common.js!jsx').Chart;
  var _ = require('lodash');
  var Bar = React.createClass({
    displayName: "Bar",
    propTypes: {
      fill: React.PropTypes.string,
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      offset: React.PropTypes.number
    },
    getDefaultProps: function() {
      return {offset: 0};
    },
    render: function() {
      return (React.createElement("rect", {
        fill: this.props.fill,
        width: this.props.width,
        height: this.props.height,
        x: this.props.offset,
        y: this.props.availableHeight - this.props.height
      }));
    }
  });
  var XAxis = React.createClass({
    displayName: "XAxis",
    styleAxis: function() {
      var props = this.props;
      var xAxis = d3.svg.axis().scale(props.xScale).orient("bottom");
      var node = d3.select(this.refs.barxaxis.getDOMNode());
      node.attr("class", "barx axis").call(xAxis);
      node.selectAll('line').attr("shape-rendering", "crispEdges").attr("stroke", "#000");
      node.select('path').attr("shape-rendering", "crispEdges").attr("fill", "none").attr("stroke", "none");
    },
    componentDidMount: function() {
      this.styleAxis();
    },
    componentDidUpdate: function() {
      this.styleAxis();
    },
    render: function() {
      var t = "translate(0," + this.props.height + ")";
      return (React.createElement("g", {
        ref: "barxaxis",
        className: "barx axis",
        transform: t
      }));
    }
  });
  var YAxis = React.createClass({
    displayName: "YAxis",
    styleAxis: function() {
      var props = this.props;
      var yAxis = d3.svg.axis().ticks(props.yAxisTickCount).scale(props.yScale).orient("left");
      var node = this.refs.baryaxis.getDOMNode();
      d3.select(node).attr("class", "bary axis").call(yAxis);
      d3.selectAll('.bary.axis').selectAll('line').attr("shape-rendering", "crispEdges").attr("stroke", "#000");
      d3.selectAll('.bary.axis').select('path').attr("shape-rendering", "crispEdges").attr("fill", "none").attr("stroke", "#000");
    },
    componentDidMount: function() {
      this.styleAxis();
    },
    componentDidUpdate: function() {
      this.styleAxis();
    },
    render: function() {
      return (React.createElement("g", {
        ref: "baryaxis",
        className: "bary axis"
      }));
    }
  });
  var DataSeries = React.createClass({
    displayName: "DataSeries",
    propTypes: {
      fill: React.PropTypes.string,
      title: React.PropTypes.string,
      padding: React.PropTypes.number,
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      offset: React.PropTypes.number
    },
    getDefaultProps: function() {
      return {
        padding: 0.1,
        data: []
      };
    },
    render: function() {
      var props = this.props;
      var xScale = d3.scale.ordinal().domain(d3.range(props.values.length)).rangeRoundBands([0, this.props.width], this.props.padding);
      var bars = props.values.map(function(point, i) {
        return (React.createElement(Bar, {
          height: props.yScale(0) - props.yScale(point),
          width: xScale.rangeBand(),
          offset: xScale(i),
          availableHeight: props.height,
          fill: props.fill,
          key: i
        }));
      });
      return (React.createElement("g", null, bars));
    }
  });
  var BarChart = React.createClass({
    displayName: "BarChart",
    getDefaultProps: function() {
      return {
        data: [],
        yAxisTickCount: 4,
        width: 500,
        height: 200,
        margins: {
          top: 20,
          right: 30,
          bottom: 30,
          left: 30
        },
        fill: "cornflowerblue"
      };
    },
    render: function() {
      var values = _.pluck(this.props.data, 'value');
      var labels = _.pluck(this.props.data, 'label');
      var margins = this.props.margins;
      var sideMargins = margins.left + margins.right;
      var topBottomMargins = margins.top + margins.bottom;
      var y_domain = [0, d3.max(values)];
      if (this.props.yAxis) {
        y_domain = [this.props.yAxis[0], this.props.yAxis[1]];
      }
      var yScale = d3.scale.linear().domain(y_domain).range([this.props.height - topBottomMargins, 0]);
      var xScale = d3.scale.ordinal().domain(labels).rangeRoundBands([0, this.props.width - sideMargins], 0.1);
      var trans = "translate(" + margins.left + "," + margins.top + ")";
      return (React.createElement(Chart, {
        width: this.props.width,
        height: this.props.height
      }, React.createElement("g", {transform: trans}, React.createElement(DataSeries, {
        values: values,
        yScale: yScale,
        xScale: yScale,
        margins: margins,
        data: this.props.data,
        width: this.props.width - sideMargins,
        height: this.props.height - topBottomMargins,
        fill: this.props.fill
      }), React.createElement(YAxis, {
        yScale: yScale,
        margins: margins,
        yAxisTickCount: this.props.yAxisTickCount,
        width: this.props.width - sideMargins,
        height: this.props.height - topBottomMargins
      }), React.createElement(XAxis, {
        xScale: xScale,
        data: this.props.data,
        margins: margins,
        width: this.props.width - sideMargins,
        height: this.props.height - topBottomMargins
      }))));
    }
  });
  exports.BarChart = BarChart;
  global.define = __define;
  return module.exports;
});



System.register("github:jspm/nodelibs-process@0.1.1/index", ["process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require('process');
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPluginUtils", ["./EventConstants", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var invariant = require("./invariant");
    var injection = {
      Mount: null,
      injectMount: function(InjectedMount) {
        injection.Mount = InjectedMount;
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? invariant(InjectedMount && InjectedMount.getNode, 'EventPluginUtils.injection.injectMount(...): Injected Mount module ' + 'is missing getNode.') : invariant(InjectedMount && InjectedMount.getNode));
        }
      }
    };
    var topLevelTypes = EventConstants.topLevelTypes;
    function isEndish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
    }
    function isMoveish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
    }
    function isStartish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
    }
    var validateEventDispatches;
    if ("production" !== process.env.NODE_ENV) {
      validateEventDispatches = function(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchIDs = event._dispatchIDs;
        var listenersIsArr = Array.isArray(dispatchListeners);
        var idsIsArr = Array.isArray(dispatchIDs);
        var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
        ("production" !== process.env.NODE_ENV ? invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen));
      };
    }
    function forEachEventDispatch(event, cb) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          cb(event, dispatchListeners[i], dispatchIDs[i]);
        }
      } else if (dispatchListeners) {
        cb(event, dispatchListeners, dispatchIDs);
      }
    }
    function executeDispatch(event, listener, domID) {
      event.currentTarget = injection.Mount.getNode(domID);
      var returnValue = listener(event, domID);
      event.currentTarget = null;
      return returnValue;
    }
    function executeDispatchesInOrder(event, executeDispatch) {
      forEachEventDispatch(event, executeDispatch);
      event._dispatchListeners = null;
      event._dispatchIDs = null;
    }
    function executeDispatchesInOrderStopAtTrueImpl(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          if (dispatchListeners[i](event, dispatchIDs[i])) {
            return dispatchIDs[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchIDs)) {
          return dispatchIDs;
        }
      }
      return null;
    }
    function executeDispatchesInOrderStopAtTrue(event) {
      var ret = executeDispatchesInOrderStopAtTrueImpl(event);
      event._dispatchIDs = null;
      event._dispatchListeners = null;
      return ret;
    }
    function executeDirectDispatch(event) {
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchID = event._dispatchIDs;
      ("production" !== process.env.NODE_ENV ? invariant(!Array.isArray(dispatchListener), 'executeDirectDispatch(...): Invalid `event`.') : invariant(!Array.isArray(dispatchListener)));
      var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
      event._dispatchListeners = null;
      event._dispatchIDs = null;
      return res;
    }
    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }
    var EventPluginUtils = {
      isEndish: isEndish,
      isMoveish: isMoveish,
      isStartish: isStartish,
      executeDirectDispatch: executeDirectDispatch,
      executeDispatch: executeDispatch,
      executeDispatchesInOrder: executeDispatchesInOrder,
      executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
      hasDispatches: hasDispatches,
      injection: injection,
      useTouchEvents: false
    };
    module.exports = EventPluginUtils;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactElement", ["./ReactContext", "./ReactCurrentOwner", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactContext = require("./ReactContext");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var warning = require("./warning");
    var RESERVED_PROPS = {
      key: true,
      ref: true
    };
    function defineWarningProperty(object, key) {
      Object.defineProperty(object, key, {
        configurable: false,
        enumerable: true,
        get: function() {
          if (!this._store) {
            return null;
          }
          return this._store[key];
        },
        set: function(value) {
          ("production" !== process.env.NODE_ENV ? warning(false, 'Don\'t set the ' + key + ' property of the component. ' + 'Mutate the existing props object instead.') : null);
          this._store[key] = value;
        }
      });
    }
    var useMutationMembrane = false;
    function defineMutationMembrane(prototype) {
      try {
        var pseudoFrozenProperties = {props: true};
        for (var key in pseudoFrozenProperties) {
          defineWarningProperty(prototype, key);
        }
        useMutationMembrane = true;
      } catch (x) {}
    }
    var ReactElement = function(type, key, ref, owner, context, props) {
      this.type = type;
      this.key = key;
      this.ref = ref;
      this._owner = owner;
      this._context = context;
      if ("production" !== process.env.NODE_ENV) {
        this._store = {
          validated: false,
          props: props
        };
        if (useMutationMembrane) {
          Object.freeze(this);
          return;
        }
      }
      this.props = props;
    };
    ReactElement.prototype = {_isReactElement: true};
    if ("production" !== process.env.NODE_ENV) {
      defineMutationMembrane(ReactElement.prototype);
    }
    ReactElement.createElement = function(type, config, children) {
      var propName;
      var props = {};
      var key = null;
      var ref = null;
      if (config != null) {
        ref = config.ref === undefined ? null : config.ref;
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(config.key !== null, 'createElement(...): Encountered component with a `key` of null. In ' + 'a future version, this will be treated as equivalent to the string ' + '\'null\'; instead, provide an explicit key or use undefined.') : null);
        }
        key = config.key == null ? null : '' + config.key;
        for (propName in config) {
          if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (typeof props[propName] === 'undefined') {
            props[propName] = defaultProps[propName];
          }
        }
      }
      return new ReactElement(type, key, ref, ReactCurrentOwner.current, ReactContext.current, props);
    };
    ReactElement.createFactory = function(type) {
      var factory = ReactElement.createElement.bind(null, type);
      factory.type = type;
      return factory;
    };
    ReactElement.cloneAndReplaceProps = function(oldElement, newProps) {
      var newElement = new ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._owner, oldElement._context, newProps);
      if ("production" !== process.env.NODE_ENV) {
        newElement._store.validated = oldElement._store.validated;
      }
      return newElement;
    };
    ReactElement.isValidElement = function(object) {
      var isElement = !!(object && object._isReactElement);
      return isElement;
    };
    module.exports = ReactElement;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactComponent", ["./ReactElement", "./ReactOwner", "./ReactUpdates", "./Object.assign", "./invariant", "./keyMirror", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var ReactOwner = require("./ReactOwner");
    var ReactUpdates = require("./ReactUpdates");
    var assign = require("./Object.assign");
    var invariant = require("./invariant");
    var keyMirror = require("./keyMirror");
    var ComponentLifeCycle = keyMirror({
      MOUNTED: null,
      UNMOUNTED: null
    });
    var injected = false;
    var unmountIDFromEnvironment = null;
    var mountImageIntoNode = null;
    var ReactComponent = {
      injection: {injectEnvironment: function(ReactComponentEnvironment) {
          ("production" !== process.env.NODE_ENV ? invariant(!injected, 'ReactComponent: injectEnvironment() can only be called once.') : invariant(!injected));
          mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;
          unmountIDFromEnvironment = ReactComponentEnvironment.unmountIDFromEnvironment;
          ReactComponent.BackendIDOperations = ReactComponentEnvironment.BackendIDOperations;
          injected = true;
        }},
      LifeCycle: ComponentLifeCycle,
      BackendIDOperations: null,
      Mixin: {
        isMounted: function() {
          return this._lifeCycleState === ComponentLifeCycle.MOUNTED;
        },
        setProps: function(partialProps, callback) {
          var element = this._pendingElement || this._currentElement;
          this.replaceProps(assign({}, element.props, partialProps), callback);
        },
        replaceProps: function(props, callback) {
          ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'replaceProps(...): Can only update a mounted component.') : invariant(this.isMounted()));
          ("production" !== process.env.NODE_ENV ? invariant(this._mountDepth === 0, 'replaceProps(...): You called `setProps` or `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(this._mountDepth === 0));
          this._pendingElement = ReactElement.cloneAndReplaceProps(this._pendingElement || this._currentElement, props);
          ReactUpdates.enqueueUpdate(this, callback);
        },
        _setPropsInternal: function(partialProps, callback) {
          var element = this._pendingElement || this._currentElement;
          this._pendingElement = ReactElement.cloneAndReplaceProps(element, assign({}, element.props, partialProps));
          ReactUpdates.enqueueUpdate(this, callback);
        },
        construct: function(element) {
          this.props = element.props;
          this._owner = element._owner;
          this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
          this._pendingCallbacks = null;
          this._currentElement = element;
          this._pendingElement = null;
        },
        mountComponent: function(rootID, transaction, mountDepth) {
          ("production" !== process.env.NODE_ENV ? invariant(!this.isMounted(), 'mountComponent(%s, ...): Can only mount an unmounted component. ' + 'Make sure to avoid storing components between renders or reusing a ' + 'single component instance in multiple places.', rootID) : invariant(!this.isMounted()));
          var ref = this._currentElement.ref;
          if (ref != null) {
            var owner = this._currentElement._owner;
            ReactOwner.addComponentAsRefTo(this, ref, owner);
          }
          this._rootNodeID = rootID;
          this._lifeCycleState = ComponentLifeCycle.MOUNTED;
          this._mountDepth = mountDepth;
        },
        unmountComponent: function() {
          ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'unmountComponent(): Can only unmount a mounted component.') : invariant(this.isMounted()));
          var ref = this._currentElement.ref;
          if (ref != null) {
            ReactOwner.removeComponentAsRefFrom(this, ref, this._owner);
          }
          unmountIDFromEnvironment(this._rootNodeID);
          this._rootNodeID = null;
          this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
        },
        receiveComponent: function(nextElement, transaction) {
          ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'receiveComponent(...): Can only update a mounted component.') : invariant(this.isMounted()));
          this._pendingElement = nextElement;
          this.performUpdateIfNecessary(transaction);
        },
        performUpdateIfNecessary: function(transaction) {
          if (this._pendingElement == null) {
            return;
          }
          var prevElement = this._currentElement;
          var nextElement = this._pendingElement;
          this._currentElement = nextElement;
          this.props = nextElement.props;
          this._owner = nextElement._owner;
          this._pendingElement = null;
          this.updateComponent(transaction, prevElement);
        },
        updateComponent: function(transaction, prevElement) {
          var nextElement = this._currentElement;
          if (nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref) {
            if (prevElement.ref != null) {
              ReactOwner.removeComponentAsRefFrom(this, prevElement.ref, prevElement._owner);
            }
            if (nextElement.ref != null) {
              ReactOwner.addComponentAsRefTo(this, nextElement.ref, nextElement._owner);
            }
          }
        },
        mountComponentIntoNode: function(rootID, container, shouldReuseMarkup) {
          var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
          transaction.perform(this._mountComponentIntoNode, this, rootID, container, transaction, shouldReuseMarkup);
          ReactUpdates.ReactReconcileTransaction.release(transaction);
        },
        _mountComponentIntoNode: function(rootID, container, transaction, shouldReuseMarkup) {
          var markup = this.mountComponent(rootID, transaction, 0);
          mountImageIntoNode(markup, container, shouldReuseMarkup);
        },
        isOwnedBy: function(owner) {
          return this._owner === owner;
        },
        getSiblingByRef: function(ref) {
          var owner = this._owner;
          if (!owner || !owner.refs) {
            return null;
          }
          return owner.refs[ref];
        }
      }
    };
    module.exports = ReactComponent;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactCompositeComponent", ["./ReactComponent", "./ReactContext", "./ReactCurrentOwner", "./ReactElement", "./ReactElementValidator", "./ReactEmptyComponent", "./ReactErrorUtils", "./ReactLegacyElement", "./ReactOwner", "./ReactPerf", "./ReactPropTransferer", "./ReactPropTypeLocations", "./ReactPropTypeLocationNames", "./ReactUpdates", "./Object.assign", "./instantiateReactComponent", "./invariant", "./keyMirror", "./keyOf", "./monitorCodeUse", "./mapObject", "./shouldUpdateReactComponent", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactComponent = require("./ReactComponent");
    var ReactContext = require("./ReactContext");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var ReactElement = require("./ReactElement");
    var ReactElementValidator = require("./ReactElementValidator");
    var ReactEmptyComponent = require("./ReactEmptyComponent");
    var ReactErrorUtils = require("./ReactErrorUtils");
    var ReactLegacyElement = require("./ReactLegacyElement");
    var ReactOwner = require("./ReactOwner");
    var ReactPerf = require("./ReactPerf");
    var ReactPropTransferer = require("./ReactPropTransferer");
    var ReactPropTypeLocations = require("./ReactPropTypeLocations");
    var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
    var ReactUpdates = require("./ReactUpdates");
    var assign = require("./Object.assign");
    var instantiateReactComponent = require("./instantiateReactComponent");
    var invariant = require("./invariant");
    var keyMirror = require("./keyMirror");
    var keyOf = require("./keyOf");
    var monitorCodeUse = require("./monitorCodeUse");
    var mapObject = require("./mapObject");
    var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
    var warning = require("./warning");
    var MIXINS_KEY = keyOf({mixins: null});
    var SpecPolicy = keyMirror({
      DEFINE_ONCE: null,
      DEFINE_MANY: null,
      OVERRIDE_BASE: null,
      DEFINE_MANY_MERGED: null
    });
    var injectedMixins = [];
    var ReactCompositeComponentInterface = {
      mixins: SpecPolicy.DEFINE_MANY,
      statics: SpecPolicy.DEFINE_MANY,
      propTypes: SpecPolicy.DEFINE_MANY,
      contextTypes: SpecPolicy.DEFINE_MANY,
      childContextTypes: SpecPolicy.DEFINE_MANY,
      getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
      getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
      getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
      render: SpecPolicy.DEFINE_ONCE,
      componentWillMount: SpecPolicy.DEFINE_MANY,
      componentDidMount: SpecPolicy.DEFINE_MANY,
      componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
      shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
      componentWillUpdate: SpecPolicy.DEFINE_MANY,
      componentDidUpdate: SpecPolicy.DEFINE_MANY,
      componentWillUnmount: SpecPolicy.DEFINE_MANY,
      updateComponent: SpecPolicy.OVERRIDE_BASE
    };
    var RESERVED_SPEC_KEYS = {
      displayName: function(Constructor, displayName) {
        Constructor.displayName = displayName;
      },
      mixins: function(Constructor, mixins) {
        if (mixins) {
          for (var i = 0; i < mixins.length; i++) {
            mixSpecIntoComponent(Constructor, mixins[i]);
          }
        }
      },
      childContextTypes: function(Constructor, childContextTypes) {
        validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
        Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
      },
      contextTypes: function(Constructor, contextTypes) {
        validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
        Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
      },
      getDefaultProps: function(Constructor, getDefaultProps) {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
        } else {
          Constructor.getDefaultProps = getDefaultProps;
        }
      },
      propTypes: function(Constructor, propTypes) {
        validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
        Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
      },
      statics: function(Constructor, statics) {
        mixStaticSpecIntoComponent(Constructor, statics);
      }
    };
    function getDeclarationErrorAddendum(component) {
      var owner = component._owner || null;
      if (owner && owner.constructor && owner.constructor.displayName) {
        return ' Check the render method of `' + owner.constructor.displayName + '`.';
      }
      return '';
    }
    function validateTypeDef(Constructor, typeDef, location) {
      for (var propName in typeDef) {
        if (typeDef.hasOwnProperty(propName)) {
          ("production" !== process.env.NODE_ENV ? invariant(typeof typeDef[propName] == 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactCompositeComponent', ReactPropTypeLocationNames[location], propName) : invariant(typeof typeDef[propName] == 'function'));
        }
      }
    }
    function validateMethodOverride(proto, name) {
      var specPolicy = ReactCompositeComponentInterface.hasOwnProperty(name) ? ReactCompositeComponentInterface[name] : null;
      if (ReactCompositeComponentMixin.hasOwnProperty(name)) {
        ("production" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.OVERRIDE_BASE, 'ReactCompositeComponentInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE));
      }
      if (proto.hasOwnProperty(name)) {
        ("production" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED, 'ReactCompositeComponentInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED));
      }
    }
    function validateLifeCycleOnReplaceState(instance) {
      var compositeLifeCycleState = instance._compositeLifeCycleState;
      ("production" !== process.env.NODE_ENV ? invariant(instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING, 'replaceState(...): Can only update a mounted or mounting component.') : invariant(instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
      ("production" !== process.env.NODE_ENV ? invariant(ReactCurrentOwner.current == null, 'replaceState(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.') : invariant(ReactCurrentOwner.current == null));
      ("production" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING, 'replaceState(...): Cannot update while unmounting component. This ' + 'usually means you called setState() on an unmounted component.') : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING));
    }
    function mixSpecIntoComponent(Constructor, spec) {
      if (!spec) {
        return;
      }
      ("production" !== process.env.NODE_ENV ? invariant(!ReactLegacyElement.isValidFactory(spec), 'ReactCompositeComponent: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(!ReactLegacyElement.isValidFactory(spec)));
      ("production" !== process.env.NODE_ENV ? invariant(!ReactElement.isValidElement(spec), 'ReactCompositeComponent: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(!ReactElement.isValidElement(spec)));
      var proto = Constructor.prototype;
      if (spec.hasOwnProperty(MIXINS_KEY)) {
        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
      }
      for (var name in spec) {
        if (!spec.hasOwnProperty(name)) {
          continue;
        }
        if (name === MIXINS_KEY) {
          continue;
        }
        var property = spec[name];
        validateMethodOverride(proto, name);
        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](Constructor, property);
        } else {
          var isCompositeComponentMethod = ReactCompositeComponentInterface.hasOwnProperty(name);
          var isAlreadyDefined = proto.hasOwnProperty(name);
          var markedDontBind = property && property.__reactDontBind;
          var isFunction = typeof property === 'function';
          var shouldAutoBind = isFunction && !isCompositeComponentMethod && !isAlreadyDefined && !markedDontBind;
          if (shouldAutoBind) {
            if (!proto.__reactAutoBindMap) {
              proto.__reactAutoBindMap = {};
            }
            proto.__reactAutoBindMap[name] = property;
            proto[name] = property;
          } else {
            if (isAlreadyDefined) {
              var specPolicy = ReactCompositeComponentInterface[name];
              ("production" !== process.env.NODE_ENV ? invariant(isCompositeComponentMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY), 'ReactCompositeComponent: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(isCompositeComponentMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)));
              if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;
              if ("production" !== process.env.NODE_ENV) {
                if (typeof property === 'function' && spec.displayName) {
                  proto[name].displayName = spec.displayName + '_' + name;
                }
              }
            }
          }
        }
      }
    }
    function mixStaticSpecIntoComponent(Constructor, statics) {
      if (!statics) {
        return;
      }
      for (var name in statics) {
        var property = statics[name];
        if (!statics.hasOwnProperty(name)) {
          continue;
        }
        var isReserved = name in RESERVED_SPEC_KEYS;
        ("production" !== process.env.NODE_ENV ? invariant(!isReserved, 'ReactCompositeComponent: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(!isReserved));
        var isInherited = name in Constructor;
        ("production" !== process.env.NODE_ENV ? invariant(!isInherited, 'ReactCompositeComponent: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(!isInherited));
        Constructor[name] = property;
      }
    }
    function mergeObjectsWithNoDuplicateKeys(one, two) {
      ("production" !== process.env.NODE_ENV ? invariant(one && two && typeof one === 'object' && typeof two === 'object', 'mergeObjectsWithNoDuplicateKeys(): Cannot merge non-objects') : invariant(one && two && typeof one === 'object' && typeof two === 'object'));
      mapObject(two, function(value, key) {
        ("production" !== process.env.NODE_ENV ? invariant(one[key] === undefined, 'mergeObjectsWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(one[key] === undefined));
        one[key] = value;
      });
      return one;
    }
    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);
        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }
        return mergeObjectsWithNoDuplicateKeys(a, b);
      };
    }
    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }
    var CompositeLifeCycle = keyMirror({
      MOUNTING: null,
      UNMOUNTING: null,
      RECEIVING_PROPS: null
    });
    var ReactCompositeComponentMixin = {
      construct: function(element) {
        ReactComponent.Mixin.construct.apply(this, arguments);
        ReactOwner.Mixin.construct.apply(this, arguments);
        this.state = null;
        this._pendingState = null;
        this.context = null;
        this._compositeLifeCycleState = null;
      },
      isMounted: function() {
        return ReactComponent.Mixin.isMounted.call(this) && this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING;
      },
      mountComponent: ReactPerf.measure('ReactCompositeComponent', 'mountComponent', function(rootID, transaction, mountDepth) {
        ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
        this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING;
        if (this.__reactAutoBindMap) {
          this._bindAutoBindMethods();
        }
        this.context = this._processContext(this._currentElement._context);
        this.props = this._processProps(this.props);
        this.state = this.getInitialState ? this.getInitialState() : null;
        ("production" !== process.env.NODE_ENV ? invariant(typeof this.state === 'object' && !Array.isArray(this.state), '%s.getInitialState(): must return an object or null', this.constructor.displayName || 'ReactCompositeComponent') : invariant(typeof this.state === 'object' && !Array.isArray(this.state)));
        this._pendingState = null;
        this._pendingForceUpdate = false;
        if (this.componentWillMount) {
          this.componentWillMount();
          if (this._pendingState) {
            this.state = this._pendingState;
            this._pendingState = null;
          }
        }
        this._renderedComponent = instantiateReactComponent(this._renderValidatedComponent(), this._currentElement.type);
        this._compositeLifeCycleState = null;
        var markup = this._renderedComponent.mountComponent(rootID, transaction, mountDepth + 1);
        if (this.componentDidMount) {
          transaction.getReactMountReady().enqueue(this.componentDidMount, this);
        }
        return markup;
      }),
      unmountComponent: function() {
        this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING;
        if (this.componentWillUnmount) {
          this.componentWillUnmount();
        }
        this._compositeLifeCycleState = null;
        this._renderedComponent.unmountComponent();
        this._renderedComponent = null;
        ReactComponent.Mixin.unmountComponent.call(this);
      },
      setState: function(partialState, callback) {
        ("production" !== process.env.NODE_ENV ? invariant(typeof partialState === 'object' || partialState == null, 'setState(...): takes an object of state variables to update.') : invariant(typeof partialState === 'object' || partialState == null));
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : null);
        }
        this.replaceState(assign({}, this._pendingState || this.state, partialState), callback);
      },
      replaceState: function(completeState, callback) {
        validateLifeCycleOnReplaceState(this);
        this._pendingState = completeState;
        if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) {
          ReactUpdates.enqueueUpdate(this, callback);
        }
      },
      _processContext: function(context) {
        var maskedContext = null;
        var contextTypes = this.constructor.contextTypes;
        if (contextTypes) {
          maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          if ("production" !== process.env.NODE_ENV) {
            this._checkPropTypes(contextTypes, maskedContext, ReactPropTypeLocations.context);
          }
        }
        return maskedContext;
      },
      _processChildContext: function(currentContext) {
        var childContext = this.getChildContext && this.getChildContext();
        var displayName = this.constructor.displayName || 'ReactCompositeComponent';
        if (childContext) {
          ("production" !== process.env.NODE_ENV ? invariant(typeof this.constructor.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', displayName) : invariant(typeof this.constructor.childContextTypes === 'object'));
          if ("production" !== process.env.NODE_ENV) {
            this._checkPropTypes(this.constructor.childContextTypes, childContext, ReactPropTypeLocations.childContext);
          }
          for (var name in childContext) {
            ("production" !== process.env.NODE_ENV ? invariant(name in this.constructor.childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', displayName, name) : invariant(name in this.constructor.childContextTypes));
          }
          return assign({}, currentContext, childContext);
        }
        return currentContext;
      },
      _processProps: function(newProps) {
        if ("production" !== process.env.NODE_ENV) {
          var propTypes = this.constructor.propTypes;
          if (propTypes) {
            this._checkPropTypes(propTypes, newProps, ReactPropTypeLocations.prop);
          }
        }
        return newProps;
      },
      _checkPropTypes: function(propTypes, props, location) {
        var componentName = this.constructor.displayName;
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            var error = propTypes[propName](props, propName, componentName, location);
            if (error instanceof Error) {
              var addendum = getDeclarationErrorAddendum(this);
              ("production" !== process.env.NODE_ENV ? warning(false, error.message + addendum) : null);
            }
          }
        }
      },
      performUpdateIfNecessary: function(transaction) {
        var compositeLifeCycleState = this._compositeLifeCycleState;
        if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING || compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) {
          return;
        }
        if (this._pendingElement == null && this._pendingState == null && !this._pendingForceUpdate) {
          return;
        }
        var nextContext = this.context;
        var nextProps = this.props;
        var nextElement = this._currentElement;
        if (this._pendingElement != null) {
          nextElement = this._pendingElement;
          nextContext = this._processContext(nextElement._context);
          nextProps = this._processProps(nextElement.props);
          this._pendingElement = null;
          this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS;
          if (this.componentWillReceiveProps) {
            this.componentWillReceiveProps(nextProps, nextContext);
          }
        }
        this._compositeLifeCycleState = null;
        var nextState = this._pendingState || this.state;
        this._pendingState = null;
        var shouldUpdate = this._pendingForceUpdate || !this.shouldComponentUpdate || this.shouldComponentUpdate(nextProps, nextState, nextContext);
        if ("production" !== process.env.NODE_ENV) {
          if (typeof shouldUpdate === "undefined") {
            console.warn((this.constructor.displayName || 'ReactCompositeComponent') + '.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.');
          }
        }
        if (shouldUpdate) {
          this._pendingForceUpdate = false;
          this._performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction);
        } else {
          this._currentElement = nextElement;
          this.props = nextProps;
          this.state = nextState;
          this.context = nextContext;
          this._owner = nextElement._owner;
        }
      },
      _performComponentUpdate: function(nextElement, nextProps, nextState, nextContext, transaction) {
        var prevElement = this._currentElement;
        var prevProps = this.props;
        var prevState = this.state;
        var prevContext = this.context;
        if (this.componentWillUpdate) {
          this.componentWillUpdate(nextProps, nextState, nextContext);
        }
        this._currentElement = nextElement;
        this.props = nextProps;
        this.state = nextState;
        this.context = nextContext;
        this._owner = nextElement._owner;
        this.updateComponent(transaction, prevElement);
        if (this.componentDidUpdate) {
          transaction.getReactMountReady().enqueue(this.componentDidUpdate.bind(this, prevProps, prevState, prevContext), this);
        }
      },
      receiveComponent: function(nextElement, transaction) {
        if (nextElement === this._currentElement && nextElement._owner != null) {
          return;
        }
        ReactComponent.Mixin.receiveComponent.call(this, nextElement, transaction);
      },
      updateComponent: ReactPerf.measure('ReactCompositeComponent', 'updateComponent', function(transaction, prevParentElement) {
        ReactComponent.Mixin.updateComponent.call(this, transaction, prevParentElement);
        var prevComponentInstance = this._renderedComponent;
        var prevElement = prevComponentInstance._currentElement;
        var nextElement = this._renderValidatedComponent();
        if (shouldUpdateReactComponent(prevElement, nextElement)) {
          prevComponentInstance.receiveComponent(nextElement, transaction);
        } else {
          var thisID = this._rootNodeID;
          var prevComponentID = prevComponentInstance._rootNodeID;
          prevComponentInstance.unmountComponent();
          this._renderedComponent = instantiateReactComponent(nextElement, this._currentElement.type);
          var nextMarkup = this._renderedComponent.mountComponent(thisID, transaction, this._mountDepth + 1);
          ReactComponent.BackendIDOperations.dangerouslyReplaceNodeWithMarkupByID(prevComponentID, nextMarkup);
        }
      }),
      forceUpdate: function(callback) {
        var compositeLifeCycleState = this._compositeLifeCycleState;
        ("production" !== process.env.NODE_ENV ? invariant(this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING, 'forceUpdate(...): Can only force an update on mounted or mounting ' + 'components.') : invariant(this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
        ("production" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING && ReactCurrentOwner.current == null, 'forceUpdate(...): Cannot force an update while unmounting component ' + 'or within a `render` function.') : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING && ReactCurrentOwner.current == null));
        this._pendingForceUpdate = true;
        ReactUpdates.enqueueUpdate(this, callback);
      },
      _renderValidatedComponent: ReactPerf.measure('ReactCompositeComponent', '_renderValidatedComponent', function() {
        var renderedComponent;
        var previousContext = ReactContext.current;
        ReactContext.current = this._processChildContext(this._currentElement._context);
        ReactCurrentOwner.current = this;
        try {
          renderedComponent = this.render();
          if (renderedComponent === null || renderedComponent === false) {
            renderedComponent = ReactEmptyComponent.getEmptyComponent();
            ReactEmptyComponent.registerNullComponentID(this._rootNodeID);
          } else {
            ReactEmptyComponent.deregisterNullComponentID(this._rootNodeID);
          }
        } finally {
          ReactContext.current = previousContext;
          ReactCurrentOwner.current = null;
        }
        ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(renderedComponent), '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.constructor.displayName || 'ReactCompositeComponent') : invariant(ReactElement.isValidElement(renderedComponent)));
        return renderedComponent;
      }),
      _bindAutoBindMethods: function() {
        for (var autoBindKey in this.__reactAutoBindMap) {
          if (!this.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
            continue;
          }
          var method = this.__reactAutoBindMap[autoBindKey];
          this[autoBindKey] = this._bindAutoBindMethod(ReactErrorUtils.guard(method, this.constructor.displayName + '.' + autoBindKey));
        }
      },
      _bindAutoBindMethod: function(method) {
        var component = this;
        var boundMethod = method.bind(component);
        if ("production" !== process.env.NODE_ENV) {
          boundMethod.__reactBoundContext = component;
          boundMethod.__reactBoundMethod = method;
          boundMethod.__reactBoundArguments = null;
          var componentName = component.constructor.displayName;
          var _bind = boundMethod.bind;
          boundMethod.bind = function(newThis) {
            for (var args = [],
                $__0 = 1,
                $__1 = arguments.length; $__0 < $__1; $__0++)
              args.push(arguments[$__0]);
            if (newThis !== component && newThis !== null) {
              monitorCodeUse('react_bind_warning', {component: componentName});
              console.warn('bind(): React component methods may only be bound to the ' + 'component instance. See ' + componentName);
            } else if (!args.length) {
              monitorCodeUse('react_bind_warning', {component: componentName});
              console.warn('bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See ' + componentName);
              return boundMethod;
            }
            var reboundMethod = _bind.apply(boundMethod, arguments);
            reboundMethod.__reactBoundContext = component;
            reboundMethod.__reactBoundMethod = method;
            reboundMethod.__reactBoundArguments = args;
            return reboundMethod;
          };
        }
        return boundMethod;
      }
    };
    var ReactCompositeComponentBase = function() {};
    assign(ReactCompositeComponentBase.prototype, ReactComponent.Mixin, ReactOwner.Mixin, ReactPropTransferer.Mixin, ReactCompositeComponentMixin);
    var ReactCompositeComponent = {
      LifeCycle: CompositeLifeCycle,
      Base: ReactCompositeComponentBase,
      createClass: function(spec) {
        var Constructor = function(props) {};
        Constructor.prototype = new ReactCompositeComponentBase();
        Constructor.prototype.constructor = Constructor;
        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
        mixSpecIntoComponent(Constructor, spec);
        if (Constructor.getDefaultProps) {
          Constructor.defaultProps = Constructor.getDefaultProps();
        }
        ("production" !== process.env.NODE_ENV ? invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.') : invariant(Constructor.prototype.render));
        if ("production" !== process.env.NODE_ENV) {
          if (Constructor.prototype.componentShouldUpdate) {
            monitorCodeUse('react_component_should_update_warning', {component: spec.displayName});
            console.warn((spec.displayName || 'A component') + ' has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.');
          }
        }
        for (var methodName in ReactCompositeComponentInterface) {
          if (!Constructor.prototype[methodName]) {
            Constructor.prototype[methodName] = null;
          }
        }
        if ("production" !== process.env.NODE_ENV) {
          return ReactLegacyElement.wrapFactory(ReactElementValidator.createFactory(Constructor));
        }
        return ReactLegacyElement.wrapFactory(ReactElement.createFactory(Constructor));
      },
      injection: {injectMixin: function(mixin) {
          injectedMixins.push(mixin);
        }}
    };
    module.exports = ReactCompositeComponent;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CSSPropertyOperations", ["./CSSProperty", "./ExecutionEnvironment", "./camelizeStyleName", "./dangerousStyleValue", "./hyphenateStyleName", "./memoizeStringOnly", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CSSProperty = require("./CSSProperty");
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var camelizeStyleName = require("./camelizeStyleName");
    var dangerousStyleValue = require("./dangerousStyleValue");
    var hyphenateStyleName = require("./hyphenateStyleName");
    var memoizeStringOnly = require("./memoizeStringOnly");
    var warning = require("./warning");
    var processStyleName = memoizeStringOnly(function(styleName) {
      return hyphenateStyleName(styleName);
    });
    var styleFloatAccessor = 'cssFloat';
    if (ExecutionEnvironment.canUseDOM) {
      if (document.documentElement.style.cssFloat === undefined) {
        styleFloatAccessor = 'styleFloat';
      }
    }
    if ("production" !== process.env.NODE_ENV) {
      var warnedStyleNames = {};
      var warnHyphenatedStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return;
        }
        warnedStyleNames[name] = true;
        ("production" !== process.env.NODE_ENV ? warning(false, 'Unsupported style property ' + name + '. Did you mean ' + camelizeStyleName(name) + '?') : null);
      };
    }
    var CSSPropertyOperations = {
      createMarkupForStyles: function(styles) {
        var serialized = '';
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          if ("production" !== process.env.NODE_ENV) {
            if (styleName.indexOf('-') > -1) {
              warnHyphenatedStyleName(styleName);
            }
          }
          var styleValue = styles[styleName];
          if (styleValue != null) {
            serialized += processStyleName(styleName) + ':';
            serialized += dangerousStyleValue(styleName, styleValue) + ';';
          }
        }
        return serialized || null;
      },
      setValueForStyles: function(node, styles) {
        var style = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          if ("production" !== process.env.NODE_ENV) {
            if (styleName.indexOf('-') > -1) {
              warnHyphenatedStyleName(styleName);
            }
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName]);
          if (styleName === 'float') {
            styleName = styleFloatAccessor;
          }
          if (styleValue) {
            style[styleName] = styleValue;
          } else {
            var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
            if (expansion) {
              for (var individualStyleName in expansion) {
                style[individualStyleName] = '';
              }
            } else {
              style[styleName] = '';
            }
          }
        }
      }
    };
    module.exports = CSSPropertyOperations;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactBrowserEventEmitter", ["./EventConstants", "./EventPluginHub", "./EventPluginRegistry", "./ReactEventEmitterMixin", "./ViewportMetrics", "./Object.assign", "./isEventSupported", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPluginHub = require("./EventPluginHub");
    var EventPluginRegistry = require("./EventPluginRegistry");
    var ReactEventEmitterMixin = require("./ReactEventEmitterMixin");
    var ViewportMetrics = require("./ViewportMetrics");
    var assign = require("./Object.assign");
    var isEventSupported = require("./isEventSupported");
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {
      topBlur: 'blur',
      topChange: 'change',
      topClick: 'click',
      topCompositionEnd: 'compositionend',
      topCompositionStart: 'compositionstart',
      topCompositionUpdate: 'compositionupdate',
      topContextMenu: 'contextmenu',
      topCopy: 'copy',
      topCut: 'cut',
      topDoubleClick: 'dblclick',
      topDrag: 'drag',
      topDragEnd: 'dragend',
      topDragEnter: 'dragenter',
      topDragExit: 'dragexit',
      topDragLeave: 'dragleave',
      topDragOver: 'dragover',
      topDragStart: 'dragstart',
      topDrop: 'drop',
      topFocus: 'focus',
      topInput: 'input',
      topKeyDown: 'keydown',
      topKeyPress: 'keypress',
      topKeyUp: 'keyup',
      topMouseDown: 'mousedown',
      topMouseMove: 'mousemove',
      topMouseOut: 'mouseout',
      topMouseOver: 'mouseover',
      topMouseUp: 'mouseup',
      topPaste: 'paste',
      topScroll: 'scroll',
      topSelectionChange: 'selectionchange',
      topTextInput: 'textInput',
      topTouchCancel: 'touchcancel',
      topTouchEnd: 'touchend',
      topTouchMove: 'touchmove',
      topTouchStart: 'touchstart',
      topWheel: 'wheel'
    };
    var topListenersIDKey = "_reactListenersID" + String(Math.random()).slice(2);
    function getListeningForDocument(mountAt) {
      if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
        mountAt[topListenersIDKey] = reactTopListenersCounter++;
        alreadyListeningTo[mountAt[topListenersIDKey]] = {};
      }
      return alreadyListeningTo[mountAt[topListenersIDKey]];
    }
    var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
      ReactEventListener: null,
      injection: {injectReactEventListener: function(ReactEventListener) {
          ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
          ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
        }},
      setEnabled: function(enabled) {
        if (ReactBrowserEventEmitter.ReactEventListener) {
          ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
        }
      },
      isEnabled: function() {
        return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
      },
      listenTo: function(registrationName, contentDocumentHandle) {
        var mountAt = contentDocumentHandle;
        var isListening = getListeningForDocument(mountAt);
        var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
        var topLevelTypes = EventConstants.topLevelTypes;
        for (var i = 0,
            l = dependencies.length; i < l; i++) {
          var dependency = dependencies[i];
          if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
            if (dependency === topLevelTypes.topWheel) {
              if (isEventSupported('wheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
              } else if (isEventSupported('mousewheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
              }
            } else if (dependency === topLevelTypes.topScroll) {
              if (isEventSupported('scroll', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
              }
            } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
              if (isEventSupported('focus', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
              } else if (isEventSupported('focusin')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
              }
              isListening[topLevelTypes.topBlur] = true;
              isListening[topLevelTypes.topFocus] = true;
            } else if (topEventMapping.hasOwnProperty(dependency)) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
            }
            isListening[dependency] = true;
          }
        }
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
      },
      ensureScrollValueMonitoring: function() {
        if (!isMonitoringScrollValue) {
          var refresh = ViewportMetrics.refreshScrollValues;
          ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
          isMonitoringScrollValue = true;
        }
      },
      eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
      registrationNameModules: EventPluginHub.registrationNameModules,
      putListener: EventPluginHub.putListener,
      getListener: EventPluginHub.getListener,
      deleteListener: EventPluginHub.deleteListener,
      deleteAllListeners: EventPluginHub.deleteAllListeners
    });
    module.exports = ReactBrowserEventEmitter;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/containsNode", ["./isTextNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var isTextNode = require("./isTextNode");
  function containsNode(outerNode, innerNode) {
    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      return containsNode(outerNode, innerNode.parentNode);
    } else if (outerNode.contains) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
  module.exports = containsNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMultiChild", ["./ReactComponent", "./ReactMultiChildUpdateTypes", "./flattenChildren", "./instantiateReactComponent", "./shouldUpdateReactComponent", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactComponent = require("./ReactComponent");
    var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");
    var flattenChildren = require("./flattenChildren");
    var instantiateReactComponent = require("./instantiateReactComponent");
    var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
    var updateDepth = 0;
    var updateQueue = [];
    var markupQueue = [];
    function enqueueMarkup(parentID, markup, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
        markupIndex: markupQueue.push(markup) - 1,
        textContent: null,
        fromIndex: null,
        toIndex: toIndex
      });
    }
    function enqueueMove(parentID, fromIndex, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
        markupIndex: null,
        textContent: null,
        fromIndex: fromIndex,
        toIndex: toIndex
      });
    }
    function enqueueRemove(parentID, fromIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.REMOVE_NODE,
        markupIndex: null,
        textContent: null,
        fromIndex: fromIndex,
        toIndex: null
      });
    }
    function enqueueTextContent(parentID, textContent) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
        markupIndex: null,
        textContent: textContent,
        fromIndex: null,
        toIndex: null
      });
    }
    function processQueue() {
      if (updateQueue.length) {
        ReactComponent.BackendIDOperations.dangerouslyProcessChildrenUpdates(updateQueue, markupQueue);
        clearQueue();
      }
    }
    function clearQueue() {
      updateQueue.length = 0;
      markupQueue.length = 0;
    }
    var ReactMultiChild = {Mixin: {
        mountChildren: function(nestedChildren, transaction) {
          var children = flattenChildren(nestedChildren);
          var mountImages = [];
          var index = 0;
          this._renderedChildren = children;
          for (var name in children) {
            var child = children[name];
            if (children.hasOwnProperty(name)) {
              var childInstance = instantiateReactComponent(child, null);
              children[name] = childInstance;
              var rootID = this._rootNodeID + name;
              var mountImage = childInstance.mountComponent(rootID, transaction, this._mountDepth + 1);
              childInstance._mountIndex = index;
              mountImages.push(mountImage);
              index++;
            }
          }
          return mountImages;
        },
        updateTextContent: function(nextContent) {
          updateDepth++;
          var errorThrown = true;
          try {
            var prevChildren = this._renderedChildren;
            for (var name in prevChildren) {
              if (prevChildren.hasOwnProperty(name)) {
                this._unmountChildByName(prevChildren[name], name);
              }
            }
            this.setTextContent(nextContent);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              errorThrown ? clearQueue() : processQueue();
            }
          }
        },
        updateChildren: function(nextNestedChildren, transaction) {
          updateDepth++;
          var errorThrown = true;
          try {
            this._updateChildren(nextNestedChildren, transaction);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              errorThrown ? clearQueue() : processQueue();
            }
          }
        },
        _updateChildren: function(nextNestedChildren, transaction) {
          var nextChildren = flattenChildren(nextNestedChildren);
          var prevChildren = this._renderedChildren;
          if (!nextChildren && !prevChildren) {
            return;
          }
          var name;
          var lastIndex = 0;
          var nextIndex = 0;
          for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
              continue;
            }
            var prevChild = prevChildren && prevChildren[name];
            var prevElement = prevChild && prevChild._currentElement;
            var nextElement = nextChildren[name];
            if (shouldUpdateReactComponent(prevElement, nextElement)) {
              this.moveChild(prevChild, nextIndex, lastIndex);
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              prevChild.receiveComponent(nextElement, transaction);
              prevChild._mountIndex = nextIndex;
            } else {
              if (prevChild) {
                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                this._unmountChildByName(prevChild, name);
              }
              var nextChildInstance = instantiateReactComponent(nextElement, null);
              this._mountChildByNameAtIndex(nextChildInstance, name, nextIndex, transaction);
            }
            nextIndex++;
          }
          for (name in prevChildren) {
            if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren[name])) {
              this._unmountChildByName(prevChildren[name], name);
            }
          }
        },
        unmountChildren: function() {
          var renderedChildren = this._renderedChildren;
          for (var name in renderedChildren) {
            var renderedChild = renderedChildren[name];
            if (renderedChild.unmountComponent) {
              renderedChild.unmountComponent();
            }
          }
          this._renderedChildren = null;
        },
        moveChild: function(child, toIndex, lastIndex) {
          if (child._mountIndex < lastIndex) {
            enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
          }
        },
        createChild: function(child, mountImage) {
          enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
        },
        removeChild: function(child) {
          enqueueRemove(this._rootNodeID, child._mountIndex);
        },
        setTextContent: function(textContent) {
          enqueueTextContent(this._rootNodeID, textContent);
        },
        _mountChildByNameAtIndex: function(child, name, index, transaction) {
          var rootID = this._rootNodeID + name;
          var mountImage = child.mountComponent(rootID, transaction, this._mountDepth + 1);
          child._mountIndex = index;
          this.createChild(child, mountImage);
          this._renderedChildren = this._renderedChildren || {};
          this._renderedChildren[name] = child;
        },
        _unmountChildByName: function(child, name) {
          this.removeChild(child);
          child._mountIndex = null;
          child.unmountComponent();
          delete this._renderedChildren[name];
        }
      }};
    module.exports = ReactMultiChild;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticInputEvent", ["./SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("./SyntheticEvent");
  var InputEventInterface = {data: null};
  function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
  module.exports = SyntheticInputEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactInputSelection", ["./ReactDOMSelection", "./containsNode", "./focusNode", "./getActiveElement"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactDOMSelection = require("./ReactDOMSelection");
  var containsNode = require("./containsNode");
  var focusNode = require("./focusNode");
  var getActiveElement = require("./getActiveElement");
  function isInDocument(node) {
    return containsNode(document.documentElement, node);
  }
  var ReactInputSelection = {
    hasSelectionCapabilities: function(elem) {
      return elem && ((elem.nodeName === 'INPUT' && elem.type === 'text') || elem.nodeName === 'TEXTAREA' || elem.contentEditable === 'true');
    },
    getSelectionInformation: function() {
      var focusedElem = getActiveElement();
      return {
        focusedElem: focusedElem,
        selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
      };
    },
    restoreSelection: function(priorSelectionInformation) {
      var curFocusedElem = getActiveElement();
      var priorFocusedElem = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
        if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
          ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
        }
        focusNode(priorFocusedElem);
      }
    },
    getSelection: function(input) {
      var selection;
      if ('selectionStart' in input) {
        selection = {
          start: input.selectionStart,
          end: input.selectionEnd
        };
      } else if (document.selection && input.nodeName === 'INPUT') {
        var range = document.selection.createRange();
        if (range.parentElement() === input) {
          selection = {
            start: -range.moveStart('character', -input.value.length),
            end: -range.moveEnd('character', -input.value.length)
          };
        }
      } else {
        selection = ReactDOMSelection.getOffsets(input);
      }
      return selection || {
        start: 0,
        end: 0
      };
    },
    setSelection: function(input, offsets) {
      var start = offsets.start;
      var end = offsets.end;
      if (typeof end === 'undefined') {
        end = start;
      }
      if ('selectionStart' in input) {
        input.selectionStart = start;
        input.selectionEnd = Math.min(end, input.value.length);
      } else if (document.selection && input.nodeName === 'INPUT') {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart('character', start);
        range.moveEnd('character', end - start);
        range.select();
      } else {
        ReactDOMSelection.setOffsets(input, offsets);
      }
    }
  };
  module.exports = ReactInputSelection;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EnterLeaveEventPlugin", ["./EventConstants", "./EventPropagators", "./SyntheticMouseEvent", "./ReactMount", "./keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("./EventConstants");
  var EventPropagators = require("./EventPropagators");
  var SyntheticMouseEvent = require("./SyntheticMouseEvent");
  var ReactMount = require("./ReactMount");
  var keyOf = require("./keyOf");
  var topLevelTypes = EventConstants.topLevelTypes;
  var getFirstReactDOM = ReactMount.getFirstReactDOM;
  var eventTypes = {
    mouseEnter: {
      registrationName: keyOf({onMouseEnter: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    },
    mouseLeave: {
      registrationName: keyOf({onMouseLeave: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    }
  };
  var extractedEvents = [null, null];
  var EnterLeaveEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
        return null;
      }
      if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
        return null;
      }
      var win;
      if (topLevelTarget.window === topLevelTarget) {
        win = topLevelTarget;
      } else {
        var doc = topLevelTarget.ownerDocument;
        if (doc) {
          win = doc.defaultView || doc.parentWindow;
        } else {
          win = window;
        }
      }
      var from,
          to;
      if (topLevelType === topLevelTypes.topMouseOut) {
        from = topLevelTarget;
        to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) || win;
      } else {
        from = win;
        to = topLevelTarget;
      }
      if (from === to) {
        return null;
      }
      var fromID = from ? ReactMount.getID(from) : '';
      var toID = to ? ReactMount.getID(to) : '';
      var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent);
      leave.type = 'mouseleave';
      leave.target = from;
      leave.relatedTarget = to;
      var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent);
      enter.type = 'mouseenter';
      enter.target = to;
      enter.relatedTarget = from;
      EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
      extractedEvents[0] = leave;
      extractedEvents[1] = enter;
      return extractedEvents;
    }
  };
  module.exports = EnterLeaveEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/createNodesFromMarkup", ["./ExecutionEnvironment", "./createArrayFrom", "./getMarkupWrap", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var createArrayFrom = require("./createArrayFrom");
    var getMarkupWrap = require("./getMarkupWrap");
    var invariant = require("./invariant");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var nodeNamePattern = /^\s*<(\w+)/;
    function getNodeName(markup) {
      var nodeNameMatch = markup.match(nodeNamePattern);
      return nodeNameMatch && nodeNameMatch[1].toLowerCase();
    }
    function createNodesFromMarkup(markup, handleScript) {
      var node = dummyNode;
      ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'createNodesFromMarkup dummy not initialized') : invariant(!!dummyNode));
      var nodeName = getNodeName(markup);
      var wrap = nodeName && getMarkupWrap(nodeName);
      if (wrap) {
        node.innerHTML = wrap[1] + markup + wrap[2];
        var wrapDepth = wrap[0];
        while (wrapDepth--) {
          node = node.lastChild;
        }
      } else {
        node.innerHTML = markup;
      }
      var scripts = node.getElementsByTagName('script');
      if (scripts.length) {
        ("production" !== process.env.NODE_ENV ? invariant(handleScript, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(handleScript));
        createArrayFrom(scripts).forEach(handleScript);
      }
      var nodes = createArrayFrom(node.childNodes);
      while (node.lastChild) {
        node.removeChild(node.lastChild);
      }
      return nodes;
    }
    module.exports = createNodesFromMarkup;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMInput", ["./AutoFocusMixin", "./DOMPropertyOperations", "./LinkedValueUtils", "./ReactBrowserComponentMixin", "./ReactCompositeComponent", "./ReactElement", "./ReactDOM", "./ReactMount", "./ReactUpdates", "./Object.assign", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var AutoFocusMixin = require("./AutoFocusMixin");
    var DOMPropertyOperations = require("./DOMPropertyOperations");
    var LinkedValueUtils = require("./LinkedValueUtils");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var ReactDOM = require("./ReactDOM");
    var ReactMount = require("./ReactMount");
    var ReactUpdates = require("./ReactUpdates");
    var assign = require("./Object.assign");
    var invariant = require("./invariant");
    var input = ReactElement.createFactory(ReactDOM.input.type);
    var instancesByReactID = {};
    function forceUpdateIfMounted() {
      if (this.isMounted()) {
        this.forceUpdate();
      }
    }
    var ReactDOMInput = ReactCompositeComponent.createClass({
      displayName: 'ReactDOMInput',
      mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
      getInitialState: function() {
        var defaultValue = this.props.defaultValue;
        return {
          initialChecked: this.props.defaultChecked || false,
          initialValue: defaultValue != null ? defaultValue : null
        };
      },
      render: function() {
        var props = assign({}, this.props);
        props.defaultChecked = null;
        props.defaultValue = null;
        var value = LinkedValueUtils.getValue(this);
        props.value = value != null ? value : this.state.initialValue;
        var checked = LinkedValueUtils.getChecked(this);
        props.checked = checked != null ? checked : this.state.initialChecked;
        props.onChange = this._handleChange;
        return input(props, this.props.children);
      },
      componentDidMount: function() {
        var id = ReactMount.getID(this.getDOMNode());
        instancesByReactID[id] = this;
      },
      componentWillUnmount: function() {
        var rootNode = this.getDOMNode();
        var id = ReactMount.getID(rootNode);
        delete instancesByReactID[id];
      },
      componentDidUpdate: function(prevProps, prevState, prevContext) {
        var rootNode = this.getDOMNode();
        if (this.props.checked != null) {
          DOMPropertyOperations.setValueForProperty(rootNode, 'checked', this.props.checked || false);
        }
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
          DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
        }
      },
      _handleChange: function(event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
          returnValue = onChange.call(this, event);
        }
        ReactUpdates.asap(forceUpdateIfMounted, this);
        var name = this.props.name;
        if (this.props.type === 'radio' && name != null) {
          var rootNode = this.getDOMNode();
          var queryRoot = rootNode;
          while (queryRoot.parentNode) {
            queryRoot = queryRoot.parentNode;
          }
          var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
          for (var i = 0,
              groupLen = group.length; i < groupLen; i++) {
            var otherNode = group[i];
            if (otherNode === rootNode || otherNode.form !== rootNode.form) {
              continue;
            }
            var otherID = ReactMount.getID(otherNode);
            ("production" !== process.env.NODE_ENV ? invariant(otherID, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(otherID));
            var otherInstance = instancesByReactID[otherID];
            ("production" !== process.env.NODE_ENV ? invariant(otherInstance, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(otherInstance));
            ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
          }
        }
        return returnValue;
      }
    });
    module.exports = ReactDOMInput;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SimpleEventPlugin", ["./EventConstants", "./EventPluginUtils", "./EventPropagators", "./SyntheticClipboardEvent", "./SyntheticEvent", "./SyntheticFocusEvent", "./SyntheticKeyboardEvent", "./SyntheticMouseEvent", "./SyntheticDragEvent", "./SyntheticTouchEvent", "./SyntheticUIEvent", "./SyntheticWheelEvent", "./getEventCharCode", "./invariant", "./keyOf", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPluginUtils = require("./EventPluginUtils");
    var EventPropagators = require("./EventPropagators");
    var SyntheticClipboardEvent = require("./SyntheticClipboardEvent");
    var SyntheticEvent = require("./SyntheticEvent");
    var SyntheticFocusEvent = require("./SyntheticFocusEvent");
    var SyntheticKeyboardEvent = require("./SyntheticKeyboardEvent");
    var SyntheticMouseEvent = require("./SyntheticMouseEvent");
    var SyntheticDragEvent = require("./SyntheticDragEvent");
    var SyntheticTouchEvent = require("./SyntheticTouchEvent");
    var SyntheticUIEvent = require("./SyntheticUIEvent");
    var SyntheticWheelEvent = require("./SyntheticWheelEvent");
    var getEventCharCode = require("./getEventCharCode");
    var invariant = require("./invariant");
    var keyOf = require("./keyOf");
    var warning = require("./warning");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {
      blur: {phasedRegistrationNames: {
          bubbled: keyOf({onBlur: true}),
          captured: keyOf({onBlurCapture: true})
        }},
      click: {phasedRegistrationNames: {
          bubbled: keyOf({onClick: true}),
          captured: keyOf({onClickCapture: true})
        }},
      contextMenu: {phasedRegistrationNames: {
          bubbled: keyOf({onContextMenu: true}),
          captured: keyOf({onContextMenuCapture: true})
        }},
      copy: {phasedRegistrationNames: {
          bubbled: keyOf({onCopy: true}),
          captured: keyOf({onCopyCapture: true})
        }},
      cut: {phasedRegistrationNames: {
          bubbled: keyOf({onCut: true}),
          captured: keyOf({onCutCapture: true})
        }},
      doubleClick: {phasedRegistrationNames: {
          bubbled: keyOf({onDoubleClick: true}),
          captured: keyOf({onDoubleClickCapture: true})
        }},
      drag: {phasedRegistrationNames: {
          bubbled: keyOf({onDrag: true}),
          captured: keyOf({onDragCapture: true})
        }},
      dragEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnd: true}),
          captured: keyOf({onDragEndCapture: true})
        }},
      dragEnter: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnter: true}),
          captured: keyOf({onDragEnterCapture: true})
        }},
      dragExit: {phasedRegistrationNames: {
          bubbled: keyOf({onDragExit: true}),
          captured: keyOf({onDragExitCapture: true})
        }},
      dragLeave: {phasedRegistrationNames: {
          bubbled: keyOf({onDragLeave: true}),
          captured: keyOf({onDragLeaveCapture: true})
        }},
      dragOver: {phasedRegistrationNames: {
          bubbled: keyOf({onDragOver: true}),
          captured: keyOf({onDragOverCapture: true})
        }},
      dragStart: {phasedRegistrationNames: {
          bubbled: keyOf({onDragStart: true}),
          captured: keyOf({onDragStartCapture: true})
        }},
      drop: {phasedRegistrationNames: {
          bubbled: keyOf({onDrop: true}),
          captured: keyOf({onDropCapture: true})
        }},
      focus: {phasedRegistrationNames: {
          bubbled: keyOf({onFocus: true}),
          captured: keyOf({onFocusCapture: true})
        }},
      input: {phasedRegistrationNames: {
          bubbled: keyOf({onInput: true}),
          captured: keyOf({onInputCapture: true})
        }},
      keyDown: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyDown: true}),
          captured: keyOf({onKeyDownCapture: true})
        }},
      keyPress: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyPress: true}),
          captured: keyOf({onKeyPressCapture: true})
        }},
      keyUp: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyUp: true}),
          captured: keyOf({onKeyUpCapture: true})
        }},
      load: {phasedRegistrationNames: {
          bubbled: keyOf({onLoad: true}),
          captured: keyOf({onLoadCapture: true})
        }},
      error: {phasedRegistrationNames: {
          bubbled: keyOf({onError: true}),
          captured: keyOf({onErrorCapture: true})
        }},
      mouseDown: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseDown: true}),
          captured: keyOf({onMouseDownCapture: true})
        }},
      mouseMove: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseMove: true}),
          captured: keyOf({onMouseMoveCapture: true})
        }},
      mouseOut: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOut: true}),
          captured: keyOf({onMouseOutCapture: true})
        }},
      mouseOver: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOver: true}),
          captured: keyOf({onMouseOverCapture: true})
        }},
      mouseUp: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseUp: true}),
          captured: keyOf({onMouseUpCapture: true})
        }},
      paste: {phasedRegistrationNames: {
          bubbled: keyOf({onPaste: true}),
          captured: keyOf({onPasteCapture: true})
        }},
      reset: {phasedRegistrationNames: {
          bubbled: keyOf({onReset: true}),
          captured: keyOf({onResetCapture: true})
        }},
      scroll: {phasedRegistrationNames: {
          bubbled: keyOf({onScroll: true}),
          captured: keyOf({onScrollCapture: true})
        }},
      submit: {phasedRegistrationNames: {
          bubbled: keyOf({onSubmit: true}),
          captured: keyOf({onSubmitCapture: true})
        }},
      touchCancel: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchCancel: true}),
          captured: keyOf({onTouchCancelCapture: true})
        }},
      touchEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchEnd: true}),
          captured: keyOf({onTouchEndCapture: true})
        }},
      touchMove: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchMove: true}),
          captured: keyOf({onTouchMoveCapture: true})
        }},
      touchStart: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchStart: true}),
          captured: keyOf({onTouchStartCapture: true})
        }},
      wheel: {phasedRegistrationNames: {
          bubbled: keyOf({onWheel: true}),
          captured: keyOf({onWheelCapture: true})
        }}
    };
    var topLevelEventsToDispatchConfig = {
      topBlur: eventTypes.blur,
      topClick: eventTypes.click,
      topContextMenu: eventTypes.contextMenu,
      topCopy: eventTypes.copy,
      topCut: eventTypes.cut,
      topDoubleClick: eventTypes.doubleClick,
      topDrag: eventTypes.drag,
      topDragEnd: eventTypes.dragEnd,
      topDragEnter: eventTypes.dragEnter,
      topDragExit: eventTypes.dragExit,
      topDragLeave: eventTypes.dragLeave,
      topDragOver: eventTypes.dragOver,
      topDragStart: eventTypes.dragStart,
      topDrop: eventTypes.drop,
      topError: eventTypes.error,
      topFocus: eventTypes.focus,
      topInput: eventTypes.input,
      topKeyDown: eventTypes.keyDown,
      topKeyPress: eventTypes.keyPress,
      topKeyUp: eventTypes.keyUp,
      topLoad: eventTypes.load,
      topMouseDown: eventTypes.mouseDown,
      topMouseMove: eventTypes.mouseMove,
      topMouseOut: eventTypes.mouseOut,
      topMouseOver: eventTypes.mouseOver,
      topMouseUp: eventTypes.mouseUp,
      topPaste: eventTypes.paste,
      topReset: eventTypes.reset,
      topScroll: eventTypes.scroll,
      topSubmit: eventTypes.submit,
      topTouchCancel: eventTypes.touchCancel,
      topTouchEnd: eventTypes.touchEnd,
      topTouchMove: eventTypes.touchMove,
      topTouchStart: eventTypes.touchStart,
      topWheel: eventTypes.wheel
    };
    for (var topLevelType in topLevelEventsToDispatchConfig) {
      topLevelEventsToDispatchConfig[topLevelType].dependencies = [topLevelType];
    }
    var SimpleEventPlugin = {
      eventTypes: eventTypes,
      executeDispatch: function(event, listener, domID) {
        var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
        ("production" !== process.env.NODE_ENV ? warning(typeof returnValue !== 'boolean', 'Returning `false` from an event handler is deprecated and will be ' + 'ignored in a future release. Instead, manually call ' + 'e.stopPropagation() or e.preventDefault(), as appropriate.') : null);
        if (returnValue === false) {
          event.stopPropagation();
          event.preventDefault();
        }
      },
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
        if (!dispatchConfig) {
          return null;
        }
        var EventConstructor;
        switch (topLevelType) {
          case topLevelTypes.topInput:
          case topLevelTypes.topLoad:
          case topLevelTypes.topError:
          case topLevelTypes.topReset:
          case topLevelTypes.topSubmit:
            EventConstructor = SyntheticEvent;
            break;
          case topLevelTypes.topKeyPress:
            if (getEventCharCode(nativeEvent) === 0) {
              return null;
            }
          case topLevelTypes.topKeyDown:
          case topLevelTypes.topKeyUp:
            EventConstructor = SyntheticKeyboardEvent;
            break;
          case topLevelTypes.topBlur:
          case topLevelTypes.topFocus:
            EventConstructor = SyntheticFocusEvent;
            break;
          case topLevelTypes.topClick:
            if (nativeEvent.button === 2) {
              return null;
            }
          case topLevelTypes.topContextMenu:
          case topLevelTypes.topDoubleClick:
          case topLevelTypes.topMouseDown:
          case topLevelTypes.topMouseMove:
          case topLevelTypes.topMouseOut:
          case topLevelTypes.topMouseOver:
          case topLevelTypes.topMouseUp:
            EventConstructor = SyntheticMouseEvent;
            break;
          case topLevelTypes.topDrag:
          case topLevelTypes.topDragEnd:
          case topLevelTypes.topDragEnter:
          case topLevelTypes.topDragExit:
          case topLevelTypes.topDragLeave:
          case topLevelTypes.topDragOver:
          case topLevelTypes.topDragStart:
          case topLevelTypes.topDrop:
            EventConstructor = SyntheticDragEvent;
            break;
          case topLevelTypes.topTouchCancel:
          case topLevelTypes.topTouchEnd:
          case topLevelTypes.topTouchMove:
          case topLevelTypes.topTouchStart:
            EventConstructor = SyntheticTouchEvent;
            break;
          case topLevelTypes.topScroll:
            EventConstructor = SyntheticUIEvent;
            break;
          case topLevelTypes.topWheel:
            EventConstructor = SyntheticWheelEvent;
            break;
          case topLevelTypes.topCopy:
          case topLevelTypes.topCut:
          case topLevelTypes.topPaste:
            EventConstructor = SyntheticClipboardEvent;
            break;
        }
        ("production" !== process.env.NODE_ENV ? invariant(EventConstructor, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(EventConstructor));
        var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    };
    module.exports = SimpleEventPlugin;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultPerf", ["./DOMProperty", "./ReactDefaultPerfAnalysis", "./ReactMount", "./ReactPerf", "./performanceNow"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("./DOMProperty");
  var ReactDefaultPerfAnalysis = require("./ReactDefaultPerfAnalysis");
  var ReactMount = require("./ReactMount");
  var ReactPerf = require("./ReactPerf");
  var performanceNow = require("./performanceNow");
  function roundFloat(val) {
    return Math.floor(val * 100) / 100;
  }
  function addValue(obj, key, val) {
    obj[key] = (obj[key] || 0) + val;
  }
  var ReactDefaultPerf = {
    _allMeasurements: [],
    _mountStack: [0],
    _injected: false,
    start: function() {
      if (!ReactDefaultPerf._injected) {
        ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
      }
      ReactDefaultPerf._allMeasurements.length = 0;
      ReactPerf.enableMeasure = true;
    },
    stop: function() {
      ReactPerf.enableMeasure = false;
    },
    getLastMeasurements: function() {
      return ReactDefaultPerf._allMeasurements;
    },
    printExclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Component class name': item.componentName,
          'Total inclusive time (ms)': roundFloat(item.inclusive),
          'Exclusive mount time (ms)': roundFloat(item.exclusive),
          'Exclusive render time (ms)': roundFloat(item.render),
          'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
          'Render time per instance (ms)': roundFloat(item.render / item.count),
          'Instances': item.count
        };
      }));
    },
    printInclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Inclusive time (ms)': roundFloat(item.time),
          'Instances': item.count
        };
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    getMeasurementsSummaryMap: function(measurements) {
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
      return summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Wasted time (ms)': item.time,
          'Instances': item.count
        };
      });
    },
    printWasted: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    printDOM: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
      console.table(summary.map(function(item) {
        var result = {};
        result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
        result['type'] = item.type;
        result['args'] = JSON.stringify(item.args);
        return result;
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    _recordWrite: function(id, fnName, totalTime, args) {
      var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
      writes[id] = writes[id] || [];
      writes[id].push({
        type: fnName,
        time: totalTime,
        args: args
      });
    },
    measure: function(moduleName, fnName, func) {
      return function() {
        for (var args = [],
            $__0 = 0,
            $__1 = arguments.length; $__0 < $__1; $__0++)
          args.push(arguments[$__0]);
        var totalTime;
        var rv;
        var start;
        if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
          ReactDefaultPerf._allMeasurements.push({
            exclusive: {},
            inclusive: {},
            render: {},
            counts: {},
            writes: {},
            displayNames: {},
            totalTime: 0
          });
          start = performanceNow();
          rv = func.apply(this, args);
          ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
          return rv;
        } else if (moduleName === 'ReactDOMIDOperations' || moduleName === 'ReactComponentBrowserEnvironment') {
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (fnName === 'mountImageIntoNode') {
            var mountID = ReactMount.getID(args[1]);
            ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
          } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
            args[0].forEach(function(update) {
              var writeArgs = {};
              if (update.fromIndex !== null) {
                writeArgs.fromIndex = update.fromIndex;
              }
              if (update.toIndex !== null) {
                writeArgs.toIndex = update.toIndex;
              }
              if (update.textContent !== null) {
                writeArgs.textContent = update.textContent;
              }
              if (update.markupIndex !== null) {
                writeArgs.markup = args[1][update.markupIndex];
              }
              ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
            });
          } else {
            ReactDefaultPerf._recordWrite(args[0], fnName, totalTime, Array.prototype.slice.call(args, 1));
          }
          return rv;
        } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || fnName === '_renderValidatedComponent')) {
          var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
          var isRender = fnName === '_renderValidatedComponent';
          var isMount = fnName === 'mountComponent';
          var mountStack = ReactDefaultPerf._mountStack;
          var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
          if (isRender) {
            addValue(entry.counts, rootNodeID, 1);
          } else if (isMount) {
            mountStack.push(0);
          }
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (isRender) {
            addValue(entry.render, rootNodeID, totalTime);
          } else if (isMount) {
            var subMountTime = mountStack.pop();
            mountStack[mountStack.length - 1] += totalTime;
            addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
            addValue(entry.inclusive, rootNodeID, totalTime);
          } else {
            addValue(entry.inclusive, rootNodeID, totalTime);
          }
          entry.displayNames[rootNodeID] = {
            current: this.constructor.displayName,
            owner: this._owner ? this._owner.constructor.displayName : '<root>'
          };
          return rv;
        } else {
          return func.apply(this, args);
        }
      };
    }
  };
  module.exports = ReactDefaultPerf;
  global.define = __define;
  return module.exports;
});



System.register("npm:immstruct@1.4.0/src/structure", ["immutable", "immutable/contrib/cursor", "eventemitter3", "inherits", "./utils"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var Immutable = require("immutable");
  var Cursor = require("immutable/contrib/cursor");
  var EventEmitter = require("eventemitter3").EventEmitter;
  var inherits = require("inherits");
  var utils = require("./utils");
  function Structure(options) {
    var self = this;
    options = options || {};
    if (!(this instanceof Structure)) {
      return new Structure(options);
    }
    this.key = options.key || utils.generateRandomKey();
    this.current = options.data;
    if (!isImmutableStructure(this.current) || !this.current) {
      this.current = Immutable.fromJS(this.current || {});
    }
    if (!!options.history) {
      this.history = Immutable.List.of(this.current);
      this._currentRevision = 0;
    }
    this._pathListeners = [];
    this.on('swap', function(newData, oldData, keyPath) {
      listListenerMatching(self._pathListeners, pathString(keyPath)).forEach(function(fns) {
        fns.forEach(function(fn) {
          if (typeof fn !== 'function')
            return;
          fn(newData, oldData, keyPath);
        });
      });
    });
    EventEmitter.call(this, arguments);
  }
  inherits(Structure, EventEmitter);
  module.exports = Structure;
  Structure.prototype.cursor = function(path) {
    var self = this;
    path = path || [];
    if (!this.current) {
      throw new Error('No structure loaded.');
    }
    var changeListener = function(newRoot, oldRoot, path) {
      if (self.current === oldRoot) {
        return self.current = newRoot;
      }
      if (!hasIn(newRoot, path)) {
        return self.current = self.current.removeIn(path);
      }
      return self.current = self.current.setIn(path, newRoot.getIn(path));
    };
    changeListener = handleHistory(this, changeListener);
    changeListener = handleSwap(this, changeListener);
    changeListener = handlePersisting(this, changeListener);
    return Cursor.from(self.current, path, changeListener);
  };
  Structure.prototype.reference = function(path) {
    if (isCursor(path) && path._keyPath) {
      path = path._keyPath;
    }
    var self = this,
        pathId = pathString(path);
    var listenerNs = self._pathListeners[pathId];
    var cursor = this.cursor(path);
    var changeListener = function(newRoot, oldRoot, changedPath) {
      cursor = self.cursor(path);
    };
    var referenceListeners = [changeListener];
    this._pathListeners[pathId] = !listenerNs ? referenceListeners : listenerNs.concat(changeListener);
    return {
      observe: function(eventName, newFn) {
        if (typeof eventName === 'function') {
          newFn = eventName;
          eventName = void 0;
        }
        if (this._dead || typeof newFn !== 'function')
          return;
        if (eventName && eventName !== 'swap') {
          newFn = onlyOnEvent(eventName, newFn);
        }
        self._pathListeners[pathId] = self._pathListeners[pathId].concat(newFn);
        referenceListeners = referenceListeners.concat(newFn);
        return function unobserve() {
          var fnIndex = self._pathListeners[pathId].indexOf(newFn);
          var localListenerIndex = referenceListeners.indexOf(newFn);
          if (referenceListeners[localListenerIndex] === newFn) {
            referenceListeners.splice(localListenerIndex, 1);
          }
          if (!self._pathListeners[pathId])
            return;
          if (self._pathListeners[pathId][fnIndex] !== newFn)
            return;
          self._pathListeners[pathId].splice(fnIndex, 1);
        };
      },
      cursor: function(subPath) {
        if (subPath)
          return cursor.cursor(subPath);
        return cursor;
      },
      unobserveAll: function() {
        removeAllListenersBut(self, pathId, referenceListeners, changeListener);
        referenceListeners = [changeListener];
      },
      destroy: function() {
        removeAllListenersBut(self, pathId, referenceListeners);
        referenceListeners = void 0;
        cursor = void 0;
        this._dead = true;
        this.observe = void 0;
        this.unobserveAll = void 0;
        this.cursor = void 0;
        this.destroy = void 0;
      }
    };
  };
  Structure.prototype.forceHasSwapped = function(newData, oldData, keyPath) {
    this.emit('swap', newData || this.current, oldData, keyPath);
    possiblyEmitAnimationFrameEvent(this, newData || this.current, oldData, keyPath);
  };
  Structure.prototype.undo = function(back) {
    this._currentRevision -= back || 1;
    if (this._currentRevision < 0) {
      this._currentRevision = 0;
    }
    this.current = this.history.get(this._currentRevision);
    return this.current;
  };
  Structure.prototype.redo = function(head) {
    this._currentRevision += head || 1;
    if (this._currentRevision > this.history.count() - 1) {
      this._currentRevision = this.history.count() - 1;
    }
    this.current = this.history.get(this._currentRevision);
    return this.current;
  };
  Structure.prototype.undoUntil = function(structure) {
    this._currentRevision = this.history.indexOf(structure);
    this.current = structure;
    return structure;
  };
  function handleHistory(emitter, fn) {
    return function(newData, oldData, path) {
      var newStructure = fn.apply(fn, arguments);
      if (!emitter.history || (newData === oldData))
        return newStructure;
      emitter.history = emitter.history.take(++emitter._currentRevision).push(emitter.current);
      return newStructure;
    };
  }
  var possiblyEmitAnimationFrameEvent = (function() {
    var queuedChange = false;
    if (typeof requestAnimationFrame !== 'function') {
      return function() {};
    }
    return function requestAnimationFrameEmitter(emitter, newStructure, oldData) {
      if (queuedChange)
        return;
      queuedChange = true;
      requestAnimationFrame(function() {
        queuedChange = false;
        emitter.emit('next-animation-frame', newStructure, oldData);
      });
    };
  }());
  function handleSwap(emitter, fn) {
    return function(newData, oldData, keyPath) {
      var newStructure = fn.apply(fn, arguments);
      if (newData === oldData)
        return newStructure;
      emitter.emit('swap', newStructure, oldData, keyPath);
      possiblyEmitAnimationFrameEvent(emitter, newStructure, oldData, keyPath);
      return newStructure;
    };
  }
  function handlePersisting(emitter, fn) {
    return function(newData, oldData, path) {
      var newStructure = fn.apply(fn, arguments);
      if (newData === oldData)
        return newStructure;
      var info = analyze(newData, oldData, path);
      if (info.eventName) {
        emitter.emit.apply(emitter, [info.eventName].concat(info.arguments));
      }
      return newStructure;
    };
  }
  function removeAllListenersBut(self, pathId, listeners, except) {
    if (!listeners)
      return;
    listeners.forEach(function(fn) {
      if (except && fn === except)
        return;
      var index = self._pathListeners[pathId].indexOf(fn);
      self._pathListeners[pathId].splice(index, 1);
    });
  }
  function analyze(newData, oldData, path) {
    var oldObject = oldData && oldData.getIn(path);
    var newObject = newData && newData.getIn(path);
    var inOld = oldData && hasIn(oldData, path);
    var inNew = newData && hasIn(newData, path);
    var arguments,
        eventName;
    if (inOld && !inNew) {
      eventName = 'delete';
      arguments = [path, oldObject];
    } else if (inOld && inNew) {
      eventName = 'change';
      arguments = [path, newObject, oldObject];
    } else if (!inOld && inNew) {
      eventName = 'add';
      arguments = [path, newObject];
    }
    return {
      eventName: eventName,
      arguments: arguments
    };
  }
  var NOT_SET = {};
  function hasIn(cursor, path) {
    if (cursor.hasIn)
      return cursor.hasIn(path);
    return cursor.getIn(path, NOT_SET) !== NOT_SET;
  }
  function pathString(path) {
    var topLevel = 'global';
    if (!path || !path.length)
      return topLevel;
    return [topLevel].concat(path).join('|');
  }
  function listListenerMatching(listeners, basePath) {
    var newListeners = [];
    for (var key in listeners) {
      if (!listeners.hasOwnProperty(key))
        return;
      if (basePath.indexOf(key) !== 0)
        continue;
      newListeners.push(listeners[key]);
    }
    return newListeners;
  }
  function onlyOnEvent(eventName, fn) {
    return function(newData, oldData, keyPath) {
      var info = analyze(newData, oldData, keyPath);
      if (info.eventName !== eventName)
        return;
      return fn(newData, oldData, keyPath);
    };
  }
  function isCursor(potential) {
    return potential && typeof potential.deref === 'function';
  }
  function isImmutableStructure(data) {
    return immutableSafeCheck('Iterable', 'isIterable', data) || immutableSafeCheck('Seq', 'isSeq', data) || immutableSafeCheck('Map', 'isMap', data) || immutableSafeCheck('OrderedMap', 'isOrderedMap', data) || immutableSafeCheck('List', 'isList', data) || immutableSafeCheck('Stack', 'isStack', data) || immutableSafeCheck('Set', 'isSet', data);
  }
  function immutableSafeCheck(ns, method, data) {
    return Immutable[ns] && Immutable[ns][method] && Immutable[ns][method](data);
  }
  global.define = __define;
  return module.exports;
});



System.register("npm:deep-equal@0.2.2", ["npm:deep-equal@0.2.2/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:deep-equal@0.2.2/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/axes/index", ["./XAxis", "./YAxis"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.XAxis = require("./XAxis");
  exports.YAxis = require("./YAxis");
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/charts/Chart", ["react", "./LegendChart", "./BasicChart"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var LegendChart = require("./LegendChart");
  var BasicChart = require("./BasicChart");
  module.exports = React.createClass({
    displayName: 'Chart',
    propTypes: {
      legend: React.PropTypes.bool,
      viewBox: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {legend: false};
    },
    render: function() {
      if (this.props.legend) {
        return React.createElement(LegendChart, React.__spread({}, this.props));
      }
      return React.createElement(BasicChart, React.__spread({}, this.props));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/linechart/DataSeries", ["react", "d3", "./Line", "./Circle"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var Line = require("./Line");
  var Circle = require("./Circle");
  module.exports = React.createClass({
    displayName: 'DataSeries',
    propTypes: {
      data: React.PropTypes.array,
      interpolationType: React.PropTypes.string,
      fill: React.PropTypes.string,
      xAccessor: React.PropTypes.func,
      yAccessor: React.PropTypes.func,
      displayDataPoints: React.PropTypes.bool
    },
    getDefaultProps: function() {
      return {
        data: [],
        interpolationType: 'linear',
        fill: '#fff',
        xAccessor: function(d) {
          return d.x;
        },
        yAccessor: function(d) {
          return d.y;
        },
        displayDataPoints: true
      };
    },
    _isDate: function(d, accessor) {
      return Object.prototype.toString.call(accessor(d)) === '[object Date]';
    },
    render: function() {
      var props = this.props;
      var xAccessor = props.xAccessor,
          yAccessor = props.yAccessor;
      var interpolatePath = d3.svg.line().y(function(d) {
        return props.yScale(props.yAccessor(d));
      }).interpolate(props.interpolationType);
      if (this._isDate(props.data[0], xAccessor)) {
        interpolatePath.x(function(d) {
          return props.xScale(props.xAccessor(d).getTime());
        });
      } else {
        interpolatePath.x(function(d) {
          return props.xScale(props.xAccessor(d));
        });
      }
      props.structure.cursor('voronoiSeries').set(props.seriesName, 'inactive');
      var voronoiSeriesRef = props.structure.reference(['voronoiSeries', props.seriesName]);
      var circles = null;
      if (props.displayDataPoints) {
        circles = props.data.map(function(point, i) {
          var zerox = props.xScale(0);
          var zeroy = props.yScale.range()[0];
          var max_x = 0;
          max_x = props.xScale.range()[2];
          if (props.seriesName.search('ask')) {
            max_x = props.xScale.range()[0];
          }
          if (props.seriesName.search('bid')) {
            max_x = props.xScale.range()[2];
          }
          var r = props.pointRadius;
          var id = props.seriesName + '-' + i;
          var point_hl = false;
          var point_mid = false;
          if (point.highlight) {
            point_hl = true;
            r = 4;
            id = props.seriesName + '-limit-' + i;
          }
          if (point.infinitessimal_price) {}
          if (point.endpoint) {
            r = 0;
          }
          if (point.bid_i === props.bidHlIndex) {
            point_hl = true;
            r = 4;
          }
          var cx,
              cy;
          if (this._isDate(point, xAccessor)) {
            cx = props.xScale(xAccessor(point).getTime());
          } else {
            cx = props.xScale(xAccessor(point));
          }
          if (this._isDate(point, yAccessor)) {
            cy = props.yScale(yAccessor(point).getTime());
          } else {
            cy = props.yScale(yAccessor(point));
          }
          var voronoiRef = props.structure.reference(['voronoi', id]);
          return (React.createElement(Circle, {
            voronoiRef: voronoiRef,
            voronoiSeriesRef: voronoiSeriesRef,
            structure: props.structure,
            cx: cx,
            cy: cy,
            r: r,
            zerox: zerox,
            zeroy: zeroy,
            maxx: max_x,
            point_hl: point_hl,
            point_mid: false,
            fill: props.fill,
            key: props.seriesName + i,
            id: id
          }));
        }, this);
      }
      return (React.createElement("g", null, React.createElement(Line, {
        voronoiSeriesRef: voronoiSeriesRef,
        path: interpolatePath(props.data),
        stroke: props.fill,
        seriesName: props.seriesName
      }), circles));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/piechart/PieChart", ["react", "./DataSeries", "../common/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var DataSeries = require("./DataSeries");
  var Chart = require("../common/index").Chart;
  module.exports = React.createClass({
    displayName: 'PieChart',
    getDefaultProps: function() {
      return {title: ''};
    },
    propTypes: {
      radius: React.PropTypes.number,
      cx: React.PropTypes.number,
      cy: React.PropTypes.number,
      labelTextFill: React.PropTypes.string,
      valueTextFill: React.PropTypes.string,
      colors: React.PropTypes.func,
      title: React.PropTypes.string
    },
    render: function() {
      var props = this.props;
      var transform = ("translate(" + (props.cx || props.width / 2) + "," + (props.cy || props.height / 2) + ")");
      var data = props.data.map(function(item) {
        return item.value;
      });
      var labels = props.data.map(function(item) {
        return item.label;
      });
      return (React.createElement(Chart, {
        width: props.width,
        height: props.height,
        title: props.title
      }, React.createElement("g", {className: "rd3-piechart"}, React.createElement(DataSeries, {
        labelTextFill: props.labelTextFill,
        valueTextFill: props.valueTextFill,
        labels: labels,
        colors: props.colors,
        transform: transform,
        data: data,
        width: props.width,
        height: props.height,
        radius: props.radius,
        innerRadius: props.innerRadius
      }))));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/areachart/AreaChart", ["react", "d3", "./DataSeries", "../common/index", "../mixins/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var DataSeries = require("./DataSeries");
  var common = require("../common/index");
  var Chart = common.Chart;
  var XAxis = common.XAxis;
  var YAxis = common.YAxis;
  var mixins = require("../mixins/index");
  var CartesianChartPropsMixin = mixins.CartesianChartPropsMixin;
  module.exports = React.createClass({
    mixins: [CartesianChartPropsMixin],
    displayName: 'AreaChart',
    propTypes: {margins: React.PropTypes.object},
    getDefaultProps: function() {
      return {
        margins: {
          top: 10,
          right: 20,
          bottom: 40,
          left: 45
        },
        yAxisTickCount: 4,
        className: 'rd3-areachart'
      };
    },
    render: function() {
      var props = this.props;
      var data = props.data;
      var innerWidth,
          innerHeight;
      innerWidth = props.width - props.margins.left - props.margins.right;
      innerHeight = props.height - props.margins.top - props.margins.bottom;
      if (props.legend) {
        innerWidth = innerWidth - props.legendOffset;
      }
      if (!Array.isArray(data)) {
        data = [data];
      }
      var yScale = d3.scale.linear().range([innerHeight, 0]);
      var xValues = [];
      var yValues = [];
      var seriesNames = [];
      data.forEach(function(series) {
        seriesNames.push(series.name);
        series.values.forEach(function(val, idx) {
          xValues.push(props.xAccessor(val));
          yValues.push(props.yAccessor(val));
        });
      });
      var xScale;
      if (xValues.length > 0 && Object.prototype.toString.call(xValues[0]) === '[object Date]' && props.xAxisTickInterval) {
        xScale = d3.time.scale().range([0, innerWidth]);
      } else {
        xScale = d3.scale.linear().range([0, innerWidth]);
      }
      xScale.domain(d3.extent(xValues));
      yScale.domain(d3.extent(yValues));
      props.colors.domain(seriesNames);
      var stack = d3.layout.stack().x(props.xAccessor).y(props.yAccessor).offset('expand').order('reverse').values(function(d) {
        return d.values;
      });
      var layers = stack(data);
      var trans = ("translate(" + props.margins.left + "," + props.margins.top + ")");
      var dataSeries = layers.map(function(d, idx) {
        return (React.createElement(DataSeries, {
          key: idx,
          name: d.name,
          colors: props.colors,
          index: idx,
          xScale: xScale,
          yScale: yScale,
          data: d.values,
          xAccessor: props.xAccessor,
          yAccessor: props.yAccessor
        }));
      });
      return (React.createElement(Chart, {
        viewBox: props.viewBox,
        legend: props.legend,
        data: data,
        margins: props.margins,
        colors: props.colors,
        width: props.width,
        height: props.height,
        title: props.title
      }, React.createElement("g", {
        transform: trans,
        className: props.className
      }, dataSeries, React.createElement(XAxis, {
        xAxisClassName: "rd3-areachart-xaxis",
        xScale: xScale,
        xAxisTickInterval: props.xAxisTickInterval,
        xAxisTickCount: props.xAxisTickCount,
        xAxisLabel: props.xAxisLabel,
        xAxisLabelOffset: props.xAxisLabelOffset,
        tickFormatting: props.xAxisFormatter,
        xOrient: props.xOrient,
        margins: props.margins,
        width: innerWidth,
        height: innerHeight
      }), React.createElement(YAxis, {
        yAxisClassName: "rd3-areachart-yaxis",
        yScale: yScale,
        yAxisTickInterval: props.yAxisTickInterval,
        yAxisTickCount: props.yAxisTickCount,
        yAxisLabel: props.yAxisLabel,
        yAxisLabelOffset: props.yAxisLabelOffset,
        tickFormatting: props.yAxisFormatter,
        yOrient: props.yOrient,
        margins: props.margins,
        width: innerWidth,
        height: props.height
      }))));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/treemap/Treemap", ["react", "../common/index", "./DataSeries"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var Chart = require("../common/index").Chart;
  var DataSeries = require("./DataSeries");
  module.exports = React.createClass({
    displayName: 'Treemap',
    propTypes: {
      margins: React.PropTypes.object,
      data: React.PropTypes.array,
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      title: React.PropTypes.string,
      textColor: React.PropTypes.string,
      fontSize: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number])
    },
    getDefaultProps: function() {
      return {
        data: [],
        width: 400,
        heigth: 200,
        title: '',
        textColor: '#f7f7f7',
        fontSize: '0.85em'
      };
    },
    render: function() {
      var props = this.props;
      return (React.createElement(Chart, {
        title: props.title,
        width: props.width,
        height: props.height
      }, React.createElement("g", {className: "rd3-treemap"}, React.createElement(DataSeries, {
        width: props.width,
        height: props.height,
        data: props.data,
        textColor: props.textColor,
        fontSize: props.fontSize
      }))));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/scatterchart/ScatterChart", ["react", "d3", "../common/index", "../utils/index", "immstruct", "./DataSeries", "../mixins/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var common = require("../common/index");
  var Chart = common.Chart;
  var XAxis = common.XAxis;
  var YAxis = common.YAxis;
  var Voronoi = common.Voronoi;
  var utils = require("../utils/index");
  var immstruct = require("immstruct");
  var DataSeries = require("./DataSeries");
  var CartesianChartPropsMixin = require("../mixins/index").CartesianChartPropsMixin;
  module.exports = React.createClass({
    mixins: [CartesianChartPropsMixin],
    displayName: 'ScatterChart',
    propTypes: {
      margins: React.PropTypes.object,
      pointRadius: React.PropTypes.number,
      hoverAnimation: React.PropTypes.bool
    },
    getDefaultProps: function() {
      return {
        pointRadius: 3,
        margins: {
          top: 10,
          right: 20,
          bottom: 50,
          left: 45
        },
        hoverAnimation: true
      };
    },
    _calculateScales: utils.calculateScales,
    render: function() {
      var structure = immstruct('scatterChart', {voronoi: {}});
      var props = this.props;
      if (this.props.data && this.props.data.length < 1) {
        return React.createElement("g", null);
      }
      var innerWidth,
          innerHeight;
      innerWidth = props.width - props.margins.left - props.margins.right;
      innerHeight = props.height - props.margins.top - props.margins.bottom;
      if (props.legend) {
        innerWidth = innerWidth - props.legendOffset;
      }
      if (!Array.isArray(props.data)) {
        props.data = [props.data];
      }
      var flattenedData = utils.flattenData(props.data, props.xAccessor, props.yAccessor);
      var allValues = flattenedData.allValues,
          xValues = flattenedData.xValues,
          yValues = flattenedData.yValues;
      var scales = this._calculateScales(innerWidth, innerHeight, xValues, yValues);
      var trans = "translate(" + (props.yAxisOffset < 0 ? props.margins.left + Math.abs(props.yAxisOffset) : props.margins.left) + "," + props.margins.top + ")";
      var dataSeriesArray = props.data.map(function(series, idx) {
        return (React.createElement(DataSeries, {
          structure: structure,
          xScale: scales.xScale,
          yScale: scales.yScale,
          seriesName: series.name,
          data: series.values,
          width: innerWidth,
          height: innerHeight,
          fill: props.colors(idx),
          pointRadius: props.pointRadius,
          key: series.name,
          hoverAnimation: props.hoverAnimation,
          xAccessor: props.xAccessor,
          yAccessor: props.yAccessor
        }));
      });
      return (React.createElement(Chart, {
        viewBox: props.viewBox,
        legend: props.legend,
        data: props.data,
        margins: props.margins,
        colors: props.colors,
        width: props.width,
        height: props.height,
        title: props.title
      }, React.createElement("g", {
        transform: trans,
        className: "rd3-scatterchart"
      }, React.createElement(Voronoi, {
        structure: structure,
        data: allValues,
        yScale: scales.yScale,
        xScale: scales.xScale,
        width: innerWidth,
        height: innerHeight
      }), dataSeriesArray, React.createElement(XAxis, {
        xAxisClassName: "rd3-scatterchart-xaxis",
        strokeWidth: "1",
        xAxisTickInterval: props.xAxisTickInterval,
        xAxisOffset: props.xAxisOffset,
        xScale: scales.xScale,
        xAxisLabel: props.xAxisLabel,
        xAxisLabelOffset: props.xAxisLabelOffset,
        tickFormatting: props.xAxisFormatter,
        xOrient: props.xOrient,
        data: props.data,
        margins: props.margins,
        width: innerWidth,
        height: innerHeight,
        stroke: props.axesColor
      }), React.createElement(YAxis, {
        yAxisClassName: "rd3-scatterchart-yaxis",
        yScale: scales.yScale,
        yAxisTickCount: props.yAxisTickCount,
        yAxisOffset: props.yAxisOffset,
        yAxisLabel: props.yAxisLabel,
        yAxisLabelOffset: props.yAxisLabelOffset,
        tickFormatting: props.yAxisFormatter,
        yOrient: props.yOrient,
        margins: props.margins,
        width: innerWidth,
        height: innerHeight,
        stroke: props.axesColor
      }))));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/candlestick/CandlestickChart", ["react", "d3", "immstruct", "../utils/index", "./DataSeries", "../common/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var immstruct = require("immstruct");
  var utils = require("../utils/index");
  var DataSeries = require("./DataSeries");
  var common = require("../common/index");
  var Chart = common.Chart;
  var XAxis = common.XAxis;
  var YAxis = common.YAxis;
  var Voronoi = common.Voronoi;
  module.exports = React.createClass({
    displayName: 'CandleStickChart',
    propTypes: {
      data: React.PropTypes.oneOfType([React.PropTypes.array, React.PropTypes.object]),
      yAxisTickCount: React.PropTypes.number,
      yAxisFormatter: React.PropTypes.func,
      yAccessor: React.PropTypes.func,
      xAxisTickInterval: React.PropTypes.object,
      xAxisFormatter: React.PropTypes.func,
      xAccessor: React.PropTypes.func,
      fillUp: React.PropTypes.func,
      fillDown: React.PropTypes.func,
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      title: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        data: [],
        fillUp: function(i) {
          return 'white';
        },
        fillDown: d3.scale.category20c(),
        margins: {
          top: 10,
          right: 20,
          bottom: 30,
          left: 45
        },
        legendOffset: 120,
        width: 400,
        height: 200,
        title: '',
        xAccessor: function(d) {
          return d.x;
        },
        yAccessor: function(d) {
          return {
            open: d.open,
            high: d.high,
            low: d.low,
            close: d.close
          };
        }
      };
    },
    render: function() {
      var structure = immstruct('candlestickChart', {voronoi: {}});
      var props = this.props;
      var innerWidth,
          innerHeight;
      innerWidth = props.width - props.margins.left - props.margins.right;
      innerHeight = props.height - props.margins.top - props.margins.bottom;
      if (props.legend) {
        innerWidth = innerWidth - props.legendOffset;
      }
      if (!Array.isArray(props.data)) {
        props.data = [props.data];
      }
      var flattenedData = utils.flattenData(props.data, props.xAccessor, props.yAccessor);
      var allValues = flattenedData.allValues,
          xValues = flattenedData.xValues,
          yValues = flattenedData.yValues;
      var scales = utils.calculateScales(innerWidth, innerHeight, xValues, yValues);
      var trans = ("translate(" + (props.yAxisOffset < 0 ? props.margins.left + Math.abs(props.yAxisOffset) : props.margins.left) + "," + props.margins.top + ")");
      var dataSeries = props.data.map(function(series, idx) {
        return (React.createElement(DataSeries, {
          structure: structure,
          series: series,
          key: idx,
          name: series.name,
          colors: props.colors,
          index: idx,
          xScale: scales.xScale,
          yScale: scales.yScale,
          data: series.values,
          fillUp: this.props.fillUp(idx),
          fillDown: this.props.fillDown(idx),
          xAccessor: props.xAccessor,
          yAccessor: props.yAccessor
        }));
      }.bind(this));
      return (React.createElement(Chart, {
        viewBox: props.viewBox,
        width: this.props.width,
        height: this.props.height,
        margins: this.props.margins,
        title: this.props.title
      }, React.createElement("g", {
        transform: trans,
        className: "rd3-candlestick"
      }, dataSeries, React.createElement(Voronoi, {
        structure: structure,
        data: allValues,
        xScale: scales.xScale,
        yScale: scales.yScale,
        width: innerWidth,
        height: innerHeight
      }), React.createElement(XAxis, {
        xAxisClassName: "rd3-candlestick-xaxis",
        xScale: scales.xScale,
        xAxisTickInterval: props.xAxisTickInterval,
        xAxisOffset: props.xAxisOffset,
        tickFormatting: props.xAxisFormatter,
        xAxisLabel: props.xAxisLabel,
        xAxisLabelOffset: props.xAxisLabelOffset,
        xOrient: props.xOrient,
        margins: props.margins,
        width: innerWidth,
        height: innerHeight
      }), React.createElement(YAxis, {
        yAxisClassName: "rd3-candlestick-yaxis",
        yScale: scales.yScale,
        yAxisOffset: props.yAxisOffset,
        yAxisTickCount: props.yAxisTickCount,
        tickFormatting: props.yAxisFormatter,
        yAxisLabel: props.yAxisLabel,
        yAxisLabelOffset: props.yAxisLabelOffset,
        yOrient: props.yOrient,
        margins: props.margins,
        width: innerWidth,
        height: props.height
      }))));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("lib/components/deps/common/index", ["./axes-aligned", "./axes-aligned", "./chart", "./chart", "./legend", "./voronoi"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.XAxis = require("./axes-aligned").XAxis;
  exports.YAxis = require("./axes-aligned").YAxis;
  exports.Chart = require("./chart").Chart;
  exports.LegendChart = require("./chart").LegendChart;
  exports.Legend = require("./legend").Legend;
  exports.Voronoi = require("./voronoi").Voronoi;
  global.define = __define;
  return module.exports;
});



System.register("github:jspm/nodelibs-events@0.1.0/index", ["events-browserify"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('events') : require('events-browserify');
  global.define = __define;
  return module.exports;
});



System.register("npm:buffer@3.2.1/index", ["base64-js", "ieee754", "is-array"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var base64 = require('base64-js');
  var ieee754 = require('ieee754');
  var isArray = require('is-array');
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192;
  var kMaxLength = 0x3fffffff;
  var rootParent = {};
  Buffer.TYPED_ARRAY_SUPPORT = (function() {
    try {
      var buf = new ArrayBuffer(0);
      var arr = new Uint8Array(buf);
      arr.foo = function() {
        return 42;
      };
      return arr.foo() === 42 && typeof arr.subarray === 'function' && new Uint8Array(1).subarray(1, 1).byteLength === 0;
    } catch (e) {
      return false;
    }
  })();
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      if (arguments.length > 1)
        return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }
    this.length = 0;
    this.parent = undefined;
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }
    return fromObject(this, arg);
  }
  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '')
      encoding = 'utf8';
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);
    that.write(string, encoding);
    return that;
  }
  function fromObject(that, object) {
    if (Buffer.isBuffer(object))
      return fromBuffer(that, object);
    if (isArray(object))
      return fromArray(that, object);
    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }
    if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object);
    }
    if (object.length)
      return fromArrayLike(that, object);
    return fromJsonObject(that, object);
  }
  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }
  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromJsonObject(that, object) {
    var array;
    var length = 0;
    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = Buffer._augment(new Uint8Array(length));
    } else {
      that.length = length;
      that._isBuffer = true;
    }
    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool)
      that.parent = rootParent;
    return that;
  }
  function checked(length) {
    if (length >= kMaxLength) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength.toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer))
      return new SlowBuffer(subject, encoding);
    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }
  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };
  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i])
        break;
      ++i;
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!isArray(list))
      throw new TypeError('list argument must be an Array of Buffers.');
    if (list.length === 0) {
      return new Buffer(0);
    } else if (list.length === 1) {
      return list[0];
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }
    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };
  function byteLength(string, encoding) {
    if (typeof string !== 'string')
      string = String(string);
    if (string.length === 0)
      return 0;
    switch (encoding || 'utf8') {
      case 'ascii':
      case 'binary':
      case 'raw':
        return string.length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return string.length * 2;
      case 'hex':
        return string.length >>> 1;
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        return string.length;
    }
  }
  Buffer.byteLength = byteLength;
  Buffer.prototype.length = undefined;
  Buffer.prototype.parent = undefined;
  Buffer.prototype.toString = function toString(encoding, start, end) {
    var loweredCase = false;
    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;
    if (!encoding)
      encoding = 'utf8';
    if (start < 0)
      start = 0;
    if (end > this.length)
      end = this.length;
    if (end <= start)
      return '';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'binary':
          return binarySlice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max)
        str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };
  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return 0;
    return Buffer.compare(this, b);
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff)
      byteOffset = 0x7fffffff;
    else if (byteOffset < -0x80000000)
      byteOffset = -0x80000000;
    byteOffset >>= 0;
    if (this.length === 0)
      return -1;
    if (byteOffset >= this.length)
      return -1;
    if (byteOffset < 0)
      byteOffset = Math.max(this.length + byteOffset, 0);
    if (typeof val === 'string') {
      if (val.length === 0)
        return -1;
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }
    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === val.length)
            return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }
    throw new TypeError('val must be string, number or Buffer');
  };
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new Error('Invalid hex string');
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined)
          encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }
    if (!encoding)
      encoding = 'utf8';
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
          return asciiWrite(this, string, offset, length);
        case 'binary':
          return binaryWrite(this, string, offset, length);
        case 'base64':
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    var res = '';
    var tmp = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      if (buf[i] <= 0x7F) {
        res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
        tmp = '';
      } else {
        tmp += '%' + buf[i].toString(16);
      }
    }
    return res + decodeUtf8Char(tmp);
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }
    if (newBuf.length)
      newBuf.parent = this.parent || this;
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };
  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };
  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
  };
  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
      return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
  }
  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = value;
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = value;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffffffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }
  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = value;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = value;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 0xff + value + 1;
    this[offset] = value;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = value;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
      value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = value;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
    if (offset < 0)
      throw new RangeError('index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value)
      value = 0;
    if (!start)
      start = 0;
    if (!end)
      end = this.length;
    if (end < start)
      throw new RangeError('end < start');
    if (end === start)
      return;
    if (this.length === 0)
      return;
    if (start < 0 || start >= this.length)
      throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length)
      throw new RangeError('end out of bounds');
    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }
    return this;
  };
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0,
            len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };
  var BP = Buffer.prototype;
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;
    arr._set = arr.set;
    arr.get = BP.get;
    arr.set = BP.set;
    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;
    return arr;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }
  function toHex(n) {
    if (n < 16)
      return '0' + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    var i = 0;
    for (; i < length; i++) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (leadSurrogate) {
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          } else {
            codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000;
            leadSurrogate = null;
          }
        } else {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else {
            leadSurrogate = codePoint;
            continue;
          }
        }
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = null;
      }
      if (codePoint < 0x80) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x200000) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c,
        hi,
        lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if ((i + offset >= dst.length) || (i >= src.length))
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function decodeUtf8Char(str) {
    try {
      return decodeURIComponent(str);
    } catch (err) {
      return String.fromCharCode(0xFFFD);
    }
  }
  global.define = __define;
  return module.exports;
});



System.register("npm:sha1@1.1.0/sha1", ["crypt", "charenc", "charenc", "buffer"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    (function() {
      var crypt = require("crypt"),
          utf8 = require("charenc").utf8,
          bin = require("charenc").bin,
          sha1 = function(message) {
            if (message.constructor == String)
              message = utf8.stringToBytes(message);
            else if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer == 'function' && Buffer.isBuffer(message))
              message = Array.prototype.slice.call(message, 0);
            else if (!Array.isArray(message))
              message = message.toString();
            var m = crypt.bytesToWords(message),
                l = message.length * 8,
                w = [],
                H0 = 1732584193,
                H1 = -271733879,
                H2 = -1732584194,
                H3 = 271733878,
                H4 = -1009589776;
            m[l >> 5] |= 0x80 << (24 - l % 32);
            m[((l + 64 >>> 9) << 4) + 15] = l;
            for (var i = 0; i < m.length; i += 16) {
              var a = H0,
                  b = H1,
                  c = H2,
                  d = H3,
                  e = H4;
              for (var j = 0; j < 80; j++) {
                if (j < 16)
                  w[j] = m[i + j];
                else {
                  var n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
                  w[j] = (n << 1) | (n >>> 31);
                }
                var t = ((H0 << 5) | (H0 >>> 27)) + H4 + (w[j] >>> 0) + (j < 20 ? (H1 & H2 | ~H1 & H3) + 1518500249 : j < 40 ? (H1 ^ H2 ^ H3) + 1859775393 : j < 60 ? (H1 & H2 | H1 & H3 | H2 & H3) - 1894007588 : (H1 ^ H2 ^ H3) - 899497514);
                H4 = H3;
                H3 = H2;
                H2 = (H1 << 30) | (H1 >>> 2);
                H1 = H0;
                H0 = t;
              }
              H0 += a;
              H1 += b;
              H2 += c;
              H3 += d;
              H4 += e;
            }
            return [H0, H1, H2, H3, H4];
          },
          api = function(message, options) {
            var digestbytes = crypt.wordsToBytes(sha1(message));
            return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
          };
      api._blocksize = 16;
      api._digestsize = 20;
      module.exports = api;
    })();
  })(require("buffer").Buffer);
  global.define = __define;
  return module.exports;
});



System.register("npm:rcss@0.1.5/styleRuleValidator", ["valid-css-props"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var isValidCSSProps = require('valid-css-props');
  function isValidProp(prop) {
    return isValidCSSProps(prop);
  }
  function isValidValue(value) {
    return value !== '' && (typeof value === 'number' || typeof value === 'string');
  }
  module.exports = {
    isValidProp: isValidProp,
    isValidValue: isValidValue
  };
  global.define = __define;
  return module.exports;
});



System.register("lib/components/grouped-stacked-barchart.jsx!github:floatdrop/plugin-jsx@0.1.1", ["react", "d3", "lodash", "classnames", "./info-tip.jsx!"], function($__export) {
  "use strict";
  var __moduleName = "lib/components/grouped-stacked-barchart.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      d3,
      _,
      classNames,
      InfoTip,
      ChartMixin,
      XAxisLabeled,
      Axis,
      Bars,
      GuideLine,
      Tooltip,
      Legend,
      GroupStackedBarChart,
      ChartContainer;
  return {
    setters: [function(m) {
      React = m.default;
    }, function(m) {
      d3 = m.default;
    }, function(m) {
      _ = m.default;
    }, function(m) {
      classNames = m.default;
    }, function(m) {
      InfoTip = m.InfoTip;
    }],
    execute: function() {
      ChartMixin = {
        propTypes: {
          xScale: React.PropTypes.func.isRequired,
          yScale: React.PropTypes.func.isRequired,
          data: React.PropTypes.array.isRequired,
          transitionDuration: React.PropTypes.number.isRequired
        },
        componentDidMount: function() {
          d3.select(this.getDOMNode()).call(this.renderData);
        },
        componentDidUpdate: function(prevProps, prevState) {
          this.xScale0 = prevProps.xScale;
          this.yScale0 = prevProps.yScale;
          this.prevPayoutMode = prevProps.payoutUSD;
          this.prevLayoutStacked = prevProps.stackedLayout;
          d3.select(this.getDOMNode()).transition().duration(this.props.transitionDuration).call(this.renderData);
        },
        render: function() {
          return (this.transferPropsTo(React.createElement("g", null)));
        }
      };
      XAxisLabeled = React.createClass({
        displayName: "XAxisLabeled",
        styleAxis: function() {
          var props = this.props;
          var offset = Math.round(props.xScale.rangeBand() / 2);
          var offsetIntervalRange = _.map(props.xScale.range(), function(val) {
            return val - 2;
          });
          var last_val = offsetIntervalRange[offsetIntervalRange.length - 1];
          offsetIntervalRange.push(last_val + props.xScale.rangeBand() + 2);
          var xScaleIntervals = d3.scale.ordinal().domain(d3.range(props.xScale.domain().length + 1)).range(offsetIntervalRange);
          var xAxisIntervals = d3.svg.axis().scale(xScaleIntervals).orient("bottom");
          var xAxisLabels = d3.svg.axis().scale(props.xScale).orient("bottom");
          var nodeAxisTicks = d3.select(this.refs.barxaxisticks.getDOMNode());
          var nodeAxisLabels = d3.select(this.refs.barxaxislabels.getDOMNode());
          nodeAxisTicks.call(xAxisIntervals);
          nodeAxisLabels.call(xAxisLabels);
          nodeAxisTicks.selectAll('line').attr("shape-rendering", "crispEdges").attr("stroke", "#000");
          nodeAxisTicks.select('path').attr("shape-rendering", "crispEdges").attr("fill", "none").attr("stroke", "#000");
          nodeAxisTicks.selectAll("text").remove();
          nodeAxisLabels.selectAll('line').remove();
          nodeAxisLabels.select('path').remove();
          nodeAxisLabels.selectAll("text").style("text-anchor", "middle").attr("font-family", "Verdana").attr("font-size", "14px").attr("font-weight", "bold").attr("dx", "-2.0em").attr("dy", "0em").attr("transform", function(d) {
            return "rotate(-60)";
          });
        },
        componentDidMount: function() {
          this.styleAxis();
        },
        componentDidUpdate: function() {},
        render: function() {
          var t = "translate(" + this.props.xOffset + "," + this.props.height + ")";
          return (React.createElement("g", {transform: t}, React.createElement("g", {
            ref: "barxaxisticks",
            className: "barx axis log"
          }), React.createElement("g", {
            ref: "barxaxislabels",
            className: "barx axis log"
          })));
        }
      });
      Axis = React.createClass({
        displayName: "Axis",
        propTypes: {
          scale: React.PropTypes.func.isRequired,
          orient: React.PropTypes.string.isRequired,
          transitionDuration: React.PropTypes.number.isRequired
        },
        componentDidMount: function() {
          this.axis = d3.svg.axis().scale(this.props.scale).orient(this.props.orient);
          d3.select(this.getDOMNode()).call(this.axis);
        },
        componentDidUpdate: function(prevProps, prevState) {
          this.axis.scale(this.props.scale).orient(this.props.orient);
          d3.select(this.getDOMNode()).transition().duration(this.props.transitionDuration).call(this.axis);
        },
        render: function() {
          return this.transferPropsTo(React.createElement("g", null));
        }
      });
      Bars = React.createClass({
        displayName: "Bars",
        mixins: [ChartMixin],
        renderData: function(g) {
          var x = this.props.xScale;
          var y = this.props.yScale;
          var x0 = this.xScale0 || x;
          var y0 = this.yScale0 || y;
          var data = this.props.data;
          var height = this.props.height;
          var colors = this.props.colors;
          var yMargin = this.props.yMargin;
          var stackedLayout = this.props.stackedLayout;
          var payoutUSD = this.props.payoutUSD;
          var transitionDuration = this.props.transitionDuration;
          var tooltipHandler = this.props.onTooltip;
          var prevPayoutMode = this.prevPayoutMode;
          var prevLayoutStacked = this.prevLayoutStacked;
          var payoutModeChanged = false;
          var layoutStackedChanged = false;
          if (prevPayoutMode !== undefined) {
            if (prevPayoutMode !== payoutUSD) {
              payoutModeChanged = true;
            }
            if (prevLayoutStacked !== stackedLayout) {
              layoutStackedChanged = true;
            }
          }
          var x_max = x.range()[1];
          var num_of_bars;
          if (data[0] !== undefined) {
            num_of_bars = data[0].length;
          } else {
            num_of_bars = 1;
          }
          var num_of_groups = data.length;
          var bar_width_stacked = Math.floor(x_max / (num_of_bars + 1)) - 5;
          var bar_width_grouped = Math.floor(x_max / ((num_of_bars + 1) * num_of_groups)) - 1;
          var yGrouped = function(d) {
            return y(d.y);
          };
          var yStacked = function(d) {
            return y(d.y) + y(d.y0) - (height - yMargin);
          };
          var yFunction = stackedLayout ? yStacked : yGrouped;
          var xStacked = function(d) {
            return x(d.x);
          };
          var xGrouped = function(d, i, j) {
            return x(d.x) + (bar_width_grouped + 1) * j;
          };
          var xFunc = stackedLayout ? xStacked : xGrouped;
          var widthStacked = function(d) {
            return bar_width_stacked;
          };
          var widthGrouped = function(d) {
            return bar_width_grouped;
          };
          var widthFunc = stackedLayout ? widthStacked : widthGrouped;
          var heightFunc = function(d) {
            return (height - yMargin) - y(d.y);
          };
          var tooltipProps = {};
          g.each(function() {
            var groups = d3.select(this).selectAll("g").data(data).enter().append("g").classed("series", true).style("fill", function(d, i) {
              return colors[i];
            });
            var bars = groups.selectAll('rect').data(function(d) {
              return d;
            });
            bars.enter().append('rect').attr('x', xFunc).attr('y', yFunction).attr('width', widthFunc).attr('height', heightFunc).on("mouseover", function(d, i, j) {
              var xPosition,
                  yPosition = parseInt(d3.select(this).attr("y"));
              if (d3.select(this).attr("x") < 350) {
                if (!stackedLayout) {
                  xPosition = parseFloat(d3.select(this).attr("x")) + 14;
                } else {
                  xPosition = parseFloat(d3.select(this).attr("x")) + 27;
                }
                tooltipProps.classedLeft = false;
                tooltipProps.classedRight = true;
              } else {
                xPosition = parseFloat(d3.select(this).attr("x")) - 143;
                tooltipProps.classedLeft = true;
                tooltipProps.classedRight = false;
              }
              tooltipProps.posLeft = Math.round(xPosition) + "px";
              tooltipProps.posTop = Math.round(yPosition) + "px";
              tooltipProps.text = d.y.toFixed(2);
              tooltipProps.usd_val = d.usdVal;
              tooltipProps.coin_val = d.coinVal;
              tooltipProps.bar_i = i;
              tooltipProps.bar_j = j;
              tooltipProps.bar_val = d.y;
              tooltipProps.classedHidden = false;
              tooltipHandler(tooltipProps);
            }).on("mouseout", function() {
              tooltipProps.classedHidden = true;
              tooltipHandler(tooltipProps);
            });
            var update_groups = d3.select(this).selectAll("g").data(data);
            update_groups.exit().remove();
            update_groups.style("fill", function(d, i) {
              return colors[i];
            });
            var update_bars = update_groups.selectAll('rect');
            update_bars.data(function(d) {
              return d;
            });
            if (payoutModeChanged || !layoutStackedChanged) {
              update_bars.transition().duration(transitionDuration).attr('height', heightFunc).attr('y', yFunction).attr('width', widthFunc).attr('x', xFunc);
            }
            if (layoutStackedChanged) {
              if (stackedLayout) {
                update_bars.transition().duration(transitionDuration).delay(function(d, i) {
                  return i / data[0].length * transitionDuration;
                }).attr('y', yFunction).attr('height', heightFunc).transition().duration(transitionDuration).attr('x', xFunc).transition().attr('width', widthFunc);
              } else {
                update_bars.transition().duration(transitionDuration).delay(function(d, i) {
                  return i / data[0].length * transitionDuration;
                }).attr('width', widthFunc).transition().duration(transitionDuration).attr('x', xFunc).transition().attr('y', yFunction).attr('height', heightFunc);
              }
            }
          });
        }
      });
      GuideLine = React.createClass({
        displayName: "GuideLine",
        mixins: [ChartMixin],
        renderData: function(g) {
          var xScale = this.props.xScale;
          var yScale = this.props.yScale;
          var payoutUSD = this.props.payoutUSD;
          var layoutStacked = this.props.layoutStacked;
          var neutral_series = [];
          if (layoutStacked) {
            neutral_series = [this.props.completeBundle];
          }
          var valueline = d3.svg.line().x(function(d) {
            return xScale(d.x);
          }).y(function(d) {
            return yScale(d.y);
          });
          g.each(function() {
            var linePath = d3.select(this).selectAll("path");
            linePath.data(neutral_series).enter().append("path").attr("class", "guideline").style("stroke-dasharray", ("3, 3")).attr("d", valueline);
            var update_line = d3.select(this).selectAll("path").data(neutral_series);
            update_line.attr("d", valueline);
            update_line.exit().remove();
          });
        }
      });
      Tooltip = React.createClass({
        displayName: "Tooltip",
        render: function() {
          var tooltipProps = this.props.tooltipProps;
          var outcomePrices = this.props.outcomePrices;
          var payoutUSD = this.props.payoutUSD;
          var tooltipClassStr = classNames({
            'tooltip': true,
            'hidden': tooltipProps.classedHidden,
            'tooltip-left': tooltipProps.classedLeft,
            'tooltip-right': tooltipProps.classedRight
          });
          var tooltipStyles = {
            'left': tooltipProps.posLeft,
            'top': tooltipProps.posTop
          };
          var bar_outcome_price = '$' + (outcomePrices[tooltipProps.bar_i]).toFixed(2);
          var bar_outcome_payout = tooltipProps.bar_val.toFixed(2);
          var bar_usd_payout = tooltipProps.usd_val.toFixed(2);
          var bar_coin_payout = tooltipProps.coin_val.toFixed(2);
          var usd_payout_str = ("$" + bar_usd_payout + " USD");
          var coin_payout_str = (bar_coin_payout + " BTC");
          var payout_str = payoutUSD ? usd_payout_str : coin_payout_str;
          var converted_payout_str = payoutUSD ? coin_payout_str : usd_payout_str;
          var tooltip_text = ("payoff of " + payout_str + " (" + converted_payout_str + ") for outcome price " + bar_outcome_price + " BTC/USD");
          return (React.createElement("div", {
            className: tooltipClassStr,
            style: tooltipStyles
          }, React.createElement("p", null, React.createElement("span", null, tooltip_text))));
        }
      });
      Legend = React.createClass({
        displayName: "Legend",
        componentDidMount: function() {
          var legendLine = d3.svg.line().x(function(d) {
            return d.x;
          }).y(function(d) {
            return d.y;
          });
          var legendData = [{
            x: 0,
            y: 10
          }, {
            x: 20,
            y: 10
          }, {
            x: 30,
            y: 10
          }];
          var legend_g = d3.select(this.getDOMNode()).select("g.legend");
          legend_g.selectAll("path").data([legendData]).enter().append("path").attr("class", "legendline").style("stroke-dasharray", ("3, 3")).attr("d", legendLine);
          legend_g.append("text").attr("x", 35).attr("y", 15).text("Complete Bundle").style("font-size", "14px");
        },
        render: function() {
          return (React.createElement("svg", {
            width: 160,
            height: 25
          }, React.createElement("g", {className: "legend"})));
        }
      });
      GroupStackedBarChart = React.createClass({
        displayName: "GroupStackedBarChart",
        getInitialState: function() {
          return {tooltipProps: {
              classedHidden: true,
              bar_i: 0,
              bar_j: 0,
              bar_val: 0,
              usd_val: 0,
              coin_val: 0
            }};
        },
        onTooltip: function(tooltipProps) {
          this.setState({tooltipProps: tooltipProps});
        },
        render: function() {
          var xScale = this.props.xScale;
          var yScale = this.props.yScale;
          var xTranslate = this.props.height - this.props.yMargin;
          var xAxisTransform = ("translate(0, " + xTranslate + ")");
          var xLabelsScale = d3.scale.ordinal().domain(this.props.outcomeLabels).rangeRoundBands([0, this.props.width - 60], 0.1);
          return (React.createElement("div", {className: "tooltip-container"}, React.createElement(Tooltip, {
            tooltipProps: this.state.tooltipProps,
            outcomePrices: this.props.outcomePrices,
            payoutUSD: this.props.payoutUSD
          }), React.createElement("svg", {
            width: this.props.width,
            height: this.props.height
          }, React.createElement(XAxisLabeled, {
            xScale: xLabelsScale,
            USDLabels: this.props.outcomeLabels,
            xOffset: 55,
            height: this.props.height - this.props.yMargin
          }), React.createElement(Axis, {
            className: "y axis",
            scale: yScale,
            orient: "left",
            transform: "translate(59, 0)",
            transitionDuration: 500
          }), React.createElement(Bars, {
            className: "bars",
            xScale: xScale,
            yScale: yScale,
            yMargin: this.props.yMargin,
            data: this.props.data,
            height: this.props.height,
            colors: this.props.colors,
            transitionDuration: 500,
            stackedLayout: this.props.stackedLayout,
            payoutUSD: this.props.payoutUSD,
            onTooltip: this.onTooltip
          }), React.createElement(GuideLine, {
            className: "guideline",
            xScale: xScale,
            yScale: yScale,
            data: this.props.data,
            payoutUSD: this.props.payoutUSD,
            layoutStacked: this.props.stackedLayout,
            completeBundle: this.props.completeBundle,
            transitionDuration: 500
          }))));
        }
      });
      ChartContainer = React.createClass({
        displayName: "ChartContainer",
        getInitialState: function() {
          return {
            stacked: true,
            payoutUSD: false
          };
        },
        onLayoutOption: function(val) {
          if (val.target.value !== 'stacked') {
            this.setState({stacked: false});
          } else {
            this.setState({stacked: true});
          }
        },
        onUSDOption: function(val) {
          if (val.target.value !== 'usd' && this.state.payoutUSD === true) {
            this.setState({payoutUSD: false});
          }
          if (val.target.value === 'usd' && this.state.payoutUSD === false) {
            this.setState({payoutUSD: true});
          }
        },
        render: function() {
          var $__0 = this;
          var outcomePrices = this.props.outcomePrices;
          var data_bid_bundles = this.props.dataBidBundles;
          var data_series_bundles = _.pluck(data_bid_bundles, 'inv_vector');
          var data_series = data_series_bundles.map((function(series) {
            return series.map((function(qival, i) {
              var coinVal = qival;
              var usdVal = parseFloat((qival * outcomePrices[i]).toFixed(2));
              return {
                x: i,
                coinVal: coinVal,
                usdVal: usdVal,
                y: $__0.state.payoutUSD ? usdVal : coinVal
              };
            }));
          }));
          var series_length = 0;
          if (_.first(data_series)) {
            series_length = _.first(data_series).length;
          }
          var zero_arr = new Array(series_length).fill(0);
          var coin_sums = data_series.reduce((function(memo, series) {
            var coin_vals = _.pluck(series, 'coinVal');
            return coin_vals.map((function(val, i) {
              return val + memo[i];
            }));
          }), zero_arr);
          var max_coin = d3.max(coin_sums);
          var complete_bundle;
          if (this.state.payoutUSD) {
            complete_bundle = outcomePrices.map((function(price, i) {
              return {
                x: i,
                y: max_coin * price
              };
            }));
          } else {
            complete_bundle = zero_arr.map((function(z, i) {
              return {
                x: i,
                y: max_coin
              };
            }));
          }
          var stack = d3.layout.stack();
          stack(data_series);
          var data_series_stacked_merged = _.flatten(data_series);
          var xScale = d3.scale.linear().domain(d3.extent(data_series_stacked_merged, function(d) {
            return d.x;
          })).range([60, this.props.width - 30]).nice();
          var yMargin = 50;
          var max_y = d3.max(_.pluck(complete_bundle, 'y'));
          var yScale = d3.scale.linear().domain([0, Math.round(max_y)]).range([this.props.height - yMargin, 30]).nice();
          return (React.createElement("div", {className: "flex-row-column"}, React.createElement("div", {className: "flex-row-start-center"}, React.createElement("div", {style: {
              display: "inline-block",
              marginLeft: "80px"
            }}, React.createElement("form", null, React.createElement("div", {
            className: "flex-column-start-start",
            style: {"fontSize": "14px"}
          }, React.createElement("label", null, React.createElement("input", {
            type: "radio",
            onChange: this.onLayoutOption,
            name: "layoutmode",
            id: "stacked",
            value: "stacked",
            checked: this.state.stacked
          }), " Stacked"), React.createElement("label", null, React.createElement("input", {
            type: "radio",
            onChange: this.onLayoutOption,
            name: "layoutmode",
            id: "grouped",
            value: "grouped",
            checked: !this.state.stacked
          }), " Grouped")))), "          ", React.createElement("div", {style: {display: "inline-block"}}, React.createElement("div", {style: {
              width: "155px",
              height: "25px",
              border: "0px dotted pink",
              display: "inline-block"
            }}, React.createElement(Legend, null)), React.createElement("div", {style: {
              display: "inline-block",
              position: "relative",
              top: "-8px",
              left: "-5px"
            }}, React.createElement(InfoTip, {
            iconSize: "",
            width: "280px"
          }, React.createElement("span", null, "A complete bundle, or riskless security, has the same payoff for all outcomes. Complementary bundles combine to form a complete bundle. If the selected bundles combine to form a complete bundle, the \"Stacked\" mode bar chart will appear flat across the top."))))), React.createElement("div", {className: "flex-row-start"}, React.createElement("div", {
            className: "flex-column-start-center",
            style: {
              border: '0px solid green',
              maxWidth: '25px'
            }
          }, React.createElement("div", {style: {height: '180px'}}, " "), React.createElement("div", {style: {
              'transform': 'rotate(-90deg)',
              'WebkitTransform': 'rotate(-90deg)',
              'width': '350px'
            }}, "Payoff Amount" + ' ' + "  ", React.createElement("label", null, React.createElement("input", {
            type: "radio",
            onChange: this.onUSDOption,
            name: "payoutmode",
            id: "coin",
            value: "coin",
            checked: !this.state.payoutUSD
          }), "BTC"), "   ", React.createElement("label", null, React.createElement("input", {
            type: "radio",
            onChange: this.onUSDOption,
            name: "payoutmode",
            id: "usd",
            value: "usd",
            checked: this.state.payoutUSD
          }), "USD")), React.createElement("div", {style: {height: '50px'}}, " ")), React.createElement("div", {
            className: "flex-column-center-center",
            style: {border: '0px solid purple'}
          }, React.createElement("div", null, React.createElement(GroupStackedBarChart, {
            width: this.props.width,
            height: this.props.height,
            xScale: xScale,
            yScale: yScale,
            yMargin: yMargin,
            stackedLayout: this.state.stacked,
            payoutUSD: this.state.payoutUSD,
            outcomePrices: this.props.outcomePrices,
            outcomeLabels: this.props.outcomeLabels,
            data: data_series,
            completeBundle: complete_bundle,
            colors: this.props.colors
          })), React.createElement("div", {style: {marginLeft: "45px"}}, "BTC Price at Expiration Date (USD)", React.createElement("div", {style: {
              display: 'inline-block',
              marginTop: "-10px",
              marginLeft: "-5px"
            }}, React.createElement(InfoTip, {iconSize: ""}, React.createElement("span", null, "We assume that the current BTC/USD spot price is $10.00, and some arbitrary future expiration date (e.g. one week, one month, three months). The BTC/USD spot price on the expiration date is used to resolve the market outcome."))))))));
        }
      });
      $__export("ChartContainer", ChartContainer);
    }
  };
});



System.register("lib/components/msr-depth-curve.jsx!github:floatdrop/plugin-jsx@0.1.1", ["react", "immstruct", "omniscient", "immutable", "./info-tip.jsx!", "./react-tangle-nodiv.jsx!", "d3", "lodash", "react-d3", "./deps/barchart.js!jsx", "./deps/stackedbarchart.js!jsx", "./msr-functions.jsx!"], function($__export) {
  "use strict";
  var __moduleName = "lib/components/msr-depth-curve.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      immstruct,
      component,
      Immutable,
      InfoTip,
      TangleText,
      d3,
      _,
      rd3,
      LineChart,
      BarChartDep,
      BarChart,
      StackedBarChartDep,
      StackedBarChart,
      MSR,
      costLMSR,
      priceLMSR,
      depthLMSR,
      depthShortLMSR,
      getSharesAmountFromCost,
      initial_array,
      structure,
      inputMixin,
      StateView,
      Market;
  function roundToTwo(decimal_num) {
    return Math.round(100 * decimal_num) / 100;
  }
  return {
    setters: [function(m) {
      React = m.default;
    }, function(m) {
      immstruct = m.default;
    }, function(m) {
      component = m.default;
    }, function(m) {
      Immutable = m.default;
    }, function(m) {
      InfoTip = m.InfoTip;
    }, function(m) {
      TangleText = m.default;
    }, function(m) {
      d3 = m.default;
    }, function(m) {
      _ = m.default;
    }, function(m) {
      rd3 = m.default;
    }, function(m) {
      BarChartDep = m.default;
    }, function(m) {
      StackedBarChartDep = m.default;
    }, function(m) {
      MSR = m.default;
    }],
    execute: function() {
      LineChart = rd3.LineChart;
      BarChart = BarChartDep.BarChart;
      StackedBarChart = StackedBarChartDep.StackedBarChart;
      costLMSR = MSR.costLMSR;
      priceLMSR = MSR.priceLMSR;
      depthLMSR = MSR.depthLMSR;
      depthShortLMSR = MSR.depthShortLMSR;
      getSharesAmountFromCost = MSR.getSharesAmountFromCost;
      initial_array = [50, 50, 50];
      structure = immstruct({market: {
          Bparam: 250,
          inventoryVector: initial_array,
          bidPrice: 0.5
        }});
      inputMixin = {
        onInputBval: function(val) {
          this.props.cursor.update('Bparam', (function(b_val) {
            return val;
          }));
        },
        onInputInv: function(qi, val) {
          var inv_vec = this.props.cursor.get('inventoryVector').deref().toArray();
          var new_vec = inv_vec;
          new_vec[qi] = val;
          this.props.cursor.update('inventoryVector', (function(oldVec) {
            return Immutable.fromJS(new_vec);
          }));
        }
      };
      StateView = component(inputMixin, function(cursor) {
        var $__0 = this;
        var curs = cursor.cursor;
        var bid_price = curs.get('bidPrice');
        var b_param = curs.get('Bparam');
        var inv_vec = curs.get('inventoryVector').deref().toArray();
        var lmsr_bounded_loss = b_param * Math.log(inv_vec.length);
        var msr_prices = priceLMSR(b_param, inv_vec);
        var outcome_prices = msr_prices.map((function(p) {
          return p.toFixed(3);
        }));
        function costOfBet(q_index, bet_size_shares) {
          var bet_bundle_i = Array.from(inv_vec);
          bet_bundle_i[q_index] += bet_size_shares;
          var cost_of_bet_two = costLMSR(b_param, bet_bundle_i) - costLMSR(b_param, inv_vec);
          var bet_move_price = priceLMSR(b_param, bet_bundle_i)[q_index];
          return {
            'cost': cost_of_bet_two,
            'price': bet_move_price
          };
        }
        function getDepthCurveForOutcome(q_index) {
          var first_price = msr_prices[q_index];
          var step_count = 12;
          var step_size = Math.floor(100 * (0.99 - first_price) / step_count) / 100;
          var buy_price_ticks = d3.range(first_price, 0.98, step_size);
          buy_price_ticks.push(0.985);
          var buy_depth_curve = buy_price_ticks.map((function(p) {
            var depth = depthLMSR(b_param, inv_vec, p);
            return {
              'price': p,
              'amount': depth[q_index]
            };
          }));
          var buy_depth_series = buy_depth_curve.map((function(d_point) {
            return {
              'x': d_point.price,
              'y': d_point.amount
            };
          }));
          buy_depth_series.push({
            'x': first_price,
            'y': 0,
            'infinitessimal_price': false,
            'highlight': false
          });
          buy_depth_series.sort(function(a, b) {
            return b.x - a.x;
          });
          var max_bid_price = msr_prices[q_index];
          var sell_price_ticks = d3.range(0.02, max_bid_price, 0.03);
          var test_sell_price_ticks = d3.range(max_bid_price, 0.02, 0.03);
          var test_short_depth = depthShortLMSR(b_param, inv_vec, test_sell_price_ticks, q_index);
          test_short_depth.sort(function(a, b) {
            return a.price - b.price;
          });
          if (q_index == 0) {
            var bid_index = _.findIndex(test_short_depth, function(bid_point) {
              return bid_price > bid_point.price;
            });
            var bid_indices = test_short_depth.filter((function(bid_point) {
              return bid_price > bid_point.price;
            }));
            test_short_depth.sort(function(a, b) {
              if (a.price === b.price) {
                return a.cost - b.cost;
              }
              return b.price - a.price;
            });
            var max_price = _.first(test_short_depth);
            var zero_point = {
              'price': max_price.price,
              'cost': 0
            };
            test_short_depth.splice(0, 0, zero_point);
          }
          var sell_depth_series = test_short_depth.map((function(d_point) {
            if (d_point.highlight) {
              return {
                'x': d_point.price,
                'y': d_point.cost,
                'highlight': false
              };
            }
            return {
              'x': d_point.price,
              'y': d_point.cost
            };
          }));
          var depth_line_data = [{
            name: 'bid depth',
            values: sell_depth_series
          }, {
            name: 'ask depth',
            values: buy_depth_series
          }];
          return depth_line_data;
        }
        var polyXscales = msr_prices.map((function(p) {
          return d3.scale.linear().domain([0.001, p, 0.99]);
        }));
        var regularPscale = d3.scale.linear().domain([0, 1]);
        var bar_data_prices = msr_prices.map((function(p, i) {
          return {
            label: ("q" + i),
            value: p
          };
        }));
        var bar_data_inventory = inv_vec.map((function(q, i) {
          return {
            label: i,
            value: q
          };
        }));
        var inventory_labels = inv_vec.map((function(q, i) {
          return ("q" + i);
        }));
        var bar_data_stacked = {
          colors: ['cornflowerblue', 'green'],
          labels: inventory_labels,
          series1: inv_vec,
          series2: [0, 0, 0]
        };
        var margins = {
          'top': 10,
          'right': 80,
          'bottom': 50,
          'left': 80
        };
        var qi_textboxes = inv_vec.map((function(q, i) {
          return (React.createElement("div", {style: {
              'display': 'inline-block',
              marginLeft: '5px'
            }}, React.createElement(TangleText, {
            value: inv_vec[i],
            min: 0,
            max: 10000,
            step: 1,
            size: 3,
            onChange: $__0.onInputInv.bind($__0, i),
            onInput: $__0.onInputInv.bind($__0, i)
          })));
        }));
        var priceCharts = inv_vec.map((function(q, i) {
          return (React.createElement("div", {
            key: "msr_depth_chart_" + i,
            style: {
              'border': '1px solid gray',
              'borderTop': '0px',
              'width': '450px',
              'height': '130px'
            }
          }, React.createElement("div", {style: {marginTop: '-20px'}}, React.createElement(LineChart, {
            legend: false,
            data: getDepthCurveForOutcome(i),
            hoverAnimation: false,
            width: 450,
            height: 150,
            pointRadius: 2,
            bidHlIndex: 0,
            colors: d3.scale.ordinal().range(["green", "orange", "orange", "green"]),
            margins: margins,
            xScale: regularPscale,
            yOrient: "left",
            yAxisTickCount: 5,
            yAxisLabel: "bid size r" + i + " (shares)",
            yAxisLabelOffset: 55,
            dualYscale: true
          }))));
        }));
        return (React.createElement("div", null, React.createElement("div", {className: "flex-row-spacearound"}, React.createElement("div", null, React.createElement("strong", null, "Logarthmic Market Scoring Rule (LMSR) as an Automated Market Maker (AMM)"), React.createElement("br", null), React.createElement("span", null, "Visualizing LMSR as bid depth on a combinatorial order book"))), React.createElement("br", null), React.createElement("div", {className: "flex-row-spacearound"}, React.createElement("div", null, React.createElement("div", {style: {
            border: "0px dotted green",
            width: "450px"
          }}, "Number of atomic securities: ", inv_vec.length, React.createElement(InfoTip, {
          iconSize: "",
          width: "280px"
        }, React.createElement("span", null, "Since this is a combinatorial market, the atomic securities are traded together in bundles at prices and quantities specified in traders' orders. These trader bundles are represented as ", React.createElement("b", null, "r"), " vectors. In this example, r has three components, i.e. ", React.createElement("b", null, "r"), " = [r", React.createElement("sub", null, "0"), ", r", React.createElement("sub", null, "1"), ", r", React.createElement("sub", null, "2"), "]. The AMM's inventory is represented with a ", React.createElement("b", null, "Q"), " vector, or inventory vector. The cost to move the AMM's inventory vector is given by a ", React.createElement("i", null, "cost function"), " ", React.createElement("b", null, "C"), ". For example, the cost charged to a trader purchasing a bundle ", React.createElement("b", null, "r"), " is ", React.createElement("b", null, "C"), "(", React.createElement("b", null, "Q"), " + ", React.createElement("b", null, "r"), ") - ", React.createElement("b", null, "C"), "(", React.createElement("b", null, "Q"), ").")), React.createElement("br", null), React.createElement("br", null), "B parameter: ", React.createElement(TangleText, {
          value: b_param,
          min: 2,
          max: 10000,
          step: 1,
          size: 4,
          onChange: this.onInputBval,
          onInput: this.onInputBval
        }), React.createElement("br", null), React.createElement("br", null), "Cost to subsidize LMSR market:", React.createElement("br", null), "B*log(N) = ", b_param, "*log(", inv_vec.length, ") = $", lmsr_bounded_loss.toFixed(2)), React.createElement("br", null), React.createElement("div", {
          className: "flex-column-start depthChartContainer",
          style: {
            'width': '450px',
            'height': '400px',
            'borderTop': '1px solid gray'
          }
        }, priceCharts)), React.createElement("div", {
          className: "flex-column-start-center",
          style: {border: "0px solid red"}
        }, React.createElement("div", null, React.createElement("div", {style: {'textAlign': 'center'}}, "Inventory Vector:", React.createElement(InfoTip, {
          iconSize: "",
          width: "280px"
        }, React.createElement("span", null, "The inventory vector or ", React.createElement("b", null, "Q"), " vector represents the amount of inventory purchased by traders from the AMM. Each element of the Q vector is the number of shares, or binary options, purchased by traders on that particular outcome or state. For example, if Q = [150, 25, 50], then traders have purchased 150 shares on on the outcome q0, 25 shares on the  outcome q1, and 50 shares on the outcome q2."))), React.createElement(StackedBarChart, {
          data: bar_data_stacked,
          width: 300,
          height: 170,
          title: "Inventory"
        }), React.createElement("div", {
          className: "flex-row-spacebetween",
          style: {
            marginLeft: "60px",
            width: "210px"
          }
        }, qi_textboxes)), React.createElement("div", null, React.createElement("br", null), React.createElement("br", null), React.createElement("div", {style: {'textAlign': 'center'}}, "Outcome Prices:", React.createElement("br", null), "[", outcome_prices.join(", "), "]"), React.createElement(BarChart, {
          data: bar_data_prices,
          yAxis: [0, 1],
          width: 250,
          height: 200,
          fill: 'cornflowerblue',
          title: "Prices"
        }))))));
      }).jsx;
      Market = (function() {
        var Market = function Market() {};
        return ($traceurRuntime.createClass)(Market, {init: function(el) {
            render(el);
            structure.on('swap', render);
            function render() {
              React.render(React.createElement(StateView, {cursor: structure.cursor('market')}), el);
            }
          }}, {});
      }());
      $__export('default', new Market());
    }
  };
});



System.register("github:jspm/nodelibs-process@0.1.1", ["github:jspm/nodelibs-process@0.1.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.1/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/traverseAllChildren", ["./ReactElement", "./ReactInstanceHandles", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var invariant = require("./invariant");
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var SUBSEPARATOR = ':';
    var userProvidedKeyEscaperLookup = {
      '=': '=0',
      '.': '=1',
      ':': '=2'
    };
    var userProvidedKeyEscapeRegex = /[=.:]/g;
    function userProvidedKeyEscaper(match) {
      return userProvidedKeyEscaperLookup[match];
    }
    function getComponentKey(component, index) {
      if (component && component.key != null) {
        return wrapUserProvidedKey(component.key);
      }
      return index.toString(36);
    }
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
    }
    function wrapUserProvidedKey(key) {
      return '$' + escapeUserProvidedKey(key);
    }
    var traverseAllChildrenImpl = function(children, nameSoFar, indexSoFar, callback, traverseContext) {
      var nextName,
          nextIndex;
      var subtreeCount = 0;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          nextName = (nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i));
          nextIndex = indexSoFar + subtreeCount;
          subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);
        }
      } else {
        var type = typeof children;
        var isOnlyChild = nameSoFar === '';
        var storageName = isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;
        if (children == null || type === 'boolean') {
          callback(traverseContext, null, storageName, indexSoFar);
          subtreeCount = 1;
        } else if (type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
          callback(traverseContext, children, storageName, indexSoFar);
          subtreeCount = 1;
        } else if (type === 'object') {
          ("production" !== process.env.NODE_ENV ? invariant(!children || children.nodeType !== 1, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(!children || children.nodeType !== 1));
          for (var key in children) {
            if (children.hasOwnProperty(key)) {
              nextName = (nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(children[key], 0));
              nextIndex = indexSoFar + subtreeCount;
              subtreeCount += traverseAllChildrenImpl(children[key], nextName, nextIndex, callback, traverseContext);
            }
          }
        }
      }
      return subtreeCount;
    };
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMount", ["./DOMProperty", "./ReactBrowserEventEmitter", "./ReactCurrentOwner", "./ReactElement", "./ReactLegacyElement", "./ReactInstanceHandles", "./ReactPerf", "./containsNode", "./deprecated", "./getReactRootElementInContainer", "./instantiateReactComponent", "./invariant", "./shouldUpdateReactComponent", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var DOMProperty = require("./DOMProperty");
    var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var ReactElement = require("./ReactElement");
    var ReactLegacyElement = require("./ReactLegacyElement");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var ReactPerf = require("./ReactPerf");
    var containsNode = require("./containsNode");
    var deprecated = require("./deprecated");
    var getReactRootElementInContainer = require("./getReactRootElementInContainer");
    var instantiateReactComponent = require("./instantiateReactComponent");
    var invariant = require("./invariant");
    var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
    var warning = require("./warning");
    var createElement = ReactLegacyElement.wrapCreateElement(ReactElement.createElement);
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var nodeCache = {};
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var instancesByReactRootID = {};
    var containersByReactRootID = {};
    if ("production" !== process.env.NODE_ENV) {
      var rootElementsByReactRootID = {};
    }
    var findComponentRootReusableArray = [];
    function getReactRootID(container) {
      var rootElement = getReactRootElementInContainer(container);
      return rootElement && ReactMount.getID(rootElement);
    }
    function getID(node) {
      var id = internalGetID(node);
      if (id) {
        if (nodeCache.hasOwnProperty(id)) {
          var cached = nodeCache[id];
          if (cached !== node) {
            ("production" !== process.env.NODE_ENV ? invariant(!isValid(cached, id), 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(!isValid(cached, id)));
            nodeCache[id] = node;
          }
        } else {
          nodeCache[id] = node;
        }
      }
      return id;
    }
    function internalGetID(node) {
      return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
    }
    function setID(node, id) {
      var oldID = internalGetID(node);
      if (oldID !== id) {
        delete nodeCache[oldID];
      }
      node.setAttribute(ATTR_NAME, id);
      nodeCache[id] = node;
    }
    function getNode(id) {
      if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
        nodeCache[id] = ReactMount.findReactNodeByID(id);
      }
      return nodeCache[id];
    }
    function isValid(node, id) {
      if (node) {
        ("production" !== process.env.NODE_ENV ? invariant(internalGetID(node) === id, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(internalGetID(node) === id));
        var container = ReactMount.findReactContainerForID(id);
        if (container && containsNode(container, node)) {
          return true;
        }
      }
      return false;
    }
    function purgeID(id) {
      delete nodeCache[id];
    }
    var deepestNodeSoFar = null;
    function findDeepestCachedAncestorImpl(ancestorID) {
      var ancestor = nodeCache[ancestorID];
      if (ancestor && isValid(ancestor, ancestorID)) {
        deepestNodeSoFar = ancestor;
      } else {
        return false;
      }
    }
    function findDeepestCachedAncestor(targetID) {
      deepestNodeSoFar = null;
      ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
      var foundNode = deepestNodeSoFar;
      deepestNodeSoFar = null;
      return foundNode;
    }
    var ReactMount = {
      _instancesByReactRootID: instancesByReactRootID,
      scrollMonitor: function(container, renderCallback) {
        renderCallback();
      },
      _updateRootComponent: function(prevComponent, nextComponent, container, callback) {
        var nextProps = nextComponent.props;
        ReactMount.scrollMonitor(container, function() {
          prevComponent.replaceProps(nextProps, callback);
        });
        if ("production" !== process.env.NODE_ENV) {
          rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
        }
        return prevComponent;
      },
      _registerComponent: function(nextComponent, container) {
        ("production" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), '_registerComponent(...): Target container is not a DOM element.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)));
        ReactBrowserEventEmitter.ensureScrollValueMonitoring();
        var reactRootID = ReactMount.registerContainer(container);
        instancesByReactRootID[reactRootID] = nextComponent;
        return reactRootID;
      },
      _renderNewRootComponent: ReactPerf.measure('ReactMount', '_renderNewRootComponent', function(nextComponent, container, shouldReuseMarkup) {
        ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
        var componentInstance = instantiateReactComponent(nextComponent, null);
        var reactRootID = ReactMount._registerComponent(componentInstance, container);
        componentInstance.mountComponentIntoNode(reactRootID, container, shouldReuseMarkup);
        if ("production" !== process.env.NODE_ENV) {
          rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
        }
        return componentInstance;
      }),
      render: function(nextElement, container, callback) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(nextElement), 'renderComponent(): Invalid component element.%s', (typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : ReactLegacyElement.isValidFactory(nextElement) ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement.props !== "undefined" ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '')) : invariant(ReactElement.isValidElement(nextElement)));
        var prevComponent = instancesByReactRootID[getReactRootID(container)];
        if (prevComponent) {
          var prevElement = prevComponent._currentElement;
          if (shouldUpdateReactComponent(prevElement, nextElement)) {
            return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback);
          } else {
            ReactMount.unmountComponentAtNode(container);
          }
        }
        var reactRootElement = getReactRootElementInContainer(container);
        var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);
        var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
        var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup);
        callback && callback.call(component);
        return component;
      },
      constructAndRenderComponent: function(constructor, props, container) {
        var element = createElement(constructor, props);
        return ReactMount.render(element, container);
      },
      constructAndRenderComponentByID: function(constructor, props, id) {
        var domNode = document.getElementById(id);
        ("production" !== process.env.NODE_ENV ? invariant(domNode, 'Tried to get element with id of "%s" but it is not present on the page.', id) : invariant(domNode));
        return ReactMount.constructAndRenderComponent(constructor, props, domNode);
      },
      registerContainer: function(container) {
        var reactRootID = getReactRootID(container);
        if (reactRootID) {
          reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
        }
        if (!reactRootID) {
          reactRootID = ReactInstanceHandles.createReactRootID();
        }
        containersByReactRootID[reactRootID] = container;
        return reactRootID;
      },
      unmountComponentAtNode: function(container) {
        ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function of ' + 'props and state; triggering nested component updates from render is ' + 'not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
        var reactRootID = getReactRootID(container);
        var component = instancesByReactRootID[reactRootID];
        if (!component) {
          return false;
        }
        ReactMount.unmountComponentFromNode(component, container);
        delete instancesByReactRootID[reactRootID];
        delete containersByReactRootID[reactRootID];
        if ("production" !== process.env.NODE_ENV) {
          delete rootElementsByReactRootID[reactRootID];
        }
        return true;
      },
      unmountComponentFromNode: function(instance, container) {
        instance.unmountComponent();
        if (container.nodeType === DOC_NODE_TYPE) {
          container = container.documentElement;
        }
        while (container.lastChild) {
          container.removeChild(container.lastChild);
        }
      },
      findReactContainerForID: function(id) {
        var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
        var container = containersByReactRootID[reactRootID];
        if ("production" !== process.env.NODE_ENV) {
          var rootElement = rootElementsByReactRootID[reactRootID];
          if (rootElement && rootElement.parentNode !== container) {
            ("production" !== process.env.NODE_ENV ? invariant(internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : invariant(internalGetID(rootElement) === reactRootID));
            var containerChild = container.firstChild;
            if (containerChild && reactRootID === internalGetID(containerChild)) {
              rootElementsByReactRootID[reactRootID] = containerChild;
            } else {
              console.warn('ReactMount: Root element has been removed from its original ' + 'container. New container:', rootElement.parentNode);
            }
          }
        }
        return container;
      },
      findReactNodeByID: function(id) {
        var reactRoot = ReactMount.findReactContainerForID(id);
        return ReactMount.findComponentRoot(reactRoot, id);
      },
      isRenderedByReact: function(node) {
        if (node.nodeType !== 1) {
          return false;
        }
        var id = ReactMount.getID(node);
        return id ? id.charAt(0) === SEPARATOR : false;
      },
      getFirstReactDOM: function(node) {
        var current = node;
        while (current && current.parentNode !== current) {
          if (ReactMount.isRenderedByReact(current)) {
            return current;
          }
          current = current.parentNode;
        }
        return null;
      },
      findComponentRoot: function(ancestorNode, targetID) {
        var firstChildren = findComponentRootReusableArray;
        var childIndex = 0;
        var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
        firstChildren[0] = deepestAncestor.firstChild;
        firstChildren.length = 1;
        while (childIndex < firstChildren.length) {
          var child = firstChildren[childIndex++];
          var targetChild;
          while (child) {
            var childID = ReactMount.getID(child);
            if (childID) {
              if (targetID === childID) {
                targetChild = child;
              } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
                firstChildren.length = childIndex = 0;
                firstChildren.push(child.firstChild);
              }
            } else {
              firstChildren.push(child.firstChild);
            }
            child = child.nextSibling;
          }
          if (targetChild) {
            firstChildren.length = 0;
            return targetChild;
          }
        }
        firstChildren.length = 0;
        ("production" !== process.env.NODE_ENV ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false));
      },
      getReactRootID: getReactRootID,
      getID: getID,
      setID: setID,
      getNode: getNode,
      purgeID: purgeID
    };
    ReactMount.renderComponent = deprecated('ReactMount', 'renderComponent', 'render', this, ReactMount.render);
    module.exports = ReactMount;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/BeforeInputEventPlugin", ["./EventConstants", "./EventPropagators", "./ExecutionEnvironment", "./SyntheticInputEvent", "./keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("./EventConstants");
  var EventPropagators = require("./EventPropagators");
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  var SyntheticInputEvent = require("./SyntheticInputEvent");
  var keyOf = require("./keyOf");
  var canUseTextInputEvent = (ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !('documentMode' in document || isPresto()));
  function isPresto() {
    var opera = window.opera;
    return (typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12);
  }
  var SPACEBAR_CODE = 32;
  var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {beforeInput: {
      phasedRegistrationNames: {
        bubbled: keyOf({onBeforeInput: null}),
        captured: keyOf({onBeforeInputCapture: null})
      },
      dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
    }};
  var fallbackChars = null;
  var hasSpaceKeypress = false;
  function isKeypressCommand(nativeEvent) {
    return ((nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey));
  }
  var BeforeInputEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      var chars;
      if (canUseTextInputEvent) {
        switch (topLevelType) {
          case topLevelTypes.topKeyPress:
            var which = nativeEvent.which;
            if (which !== SPACEBAR_CODE) {
              return;
            }
            hasSpaceKeypress = true;
            chars = SPACEBAR_CHAR;
            break;
          case topLevelTypes.topTextInput:
            chars = nativeEvent.data;
            if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
              return;
            }
            break;
          default:
            return;
        }
      } else {
        switch (topLevelType) {
          case topLevelTypes.topPaste:
            fallbackChars = null;
            break;
          case topLevelTypes.topKeyPress:
            if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
              fallbackChars = String.fromCharCode(nativeEvent.which);
            }
            break;
          case topLevelTypes.topCompositionEnd:
            fallbackChars = nativeEvent.data;
            break;
        }
        if (fallbackChars === null) {
          return;
        }
        chars = fallbackChars;
      }
      if (!chars) {
        return;
      }
      var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent);
      event.data = chars;
      fallbackChars = null;
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
  };
  module.exports = BeforeInputEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CompositionEventPlugin", ["./EventConstants", "./EventPropagators", "./ExecutionEnvironment", "./ReactInputSelection", "./SyntheticCompositionEvent", "./getTextContentAccessor", "./keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("./EventConstants");
  var EventPropagators = require("./EventPropagators");
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  var ReactInputSelection = require("./ReactInputSelection");
  var SyntheticCompositionEvent = require("./SyntheticCompositionEvent");
  var getTextContentAccessor = require("./getTextContentAccessor");
  var keyOf = require("./keyOf");
  var END_KEYCODES = [9, 13, 27, 32];
  var START_KEYCODE = 229;
  var useCompositionEvent = (ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window);
  var useFallbackData = (!useCompositionEvent || ('documentMode' in document && document.documentMode > 8 && document.documentMode <= 11));
  var topLevelTypes = EventConstants.topLevelTypes;
  var currentComposition = null;
  var eventTypes = {
    compositionEnd: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionEnd: null}),
        captured: keyOf({onCompositionEndCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionStart: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionStart: null}),
        captured: keyOf({onCompositionStartCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionUpdate: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionUpdate: null}),
        captured: keyOf({onCompositionUpdateCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    }
  };
  function getCompositionEventType(topLevelType) {
    switch (topLevelType) {
      case topLevelTypes.topCompositionStart:
        return eventTypes.compositionStart;
      case topLevelTypes.topCompositionEnd:
        return eventTypes.compositionEnd;
      case topLevelTypes.topCompositionUpdate:
        return eventTypes.compositionUpdate;
    }
  }
  function isFallbackStart(topLevelType, nativeEvent) {
    return (topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE);
  }
  function isFallbackEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case topLevelTypes.topKeyUp:
        return (END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1);
      case topLevelTypes.topKeyDown:
        return (nativeEvent.keyCode !== START_KEYCODE);
      case topLevelTypes.topKeyPress:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topBlur:
        return true;
      default:
        return false;
    }
  }
  function FallbackCompositionState(root) {
    this.root = root;
    this.startSelection = ReactInputSelection.getSelection(root);
    this.startValue = this.getText();
  }
  FallbackCompositionState.prototype.getText = function() {
    return this.root.value || this.root[getTextContentAccessor()];
  };
  FallbackCompositionState.prototype.getData = function() {
    var endValue = this.getText();
    var prefixLength = this.startSelection.start;
    var suffixLength = this.startValue.length - this.startSelection.end;
    return endValue.substr(prefixLength, endValue.length - suffixLength - prefixLength);
  };
  var CompositionEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      var eventType;
      var data;
      if (useCompositionEvent) {
        eventType = getCompositionEventType(topLevelType);
      } else if (!currentComposition) {
        if (isFallbackStart(topLevelType, nativeEvent)) {
          eventType = eventTypes.compositionStart;
        }
      } else if (isFallbackEnd(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionEnd;
      }
      if (useFallbackData) {
        if (!currentComposition && eventType === eventTypes.compositionStart) {
          currentComposition = new FallbackCompositionState(topLevelTarget);
        } else if (eventType === eventTypes.compositionEnd) {
          if (currentComposition) {
            data = currentComposition.getData();
            currentComposition = null;
          }
        }
      }
      if (eventType) {
        var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent);
        if (data) {
          event.data = data;
        }
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }
  };
  module.exports = CompositionEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/Danger", ["./ExecutionEnvironment", "./createNodesFromMarkup", "./emptyFunction", "./getMarkupWrap", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var createNodesFromMarkup = require("./createNodesFromMarkup");
    var emptyFunction = require("./emptyFunction");
    var getMarkupWrap = require("./getMarkupWrap");
    var invariant = require("./invariant");
    var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
    var RESULT_INDEX_ATTR = 'data-danger-index';
    function getNodeName(markup) {
      return markup.substring(1, markup.indexOf(' '));
    }
    var Danger = {
      dangerouslyRenderMarkup: function(markupList) {
        ("production" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(ExecutionEnvironment.canUseDOM));
        var nodeName;
        var markupByNodeName = {};
        for (var i = 0; i < markupList.length; i++) {
          ("production" !== process.env.NODE_ENV ? invariant(markupList[i], 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(markupList[i]));
          nodeName = getNodeName(markupList[i]);
          nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
          markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
          markupByNodeName[nodeName][i] = markupList[i];
        }
        var resultList = [];
        var resultListAssignmentCount = 0;
        for (nodeName in markupByNodeName) {
          if (!markupByNodeName.hasOwnProperty(nodeName)) {
            continue;
          }
          var markupListByNodeName = markupByNodeName[nodeName];
          for (var resultIndex in markupListByNodeName) {
            if (markupListByNodeName.hasOwnProperty(resultIndex)) {
              var markup = markupListByNodeName[resultIndex];
              markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP, '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
            }
          }
          var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction);
          for (i = 0; i < renderNodes.length; ++i) {
            var renderNode = renderNodes[i];
            if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
              resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
              renderNode.removeAttribute(RESULT_INDEX_ATTR);
              ("production" !== process.env.NODE_ENV ? invariant(!resultList.hasOwnProperty(resultIndex), 'Danger: Assigning to an already-occupied result index.') : invariant(!resultList.hasOwnProperty(resultIndex)));
              resultList[resultIndex] = renderNode;
              resultListAssignmentCount += 1;
            } else if ("production" !== process.env.NODE_ENV) {
              console.error("Danger: Discarding unexpected node:", renderNode);
            }
          }
        }
        ("production" !== process.env.NODE_ENV ? invariant(resultListAssignmentCount === resultList.length, 'Danger: Did not assign to every index of resultList.') : invariant(resultListAssignmentCount === resultList.length));
        ("production" !== process.env.NODE_ENV ? invariant(resultList.length === markupList.length, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(resultList.length === markupList.length));
        return resultList;
      },
      dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
        ("production" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(ExecutionEnvironment.canUseDOM));
        ("production" !== process.env.NODE_ENV ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup));
        ("production" !== process.env.NODE_ENV ? invariant(oldChild.tagName.toLowerCase() !== 'html', 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See renderComponentToString().') : invariant(oldChild.tagName.toLowerCase() !== 'html'));
        var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
        oldChild.parentNode.replaceChild(newChild, oldChild);
      }
    };
    module.exports = Danger;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:immstruct@1.4.0/index", ["./src/structure"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var Structure = require("./src/structure");
  function Immstruct() {
    if (!(this instanceof Immstruct)) {
      return new Immstruct();
    }
    this.instances = {};
  }
  Immstruct.prototype.get = function(key, data) {
    return getInstance(this, {
      key: key,
      data: data
    });
  };
  Immstruct.prototype.clear = function() {
    this.instances = {};
  };
  Immstruct.prototype.remove = function(key) {
    return delete this.instances[key];
  };
  Immstruct.prototype.withHistory = function(key, data) {
    return getInstance(this, {
      key: key,
      data: data,
      history: true
    });
  };
  var inst = new Immstruct();
  module.exports = function(key, data) {
    return getInstance(inst, {
      key: key,
      data: data
    });
  };
  module.exports.withHistory = function(key, data) {
    return getInstance(inst, {
      key: key,
      data: data,
      history: true
    });
  };
  module.exports.Structure = Structure;
  module.exports.Immstruct = Immstruct;
  module.exports.clear = inst.clear.bind(inst);
  module.exports.remove = inst.remove.bind(inst);
  Object.defineProperty(module.exports, 'instances', {
    get: function() {
      return inst.instances;
    },
    enumerable: true,
    configurable: true
  });
  function getInstance(obj, options) {
    if (typeof options.key === 'object') {
      options.data = options.key;
      options.key = void 0;
    }
    if (options.key && obj.instances[options.key]) {
      return obj.instances[options.key];
    }
    var newInstance = new Structure(options);
    obj.instances[newInstance.key] = newInstance;
    return newInstance;
  }
  global.define = __define;
  return module.exports;
});



System.register("npm:omniscient@2.1.0/component", ["react", "deep-equal"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require('react'),
      deepEqual = require('deep-equal');
  module.exports = component;
  module.exports.shouldComponentUpdate = shouldComponentUpdate;
  module.exports.isEqualState = function isEqualState() {
    return deepEqual.apply(this, arguments);
  };
  module.exports.isEqualCursor = function isEqualCursor(a, b) {
    return unCursor(a) === unCursor(b);
  };
  module.exports.isCursor = isCursor;
  var debug;
  module.exports.debug = function(pattern) {
    var regex = new RegExp(pattern || '.*');
    debug = function(str) {
      var key = this._currentElement && this._currentElement.key ? ' key=' + this._currentElement.key : '';
      var name = this.constructor.displayName;
      var tag = name + key;
      if ((key || name) && regex.test(tag))
        console.debug('<' + tag + '>: ' + str);
    };
  };
  function component(displayName, mixins, render) {
    var options = createDefaultArguments(displayName, mixins, render);
    var methodStatics = pickStaticMixins(options.mixins);
    var componentObject = {
      displayName: options.displayName,
      mixins: options.mixins,
      render: function render() {
        if (debug)
          debug.call(this, 'render');
        return options.render.call(this, this.props, this.props.statics);
      }
    };
    if (methodStatics) {
      componentObject.statics = methodStatics;
      removeOldStaticMethods(options.mixins);
    }
    var Component = React.createClass(componentObject);
    var create = function(key, props) {
      var children = toArray(arguments).filter(React.isValidElement);
      if (typeof key === 'object') {
        props = key;
        key = void 0;
      }
      if (!props) {
        props = {};
      }
      if (isCursor(props)) {
        props = {cursor: props};
      }
      if (key) {
        props.key = key;
      }
      if (!!children.length) {
        props.children = children;
      }
      return React.createElement(Component, props);
    };
    create.jsx = Component;
    if (methodStatics) {
      create = extend(create, methodStatics);
    }
    return create;
  }
  ;
  function shouldComponentUpdate(nextProps, nextState) {
    var isEqualState = module.exports.isEqualState;
    var isNotIgnorable = not(or(isStatics, isChildren));
    var nextCursors = filterKeyValue(guaranteeObject(nextProps), isNotIgnorable),
        currentCursors = filterKeyValue(guaranteeObject(this.props), isNotIgnorable);
    var nextCursorsKeys = Object.keys(nextCursors),
        currentCursorsKeys = Object.keys(currentCursors);
    if (currentCursorsKeys.length !== nextCursorsKeys.length) {
      if (debug)
        debug.call(this, 'shouldComponentUpdate => true (number of cursors differ)');
      return true;
    }
    if (hasDifferentKeys(currentCursorsKeys, currentCursors, nextCursors)) {
      if (debug)
        debug.call(this, 'shouldComponentUpdate => true (cursors have different keys)');
      return true;
    }
    if (hasChangedCursors(currentCursors, nextCursors)) {
      if (debug)
        debug.call(this, 'shouldComponentUpdate => true (cursors have changed)');
      return true;
    }
    if (!isEqualState(this.state, nextState)) {
      if (debug)
        debug.call(this, 'shouldComponentUpdate => true (state has changed)');
      return true;
    }
    if (hasChangedProperties(currentCursors, nextCursors)) {
      if (debug)
        debug.call(this, 'shouldComponentUpdate => true (properties have changed)');
      return true;
    }
    if (debug)
      debug.call(this, 'shouldComponentUpdate => false');
    return false;
  }
  function guaranteeObject(prop) {
    if (!prop) {
      return {};
    }
    if (isCursor(prop)) {
      return {_dummy_key: prop};
    }
    if (typeof prop !== 'object') {
      return {_dummy_key: prop};
    }
    return prop;
  }
  function hasDifferentKeys(currentCursorsKeys, currentCursors, nextCursors) {
    return !currentCursorsKeys.every(function existsInBoth(key) {
      return typeof currentCursors[key] !== 'undefined' && typeof nextCursors[key] !== 'undefined';
    });
  }
  function hasChangedCursors(current, next) {
    current = filterKeyValue(current, isCursor);
    next = filterKeyValue(next, isCursor);
    var isEqualCursor = module.exports.isEqualCursor;
    for (var key in current)
      if (!isEqualCursor(current[key], next[key]))
        return true;
    return false;
  }
  function hasChangedProperties(current, next) {
    current = filterKeyValue(current, not(isCursor));
    next = filterKeyValue(next, not(isCursor));
    for (var key in current)
      if (!deepEqual(current[key], next[key]))
        return true;
    return false;
  }
  function createDefaultArguments(displayName, mixins, render) {
    if (typeof displayName === 'function') {
      render = displayName;
      mixins = [];
      displayName = void 0;
    }
    if (typeof displayName === 'object' && typeof mixins === 'function') {
      render = mixins;
      mixins = displayName;
      displayName = void 0;
    }
    if (typeof displayName === 'string' && typeof mixins === 'function') {
      render = mixins;
      mixins = [];
    }
    if (!Array.isArray(mixins)) {
      mixins = [mixins];
    }
    if (!hasShouldComponentUpdate(mixins)) {
      var ShouldComponentUpdate = {shouldComponentUpdate: module.exports.shouldComponentUpdate};
      mixins = [ShouldComponentUpdate].concat(mixins);
    }
    return {
      displayName: displayName,
      mixins: mixins,
      render: render
    };
  }
  function pickStaticMixins(mixins) {
    var filtered = mixins.filter(function(obj) {
      return !!obj.statics;
    });
    if (!filtered.length) {
      return void 0;
    }
    var statics = {};
    filtered.forEach(function(obj) {
      statics = extend(statics, obj.statics);
    });
    return statics;
  }
  function removeOldStaticMethods(mixins) {
    mixins.filter(function(obj) {
      return !!obj.statics;
    }).forEach(function(obj) {
      delete obj.statics;
    });
  }
  function extend(original, extension) {
    for (key in extension) {
      if (extension.hasOwnProperty(key) && !original[key]) {
        original[key] = extension[key];
      }
    }
    return original;
  }
  function hasShouldComponentUpdate(mixins) {
    return !!mixins.filter(function(mixin) {
      return !!mixin.shouldComponentUpdate;
    }).length;
  }
  function isCursor(potential) {
    return potential && ((typeof potential.deref === 'function') || (typeof potential.__deref === 'function'));
  }
  function unCursor(cursor) {
    if (!isCursor(cursor)) {
      return cursor;
    }
    if (typeof cursor.deref === 'function') {
      return cursor.deref();
    }
    return cursor.__deref();
  }
  function filterKeyValue(object, predicate) {
    var key,
        filtered = {};
    for (key in object)
      if (predicate(object[key], key))
        filtered[key] = object[key];
    return filtered;
  }
  function not(fn) {
    return function() {
      return !fn.apply(fn, arguments);
    };
  }
  function isStatics(val, key) {
    return key === 'statics';
  }
  function isChildren(val, key) {
    return key === 'children';
  }
  function or(fn1, fn2) {
    return function() {
      return fn1.apply(null, arguments) || fn2.apply(null, arguments);
    };
  }
  function toArray(args) {
    return Array.prototype.slice.call(args);
  }
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/charts/index", ["./BasicChart", "./Chart", "./LegendChart"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.BasicChart = require("./BasicChart");
  exports.Chart = require("./Chart");
  exports.LegendChart = require("./LegendChart");
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/linechart/LineChart", ["react", "d3", "../common/index", "../utils/index", "immstruct", "./DataSeries", "../mixins/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var common = require("../common/index");
  var Chart = common.Chart;
  var XAxis = common.XAxis;
  var YAxis = common.YAxis;
  var Voronoi = common.Voronoi;
  var utils = require("../utils/index");
  var immstruct = require("immstruct");
  var DataSeries = require("./DataSeries");
  var mixins = require("../mixins/index");
  var CartesianChartPropsMixin = mixins.CartesianChartPropsMixin;
  module.exports = React.createClass({
    mixins: [CartesianChartPropsMixin],
    displayName: 'LineChart',
    propTypes: {
      margins: React.PropTypes.object,
      pointRadius: React.PropTypes.number,
      colors: React.PropTypes.func,
      displayDataPoints: React.PropTypes.bool,
      hoverAnimation: React.PropTypes.bool
    },
    getDefaultProps: function() {
      return {
        margins: {
          top: 10,
          right: 20,
          bottom: 40,
          left: 45
        },
        className: 'rd3-linechart',
        pointRadius: 3,
        interpolate: false,
        interpolationType: null,
        displayDataPoints: true,
        hoverAnimation: true
      };
    },
    render: function() {
      var structure = immstruct('lineChart', {
        voronoi: {},
        voronoiSeries: {}
      });
      var props = this.props;
      var data = props.data;
      var interpolationType = props.interpolationType || (props.interpolate ? 'cardinal' : 'linear');
      var innerWidth,
          innerHeight;
      innerWidth = props.width - props.margins.left - props.margins.right;
      innerHeight = props.height - props.margins.top - props.margins.bottom;
      if (props.legend) {
        innerWidth = innerWidth - props.legendOffset;
      }
      if (!Array.isArray(data)) {
        data = [data];
      }
      var flattenedData = utils.flattenData(data, props.xAccessor, props.yAccessor);
      var allValues = flattenedData.allValues,
          xValues = flattenedData.xValues,
          yValues = flattenedData.yValues;
      var scales = utils.calculateScales(innerWidth, innerHeight, xValues, yValues);
      if (props.xScale) {
        scales.xScale = props.xScale;
        scales.xScale.range([0, innerWidth]);
      }
      if (props.polyxScale) {
        scales.xScale = props.polyxScale;
        scales.xScale.range([0, innerWidth / 2, innerWidth]);
      }
      var trans = ("translate(" + props.margins.left + "," + props.margins.top + ")");
      var dataSeriesArray = data.map(function(series, idx) {
        return (React.createElement(DataSeries, {
          structure: structure,
          xScale: scales.xScale,
          yScale: scales.yScale,
          yOrient: props.yOrient,
          bidHlIndex: props.bidHlIndex,
          seriesName: series.name,
          data: series.values,
          width: innerWidth,
          height: innerHeight,
          fill: props.colors(idx),
          pointRadius: props.pointRadius,
          key: series.name,
          xAccessor: props.xAccessor,
          yAccessor: props.yAccessor,
          interpolationType: interpolationType,
          displayDataPoints: props.displayDataPoints
        }));
      });
      return (React.createElement(Chart, {
        viewBox: props.viewBox,
        legend: props.legend,
        legendPosition: props.legendPosition,
        data: data,
        margins: props.margins,
        colors: props.colors,
        width: props.width,
        height: props.height,
        title: props.title
      }, React.createElement("g", {
        transform: trans,
        className: props.className
      }, dataSeriesArray, props.hoverAnimation ? React.createElement(Voronoi, {
        structure: structure,
        data: allValues,
        xScale: scales.xScale,
        yScale: scales.yScale,
        width: innerWidth,
        height: innerHeight
      }) : React.createElement("g", null), React.createElement(XAxis, {
        xAxisClassName: "rd3-linechart-xaxis",
        tickFormatting: props.xAxisFormatter,
        xAxisLabel: props.xAxisLabel,
        xAxisLabelOffset: props.xAxisLabelOffset,
        xAxisTickCount: props.xAxisTickCount,
        xOrient: props.xOrient,
        xScale: scales.xScale,
        margins: props.margins,
        width: innerWidth,
        height: innerHeight,
        stroke: props.axesColor,
        strokeWidth: props.strokeWidth
      }), React.createElement(YAxis, {
        yAxisClassName: "rd3-linechart-yaxis",
        tickFormatting: props.yAxisFormatter,
        yAxisLabel: props.yAxisLabel,
        yAxisLabelOffset: props.yAxisLabelOffset,
        yAxisTickCount: props.yAxisTickCount,
        yScale: scales.yScale,
        yOrient: props.yOrient,
        margins: props.margins,
        width: innerWidth,
        height: innerHeight,
        stroke: props.axesColor
      }), (props.dualYscale) ? React.createElement(YAxis, {
        yAxisClassName: "rd3-linechart-yaxis",
        tickFormatting: props.yAxisFormatter,
        yAxisLabel: "",
        yAxisLabelOffset: props.yAxisLabelOffset,
        yAxisTickCount: props.yAxisTickCount,
        yScale: scales.yScale,
        yOrient: "right",
        margins: props.margins,
        width: innerWidth,
        height: innerHeight,
        stroke: props.axesColor
      }) : React.createElement("g", null))));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/piechart/index", ["./PieChart"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.PieChart = require("./PieChart");
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/areachart/index", ["./AreaChart"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.AreaChart = require("./AreaChart");
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/treemap/index", ["./Treemap"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.Treemap = require("./Treemap");
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/scatterchart/index", ["./ScatterChart"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.ScatterChart = require("./ScatterChart");
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/candlestick/index", ["./CandlestickChart"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.CandlestickChart = require("./CandlestickChart");
  global.define = __define;
  return module.exports;
});



System.register("github:jspm/nodelibs-events@0.1.0", ["github:jspm/nodelibs-events@0.1.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-events@0.1.0/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:buffer@3.2.1", ["npm:buffer@3.2.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:buffer@3.2.1/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:sha1@1.1.0", ["npm:sha1@1.1.0/sha1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:sha1@1.1.0/sha1");
  global.define = __define;
  return module.exports;
});



System.register("npm:rcss@0.1.5/styleRuleConverter", ["escape-html", "valid-media-queries", "./styleRuleValidator"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var escape = require("escape-html");
  var mediaQueryValidator = require("valid-media-queries");
  var styleRuleValidator = require("./styleRuleValidator");
  var _uppercasePattern = /([A-Z])/g;
  var msPattern = /^ms-/;
  function hyphenateProp(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
  }
  function escapeValueForProp(value, prop) {
    if (prop === 'content') {
      return '"' + value + '"';
    }
    return escape(value);
  }
  function ruleToString(propName, value) {
    var cssPropName = hyphenateProp(propName);
    if (!styleRuleValidator.isValidProp(cssPropName)) {
      console.warn('%s (transformed into %s) is not a valid CSS property name.', propName, cssPropName);
      return '';
    }
    if (!styleRuleValidator.isValidValue(value)) {
      return '';
    }
    return cssPropName + ':' + escapeValueForProp(value, cssPropName) + ';';
  }
  function _rulesToStringHeadless(styleObj) {
    var markup = '';
    for (var key in styleObj) {
      if (!styleObj.hasOwnProperty(key)) {
        continue;
      }
      if (key[0] === ':' || key.substring(0, 6) === '@media') {
        continue;
      }
      markup += ruleToString(key, styleObj[key]);
    }
    return markup;
  }
  function rulesToString(className, styleObj) {
    var markup = '';
    var pseudos = '';
    var mediaQueries = '';
    for (var key in styleObj) {
      if (!styleObj.hasOwnProperty(key)) {
        continue;
      }
      if (key[0] === ':') {
        pseudos += '.' + className + key + '{' + _rulesToStringHeadless(styleObj[key]) + '}';
      } else if (key.substring(0, 6) === '@media') {
        if (!mediaQueryValidator(key)) {
          console.log('%s is not a valid media query.', key);
          continue;
        }
        mediaQueries += key + '{' + rulesToString(className, styleObj[key]) + '}';
      } else {
        markup += ruleToString(key, styleObj[key]);
      }
    }
    if (markup !== '') {
      markup = '.' + className + '{' + markup + '}';
    }
    return markup + pseudos + mediaQueries;
  }
  module.exports = {rulesToString: rulesToString};
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/invariant", ["process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = function(condition, format, a, b, c, d, e, f) {
      if ("production" !== process.env.NODE_ENV) {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error('Invariant Violation: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactChildren", ["./PooledClass", "./traverseAllChildren", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var PooledClass = require("./PooledClass");
    var traverseAllChildren = require("./traverseAllChildren");
    var warning = require("./warning");
    var twoArgumentPooler = PooledClass.twoArgumentPooler;
    var threeArgumentPooler = PooledClass.threeArgumentPooler;
    function ForEachBookKeeping(forEachFunction, forEachContext) {
      this.forEachFunction = forEachFunction;
      this.forEachContext = forEachContext;
    }
    PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
    function forEachSingleChild(traverseContext, child, name, i) {
      var forEachBookKeeping = traverseContext;
      forEachBookKeeping.forEachFunction.call(forEachBookKeeping.forEachContext, child, i);
    }
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      ForEachBookKeeping.release(traverseContext);
    }
    function MapBookKeeping(mapResult, mapFunction, mapContext) {
      this.mapResult = mapResult;
      this.mapFunction = mapFunction;
      this.mapContext = mapContext;
    }
    PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);
    function mapSingleChildIntoContext(traverseContext, child, name, i) {
      var mapBookKeeping = traverseContext;
      var mapResult = mapBookKeeping.mapResult;
      var keyUnique = !mapResult.hasOwnProperty(name);
      ("production" !== process.env.NODE_ENV ? warning(keyUnique, 'ReactChildren.map(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : null);
      if (keyUnique) {
        var mappedChild = mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
        mapResult[name] = mappedChild;
      }
    }
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var mapResult = {};
      var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      MapBookKeeping.release(traverseContext);
      return mapResult;
    }
    function forEachSingleChildDummy(traverseContext, child, name, i) {
      return null;
    }
    function countChildren(children, context) {
      return traverseAllChildren(children, forEachSingleChildDummy, null);
    }
    var ReactChildren = {
      forEach: forEachChildren,
      map: mapChildren,
      count: countChildren
    };
    module.exports = ReactChildren;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactBrowserComponentMixin", ["./ReactEmptyComponent", "./ReactMount", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactEmptyComponent = require("./ReactEmptyComponent");
    var ReactMount = require("./ReactMount");
    var invariant = require("./invariant");
    var ReactBrowserComponentMixin = {getDOMNode: function() {
        ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'getDOMNode(): A component must be mounted to have a DOM node.') : invariant(this.isMounted()));
        if (ReactEmptyComponent.isNullComponentID(this._rootNodeID)) {
          return null;
        }
        return ReactMount.getNode(this._rootNodeID);
      }};
    module.exports = ReactBrowserComponentMixin;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/DOMChildrenOperations", ["./Danger", "./ReactMultiChildUpdateTypes", "./getTextContentAccessor", "./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var Danger = require("./Danger");
    var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");
    var getTextContentAccessor = require("./getTextContentAccessor");
    var invariant = require("./invariant");
    var textContentAccessor = getTextContentAccessor();
    function insertChildAt(parentNode, childNode, index) {
      parentNode.insertBefore(childNode, parentNode.childNodes[index] || null);
    }
    var updateTextContent;
    if (textContentAccessor === 'textContent') {
      updateTextContent = function(node, text) {
        node.textContent = text;
      };
    } else {
      updateTextContent = function(node, text) {
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
        if (text) {
          var doc = node.ownerDocument || document;
          node.appendChild(doc.createTextNode(text));
        }
      };
    }
    var DOMChildrenOperations = {
      dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
      updateTextContent: updateTextContent,
      processUpdates: function(updates, markupList) {
        var update;
        var initialChildren = null;
        var updatedChildren = null;
        for (var i = 0; update = updates[i]; i++) {
          if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
            var updatedIndex = update.fromIndex;
            var updatedChild = update.parentNode.childNodes[updatedIndex];
            var parentID = update.parentID;
            ("production" !== process.env.NODE_ENV ? invariant(updatedChild, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(updatedChild));
            initialChildren = initialChildren || {};
            initialChildren[parentID] = initialChildren[parentID] || [];
            initialChildren[parentID][updatedIndex] = updatedChild;
            updatedChildren = updatedChildren || [];
            updatedChildren.push(updatedChild);
          }
        }
        var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
        if (updatedChildren) {
          for (var j = 0; j < updatedChildren.length; j++) {
            updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
          }
        }
        for (var k = 0; update = updates[k]; k++) {
          switch (update.type) {
            case ReactMultiChildUpdateTypes.INSERT_MARKUP:
              insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.MOVE_EXISTING:
              insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.TEXT_CONTENT:
              updateTextContent(update.parentNode, update.textContent);
              break;
            case ReactMultiChildUpdateTypes.REMOVE_NODE:
              break;
          }
        }
      }
    };
    module.exports = DOMChildrenOperations;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:immstruct@1.4.0", ["npm:immstruct@1.4.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:immstruct@1.4.0/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:omniscient@2.1.0", ["npm:omniscient@2.1.0/component"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:omniscient@2.1.0/component");
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/common/index", ["./axes/index", "./axes/index", "./charts/index", "./charts/index", "./Legend", "./Voronoi"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.XAxis = require("./axes/index").XAxis;
  exports.YAxis = require("./axes/index").YAxis;
  exports.Chart = require("./charts/index").Chart;
  exports.LegendChart = require("./charts/index").LegendChart;
  exports.Legend = require("./Legend");
  exports.Voronoi = require("./Voronoi");
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/linechart/index", ["./LineChart"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.LineChart = require("./LineChart");
  global.define = __define;
  return module.exports;
});



System.register("lib/components/deps/payoff-linechart.js!github:floatdrop/plugin-jsx@0.1.1", ["react", "d3", "./common/index", "events", "./utils"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var common = require("./common/index");
  var Chart = common.Chart;
  var XAxis = common.XAxis;
  var YAxis = common.YAxis;
  var Voronoi = common.Voronoi;
  var EventEmitter = require("events").EventEmitter;
  var pubsub = exports.pubsub = new EventEmitter();
  var utils = require("./utils");
  var Line = React.createClass({
    displayName: "Line",
    propTypes: {
      data: React.PropTypes.object,
      strokeWidth: React.PropTypes.number,
      path: React.PropTypes.string,
      fill: React.PropTypes.string,
      stroke: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        stroke: '#1f77b4',
        strokeWidth: 1.5,
        fill: 'none',
        className: 'rd3-linechart-path'
      };
    },
    getInitialState: function() {
      return {
        lineStrokeWidth: this.props.strokeWidth,
        lineStroke: this.props.stroke
      };
    },
    componentDidMount: function() {
      pubsub.on('animate', this._animateLine);
      pubsub.on('restore', this._restoreLine);
    },
    componentWillUnmount: function() {
      pubsub.removeListener('animate', this._animateLine);
      pubsub.removeListener('restore', this._restoreLine);
    },
    _animateLine: function(id) {
      if (this.props.id === id.split('-')[0]) {
        this.setState({lineStrokeWidth: this.state.lineStrokeWidth * 1.8});
      }
    },
    _restoreLine: function(id) {
      if (this.props.id === id.split('-')[0]) {
        this.setState({lineStrokeWidth: this.props.strokeWidth});
      }
    },
    render: function() {
      var props = this.props;
      var state = this.state;
      return (React.createElement("path", {
        d: props.path,
        stroke: state.lineStroke,
        strokeWidth: state.lineStrokeWidth,
        fill: props.fill,
        className: props.className
      }));
    }
  });
  var Circle = React.createClass({
    displayName: "Circle",
    propTypes: {
      cx: React.PropTypes.number,
      cy: React.PropTypes.number,
      r: React.PropTypes.number,
      fill: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        fill: '#1f77b4',
        className: 'rd3-linechart-circle'
      };
    },
    getInitialState: function() {
      return {
        circleRadius: this.props.r,
        circleColor: this.props.fill
      };
    },
    componentDidMount: function() {
      pubsub.on('animateCircle', this._animateCircle);
      pubsub.on('restoreCircle', this._restoreCircle);
    },
    componentWillUnmount: function() {
      pubsub.removeListener('animateCircle', this._animateCircle);
      pubsub.removeListener('restoreCircle', this._restoreCircle);
    },
    render: function() {
      var props = this.props;
      return (React.createElement("circle", {
        cx: props.cx,
        cy: props.cy,
        r: this.state.circleRadius,
        fill: this.state.circleColor,
        id: props.id,
        className: props.className
      }));
    },
    _animateCircle: function(id) {
      if (this.props.id === id) {
        this.setState({circleRadius: this.state.circleRadius * (5 / 4)});
      }
    },
    _restoreCircle: function(id) {
      if (this.props.id === id) {
        this.setState({circleRadius: this.props.r});
      }
    }
  });
  var DataSeries = React.createClass({
    displayName: "DataSeries",
    propTypes: {
      data: React.PropTypes.array,
      interpolationType: React.PropTypes.string,
      fill: React.PropTypes.string,
      xAccessor: React.PropTypes.func,
      yAccessor: React.PropTypes.func
    },
    getDefaultProps: function() {
      return {
        data: [],
        interpolationType: 'linear',
        fill: '#fff',
        xAccessor: function(d) {
          return d.x;
        },
        yAccessor: function(d) {
          return d.y;
        }
      };
    },
    _isDate: function(d, accessor) {
      return Object.prototype.toString.call(accessor(d)) === '[object Date]';
    },
    render: function() {
      var props = this.props;
      var xAccessor = props.xAccessor,
          yAccessor = props.yAccessor;
      if (props.data == undefined) {
        return React.createElement("g", null);
      }
      var interpolatePath = d3.svg.line().y(function(d) {
        return props.yScale(props.yAccessor(d));
      }).interpolate(props.interpolationType);
      if (this._isDate(props.data[0], xAccessor)) {
        interpolatePath.x(function(d) {
          return props.xScale(props.xAccessor(d).getTime());
        });
      } else {
        interpolatePath.x(function(d) {
          return props.xScale(props.xAccessor(d));
        });
      }
      var circles = props.data.map(function(point, i) {
        var cx,
            cy;
        if (this._isDate(point, xAccessor)) {
          cx = props.xScale(xAccessor(point).getTime());
        } else {
          cx = props.xScale(xAccessor(point));
        }
        if (this._isDate(point, yAccessor)) {
          cy = props.yScale(yAccessor(point).getTime());
        } else {
          cy = props.yScale(yAccessor(point));
        }
        return (React.createElement(Circle, {
          cx: cx,
          cy: cy,
          r: props.pointRadius,
          fill: props.fill,
          key: props.seriesName + i,
          id: props.seriesName + '-' + i
        }));
      }, this);
      return (React.createElement("g", null, React.createElement(Line, {
        path: interpolatePath(props.data),
        stroke: props.fill,
        id: props.seriesName
      }), circles));
    }
  });
  var Axes = React.createClass({
    displayName: "Axes",
    propTypes: {
      xAxisClassName: React.PropTypes.string.isRequired,
      xOrient: React.PropTypes.oneOf(['top', 'bottom']),
      xScale: React.PropTypes.func.isRequired,
      xHideOrigin: React.PropTypes.bool,
      yAxisClassName: React.PropTypes.string.isRequired,
      yOrient: React.PropTypes.oneOf(['left', 'right']),
      yScale: React.PropTypes.func.isRequired,
      yHideOrigin: React.PropTypes.bool,
      chartHeight: React.PropTypes.number.isRequired,
      chartWidth: React.PropTypes.number.isRequired,
      fill: React.PropTypes.string,
      stroke: React.PropTypes.string,
      tickStroke: React.PropTypes.string,
      strokeWidth: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {axesColor: '#000'};
    },
    render: function() {
      var props = this.props;
      return (React.createElement("g", null, React.createElement(YAxis, {
        yAxisClassName: props.yAxisClassName,
        yScale: props.yScale,
        yAxisTickCount: props.yAxisTickCount,
        yHideOrigin: props.yHideOrigin,
        margins: props.margins,
        width: props.chartWidth,
        height: props.chartHeight,
        stroke: props.axesColor
      }), React.createElement(XAxis, {
        xAxisClassName: props.xAxisClassName,
        strokeWidth: props.strokeWidth,
        xHideOrigin: props.xHideOrigin,
        xScale: props.xScale,
        yScale: props.yScale,
        xZeroAligned: props.xZeroAligned,
        margins: props.margins,
        width: props.chartWidth,
        height: props.chartHeight,
        stroke: props.axesColor
      })));
    }
  });
  var PayoffLineChart = React.createClass({
    displayName: "LineChart",
    propTypes: {
      margins: React.PropTypes.object,
      legendOffset: React.PropTypes.number,
      pointRadius: React.PropTypes.number,
      yHideOrigin: React.PropTypes.bool,
      xHideOrigin: React.PropTypes.bool,
      width: React.PropTypes.number,
      height: React.PropTypes.number,
      axesColor: React.PropTypes.string,
      xZeroAligned: React.PropTypes.bool,
      title: React.PropTypes.string,
      colors: React.PropTypes.func,
      legend: React.PropTypes.bool,
      xAccessor: React.PropTypes.func,
      yAccessor: React.PropTypes.func
    },
    getDefaultProps: function() {
      return {
        margins: {
          top: 10,
          right: 20,
          bottom: 40,
          left: 50
        },
        legendOffset: 120,
        pointRadius: 3,
        width: 400,
        height: 200,
        axesColor: '#000',
        xZeroAligned: false,
        title: '',
        colors: d3.scale.category20c(),
        xAccessor: function(d) {
          return d.x;
        },
        yAccessor: function(d) {
          return d.y;
        }
      };
    },
    render: function() {
      var props = this.props;
      var chartWidth,
          chartHeight;
      chartWidth = props.width - props.margins.left - props.margins.right;
      chartHeight = props.height - props.margins.top - props.margins.bottom;
      if (props.legend) {
        chartWidth = chartWidth - props.legendOffset;
      }
      if (props.data.length == 0) {
        return React.createElement("g", null);
      }
      if (!Array.isArray(props.data)) {
        props.data = [props.data];
      }
      var flattenedData = utils.flattenData(props.data, props.xAccessor, props.yAccessor);
      var allValues = flattenedData.allValues,
          xValues = flattenedData.xValues,
          yValues = flattenedData.yValues;
      pubsub.setMaxListeners(xValues.length + yValues.length);
      var scales = utils.calculateScales(chartWidth, chartHeight, xValues, yValues);
      var trans = "translate(" + props.margins.left + "," + props.margins.top + ")";
      var dataSeriesArray = props.data.map(function(series, idx) {
        return (React.createElement(DataSeries, {
          xScale: scales.xScale,
          yScale: scales.yScale,
          seriesName: series.name,
          data: series.values,
          width: chartWidth,
          height: chartHeight,
          fill: series.color,
          pointRadius: props.pointRadius,
          key: series.name,
          xAccessor: props.xAccessor,
          yAccessor: props.yAccessor
        }));
      });
      return (React.createElement(Chart, {
        legend: props.legend,
        data: props.data,
        margins: props.margins,
        colors: props.colors,
        width: props.width,
        height: props.height,
        title: props.title
      }, React.createElement("g", {transform: trans}, dataSeriesArray, React.createElement(Voronoi, {
        pubsub: pubsub,
        data: allValues,
        xScale: scales.xScale,
        yScale: scales.yScale,
        width: chartWidth,
        height: chartHeight
      }), React.createElement(Axes, {
        yAxisClassName: "line y axis",
        yScale: scales.yScale,
        yAxisTickCount: props.yAxisTickCount,
        yHideOrigin: props.yHideOrigin,
        xAxisClassName: "line x axis",
        xScale: scales.xScale,
        xZeroAligned: props.xZeroAligned,
        xHideOrigin: props.xHideOrigin,
        strokeWidth: "1",
        margins: props.margins,
        chartWidth: chartWidth,
        chartHeight: chartHeight,
        stroke: props.axesColor
      }))));
    }
  });
  module.exports = PayoffLineChart;
  global.define = __define;
  return module.exports;
});



System.register("github:jspm/nodelibs-buffer@0.1.0/index", ["buffer"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('buffer') : require('buffer');
  global.define = __define;
  return module.exports;
});



System.register("npm:rcss@0.1.5/registerClass", ["sha1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var sha1 = require('sha1');
  function hashStyle(styleObj) {
    return sha1(JSON.stringify(styleObj));
  }
  function generateValidCSSClassName(styleId) {
    return 'c' + styleId;
  }
  var global = Function("return this")();
  global.__RCSS_0_registry = global.__RCSS_0_registry || {};
  function registerClass(styleObj) {
    var styleId = generateValidCSSClassName(hashStyle(styleObj));
    if (global.__RCSS_0_registry[styleId] == null) {
      global.__RCSS_0_registry[styleId] = {
        className: styleId,
        style: styleObj
      };
    }
    var styleObj = global.__RCSS_0_registry[styleId];
    return {
      className: styleObj.className,
      style: styleObj.style
    };
  }
  module.exports = registerClass;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/DOMProperty", ["./invariant", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("./invariant");
    function checkMask(value, bitmask) {
      return (value & bitmask) === bitmask;
    }
    var DOMPropertyInjection = {
      MUST_USE_ATTRIBUTE: 0x1,
      MUST_USE_PROPERTY: 0x2,
      HAS_SIDE_EFFECTS: 0x4,
      HAS_BOOLEAN_VALUE: 0x8,
      HAS_NUMERIC_VALUE: 0x10,
      HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
      HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
      injectDOMPropertyConfig: function(domPropertyConfig) {
        var Properties = domPropertyConfig.Properties || {};
        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
        if (domPropertyConfig.isCustomAttribute) {
          DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
        }
        for (var propName in Properties) {
          ("production" !== process.env.NODE_ENV ? invariant(!DOMProperty.isStandardName.hasOwnProperty(propName), 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName)));
          DOMProperty.isStandardName[propName] = true;
          var lowerCased = propName.toLowerCase();
          DOMProperty.getPossibleStandardName[lowerCased] = propName;
          if (DOMAttributeNames.hasOwnProperty(propName)) {
            var attributeName = DOMAttributeNames[propName];
            DOMProperty.getPossibleStandardName[attributeName] = propName;
            DOMProperty.getAttributeName[propName] = attributeName;
          } else {
            DOMProperty.getAttributeName[propName] = lowerCased;
          }
          DOMProperty.getPropertyName[propName] = DOMPropertyNames.hasOwnProperty(propName) ? DOMPropertyNames[propName] : propName;
          if (DOMMutationMethods.hasOwnProperty(propName)) {
            DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];
          } else {
            DOMProperty.getMutationMethod[propName] = null;
          }
          var propConfig = Properties[propName];
          DOMProperty.mustUseAttribute[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);
          DOMProperty.mustUseProperty[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);
          DOMProperty.hasSideEffects[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);
          DOMProperty.hasBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);
          DOMProperty.hasNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);
          DOMProperty.hasPositiveNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);
          DOMProperty.hasOverloadedBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);
          ("production" !== process.env.NODE_ENV ? invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName], 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName]));
          ("production" !== process.env.NODE_ENV ? invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName], 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName]));
          ("production" !== process.env.NODE_ENV ? invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1));
        }
      }
    };
    var defaultValueCache = {};
    var DOMProperty = {
      ID_ATTRIBUTE_NAME: 'data-reactid',
      isStandardName: {},
      getPossibleStandardName: {},
      getAttributeName: {},
      getPropertyName: {},
      getMutationMethod: {},
      mustUseAttribute: {},
      mustUseProperty: {},
      hasSideEffects: {},
      hasBooleanValue: {},
      hasNumericValue: {},
      hasPositiveNumericValue: {},
      hasOverloadedBooleanValue: {},
      _isCustomAttributeFunctions: [],
      isCustomAttribute: function(attributeName) {
        for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
          var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
          if (isCustomAttributeFn(attributeName)) {
            return true;
          }
        }
        return false;
      },
      getDefaultValueForProperty: function(nodeName, prop) {
        var nodeDefaults = defaultValueCache[nodeName];
        var testElement;
        if (!nodeDefaults) {
          defaultValueCache[nodeName] = nodeDefaults = {};
        }
        if (!(prop in nodeDefaults)) {
          testElement = document.createElement(nodeName);
          nodeDefaults[prop] = testElement[prop];
        }
        return nodeDefaults[prop];
      },
      injection: DOMPropertyInjection
    };
    module.exports = DOMProperty;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMComponent", ["./CSSPropertyOperations", "./DOMProperty", "./DOMPropertyOperations", "./ReactBrowserComponentMixin", "./ReactComponent", "./ReactBrowserEventEmitter", "./ReactMount", "./ReactMultiChild", "./ReactPerf", "./Object.assign", "./escapeTextForBrowser", "./invariant", "./isEventSupported", "./keyOf", "./monitorCodeUse", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CSSPropertyOperations = require("./CSSPropertyOperations");
    var DOMProperty = require("./DOMProperty");
    var DOMPropertyOperations = require("./DOMPropertyOperations");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactComponent = require("./ReactComponent");
    var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
    var ReactMount = require("./ReactMount");
    var ReactMultiChild = require("./ReactMultiChild");
    var ReactPerf = require("./ReactPerf");
    var assign = require("./Object.assign");
    var escapeTextForBrowser = require("./escapeTextForBrowser");
    var invariant = require("./invariant");
    var isEventSupported = require("./isEventSupported");
    var keyOf = require("./keyOf");
    var monitorCodeUse = require("./monitorCodeUse");
    var deleteListener = ReactBrowserEventEmitter.deleteListener;
    var listenTo = ReactBrowserEventEmitter.listenTo;
    var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
    var CONTENT_TYPES = {
      'string': true,
      'number': true
    };
    var STYLE = keyOf({style: null});
    var ELEMENT_NODE_TYPE = 1;
    function assertValidProps(props) {
      if (!props) {
        return;
      }
      ("production" !== process.env.NODE_ENV ? invariant(props.children == null || props.dangerouslySetInnerHTML == null, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(props.children == null || props.dangerouslySetInnerHTML == null));
      if ("production" !== process.env.NODE_ENV) {
        if (props.contentEditable && props.children != null) {
          console.warn('A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of those ' + 'nodes are unexpectedly modified or duplicated. This is probably not ' + 'intentional.');
        }
      }
      ("production" !== process.env.NODE_ENV ? invariant(props.style == null || typeof props.style === 'object', 'The `style` prop expects a mapping from style properties to values, ' + 'not a string.') : invariant(props.style == null || typeof props.style === 'object'));
    }
    function putListener(id, registrationName, listener, transaction) {
      if ("production" !== process.env.NODE_ENV) {
        if (registrationName === 'onScroll' && !isEventSupported('scroll', true)) {
          monitorCodeUse('react_no_scroll_event');
          console.warn('This browser doesn\'t support the `onScroll` event');
        }
      }
      var container = ReactMount.findReactContainerForID(id);
      if (container) {
        var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
        listenTo(registrationName, doc);
      }
      transaction.getPutListenerQueue().enqueuePutListener(id, registrationName, listener);
    }
    var omittedCloseTags = {
      'area': true,
      'base': true,
      'br': true,
      'col': true,
      'embed': true,
      'hr': true,
      'img': true,
      'input': true,
      'keygen': true,
      'link': true,
      'meta': true,
      'param': true,
      'source': true,
      'track': true,
      'wbr': true
    };
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = {};
    var hasOwnProperty = {}.hasOwnProperty;
    function validateDangerousTag(tag) {
      if (!hasOwnProperty.call(validatedTagCache, tag)) {
        ("production" !== process.env.NODE_ENV ? invariant(VALID_TAG_REGEX.test(tag), 'Invalid tag: %s', tag) : invariant(VALID_TAG_REGEX.test(tag)));
        validatedTagCache[tag] = true;
      }
    }
    function ReactDOMComponent(tag) {
      validateDangerousTag(tag);
      this._tag = tag;
      this.tagName = tag.toUpperCase();
    }
    ReactDOMComponent.displayName = 'ReactDOMComponent';
    ReactDOMComponent.Mixin = {
      mountComponent: ReactPerf.measure('ReactDOMComponent', 'mountComponent', function(rootID, transaction, mountDepth) {
        ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
        assertValidProps(this.props);
        var closeTag = omittedCloseTags[this._tag] ? '' : '</' + this._tag + '>';
        return (this._createOpenTagMarkupAndPutListeners(transaction) + this._createContentMarkup(transaction) + closeTag);
      }),
      _createOpenTagMarkupAndPutListeners: function(transaction) {
        var props = this.props;
        var ret = '<' + this._tag;
        for (var propKey in props) {
          if (!props.hasOwnProperty(propKey)) {
            continue;
          }
          var propValue = props[propKey];
          if (propValue == null) {
            continue;
          }
          if (registrationNameModules.hasOwnProperty(propKey)) {
            putListener(this._rootNodeID, propKey, propValue, transaction);
          } else {
            if (propKey === STYLE) {
              if (propValue) {
                propValue = props.style = assign({}, props.style);
              }
              propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
            }
            var markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
            if (markup) {
              ret += ' ' + markup;
            }
          }
        }
        if (transaction.renderToStaticMarkup) {
          return ret + '>';
        }
        var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
        return ret + ' ' + markupForID + '>';
      },
      _createContentMarkup: function(transaction) {
        var innerHTML = this.props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            return innerHTML.__html;
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof this.props.children] ? this.props.children : null;
          var childrenToUse = contentToUse != null ? null : this.props.children;
          if (contentToUse != null) {
            return escapeTextForBrowser(contentToUse);
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(childrenToUse, transaction);
            return mountImages.join('');
          }
        }
        return '';
      },
      receiveComponent: function(nextElement, transaction) {
        if (nextElement === this._currentElement && nextElement._owner != null) {
          return;
        }
        ReactComponent.Mixin.receiveComponent.call(this, nextElement, transaction);
      },
      updateComponent: ReactPerf.measure('ReactDOMComponent', 'updateComponent', function(transaction, prevElement) {
        assertValidProps(this._currentElement.props);
        ReactComponent.Mixin.updateComponent.call(this, transaction, prevElement);
        this._updateDOMProperties(prevElement.props, transaction);
        this._updateDOMChildren(prevElement.props, transaction);
      }),
      _updateDOMProperties: function(lastProps, transaction) {
        var nextProps = this.props;
        var propKey;
        var styleName;
        var styleUpdates;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = lastProps[propKey];
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = '';
              }
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            deleteListener(this._rootNodeID, propKey);
          } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            ReactComponent.BackendIDOperations.deletePropertyByID(this._rootNodeID, propKey);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = lastProps[propKey];
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
            continue;
          }
          if (propKey === STYLE) {
            if (nextProp) {
              nextProp = nextProps.style = assign({}, nextProp);
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = '';
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              styleUpdates = nextProp;
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            putListener(this._rootNodeID, propKey, nextProp, transaction);
          } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            ReactComponent.BackendIDOperations.updatePropertyByID(this._rootNodeID, propKey, nextProp);
          }
        }
        if (styleUpdates) {
          ReactComponent.BackendIDOperations.updateStylesByID(this._rootNodeID, styleUpdates);
        }
      },
      _updateDOMChildren: function(lastProps, transaction) {
        var nextProps = this.props;
        var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
        var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
        var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
        var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
        var lastChildren = lastContent != null ? null : lastProps.children;
        var nextChildren = nextContent != null ? null : nextProps.children;
        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
        if (lastChildren != null && nextChildren == null) {
          this.updateChildren(null, transaction);
        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
          this.updateTextContent('');
        }
        if (nextContent != null) {
          if (lastContent !== nextContent) {
            this.updateTextContent('' + nextContent);
          }
        } else if (nextHtml != null) {
          if (lastHtml !== nextHtml) {
            ReactComponent.BackendIDOperations.updateInnerHTMLByID(this._rootNodeID, nextHtml);
          }
        } else if (nextChildren != null) {
          this.updateChildren(nextChildren, transaction);
        }
      },
      unmountComponent: function() {
        this.unmountChildren();
        ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
        ReactComponent.Mixin.unmountComponent.call(this);
      }
    };
    assign(ReactDOMComponent.prototype, ReactComponent.Mixin, ReactDOMComponent.Mixin, ReactMultiChild.Mixin, ReactBrowserComponentMixin);
    module.exports = ReactDOMComponent;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMIDOperations", ["./CSSPropertyOperations", "./DOMChildrenOperations", "./DOMPropertyOperations", "./ReactMount", "./ReactPerf", "./invariant", "./setInnerHTML", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CSSPropertyOperations = require("./CSSPropertyOperations");
    var DOMChildrenOperations = require("./DOMChildrenOperations");
    var DOMPropertyOperations = require("./DOMPropertyOperations");
    var ReactMount = require("./ReactMount");
    var ReactPerf = require("./ReactPerf");
    var invariant = require("./invariant");
    var setInnerHTML = require("./setInnerHTML");
    var INVALID_PROPERTY_ERRORS = {
      dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
      style: '`style` must be set using `updateStylesByID()`.'
    };
    var ReactDOMIDOperations = {
      updatePropertyByID: ReactPerf.measure('ReactDOMIDOperations', 'updatePropertyByID', function(id, name, value) {
        var node = ReactMount.getNode(id);
        ("production" !== process.env.NODE_ENV ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
        if (value != null) {
          DOMPropertyOperations.setValueForProperty(node, name, value);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, name);
        }
      }),
      deletePropertyByID: ReactPerf.measure('ReactDOMIDOperations', 'deletePropertyByID', function(id, name, value) {
        var node = ReactMount.getNode(id);
        ("production" !== process.env.NODE_ENV ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
        DOMPropertyOperations.deleteValueForProperty(node, name, value);
      }),
      updateStylesByID: ReactPerf.measure('ReactDOMIDOperations', 'updateStylesByID', function(id, styles) {
        var node = ReactMount.getNode(id);
        CSSPropertyOperations.setValueForStyles(node, styles);
      }),
      updateInnerHTMLByID: ReactPerf.measure('ReactDOMIDOperations', 'updateInnerHTMLByID', function(id, html) {
        var node = ReactMount.getNode(id);
        setInnerHTML(node, html);
      }),
      updateTextContentByID: ReactPerf.measure('ReactDOMIDOperations', 'updateTextContentByID', function(id, content) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.updateTextContent(node, content);
      }),
      dangerouslyReplaceNodeWithMarkupByID: ReactPerf.measure('ReactDOMIDOperations', 'dangerouslyReplaceNodeWithMarkupByID', function(id, markup) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
      }),
      dangerouslyProcessChildrenUpdates: ReactPerf.measure('ReactDOMIDOperations', 'dangerouslyProcessChildrenUpdates', function(updates, markup) {
        for (var i = 0; i < updates.length; i++) {
          updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
        }
        DOMChildrenOperations.processUpdates(updates, markup);
      })
    };
    module.exports = ReactDOMIDOperations;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/barchart/BarChart", ["react", "d3", "./DataSeries", "../common/index", "../mixins/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var React = require("react");
  var d3 = require("d3");
  var DataSeries = require("./DataSeries");
  var common = require("../common/index");
  var Chart = common.Chart;
  var XAxis = common.XAxis;
  var YAxis = common.YAxis;
  var mixins = require("../mixins/index");
  var CartesianChartPropsMixin = mixins.CartesianChartPropsMixin;
  module.exports = React.createClass({
    mixins: [CartesianChartPropsMixin],
    displayName: 'BarChart',
    propTypes: {
      data: React.PropTypes.array,
      yAxisTickCount: React.PropTypes.number,
      width: React.PropTypes.number,
      margins: React.PropTypes.object,
      height: React.PropTypes.number,
      fill: React.PropTypes.string,
      title: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        yAxisTickCount: 4,
        margins: {
          top: 10,
          right: 20,
          bottom: 40,
          left: 45
        },
        fill: "#3182bd"
      };
    },
    render: function() {
      var props = this.props;
      var values = props.data.map(function(item) {
        return item.value;
      });
      var labels = props.data.map(function(item) {
        return item.label;
      });
      var margins = props.margins;
      var sideMargins = margins.left + margins.right;
      var topBottomMargins = margins.top + margins.bottom;
      var yScale = d3.scale.linear().domain([d3.min([d3.min(values), 0]), d3.max(values)]).range([props.height - topBottomMargins, 0]);
      var xScale = d3.scale.ordinal().domain(labels).rangeRoundBands([0, props.width - sideMargins], 0.1);
      var trans = ("translate(" + margins.left + "," + margins.top + ")");
      return (React.createElement(Chart, {
        width: props.width,
        height: props.height,
        title: props.title
      }, React.createElement("g", {
        transform: trans,
        className: "rd3-barchart"
      }, React.createElement(DataSeries, {
        values: values,
        yScale: yScale,
        xScale: yScale,
        margins: margins,
        data: props.data,
        width: props.width - sideMargins,
        height: props.height - topBottomMargins,
        fill: props.fill
      }), React.createElement(YAxis, {
        yAxisClassName: "rd3-barchart-yaxis",
        yAxisLabel: props.yAxisLabel,
        yAxisLabelOffset: props.yAxisLabelOffset,
        yScale: yScale,
        margins: margins,
        yAxisTickCount: props.yAxisTickCount,
        tickFormatting: props.yAxisFormatter,
        width: props.width - sideMargins,
        height: props.height - topBottomMargins
      }), React.createElement(XAxis, {
        xAxisClassName: "rd3-barchart-xaxis",
        xAxisLabel: props.xAxisLabel,
        xAxisLabelOffset: props.xAxisLabelOffset,
        xScale: xScale,
        data: props.data,
        margins: margins,
        tickFormatting: props.xAxisFormatter,
        width: props.width - sideMargins,
        height: props.height - topBottomMargins
      }))));
    }
  });
  global.define = __define;
  return module.exports;
});



System.register("github:jspm/nodelibs-buffer@0.1.0", ["github:jspm/nodelibs-buffer@0.1.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-buffer@0.1.0/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/DOMPropertyOperations", ["./DOMProperty", "./escapeTextForBrowser", "./memoizeStringOnly", "./warning", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var DOMProperty = require("./DOMProperty");
    var escapeTextForBrowser = require("./escapeTextForBrowser");
    var memoizeStringOnly = require("./memoizeStringOnly");
    var warning = require("./warning");
    function shouldIgnoreValue(name, value) {
      return value == null || (DOMProperty.hasBooleanValue[name] && !value) || (DOMProperty.hasNumericValue[name] && isNaN(value)) || (DOMProperty.hasPositiveNumericValue[name] && (value < 1)) || (DOMProperty.hasOverloadedBooleanValue[name] && value === false);
    }
    var processAttributeNameAndPrefix = memoizeStringOnly(function(name) {
      return escapeTextForBrowser(name) + '="';
    });
    if ("production" !== process.env.NODE_ENV) {
      var reactProps = {
        children: true,
        dangerouslySetInnerHTML: true,
        key: true,
        ref: true
      };
      var warnedProperties = {};
      var warnUnknownProperty = function(name) {
        if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
          return;
        }
        warnedProperties[name] = true;
        var lowerCasedName = name.toLowerCase();
        var standardName = (DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null);
        ("production" !== process.env.NODE_ENV ? warning(standardName == null, 'Unknown DOM property ' + name + '. Did you mean ' + standardName + '?') : null);
      };
    }
    var DOMPropertyOperations = {
      createMarkupForID: function(id) {
        return processAttributeNameAndPrefix(DOMProperty.ID_ATTRIBUTE_NAME) + escapeTextForBrowser(id) + '"';
      },
      createMarkupForProperty: function(name, value) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          if (shouldIgnoreValue(name, value)) {
            return '';
          }
          var attributeName = DOMProperty.getAttributeName[name];
          if (DOMProperty.hasBooleanValue[name] || (DOMProperty.hasOverloadedBooleanValue[name] && value === true)) {
            return escapeTextForBrowser(attributeName);
          }
          return processAttributeNameAndPrefix(attributeName) + escapeTextForBrowser(value) + '"';
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            return '';
          }
          return processAttributeNameAndPrefix(name) + escapeTextForBrowser(value) + '"';
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
        return null;
      },
      setValueForProperty: function(node, name, value) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          var mutationMethod = DOMProperty.getMutationMethod[name];
          if (mutationMethod) {
            mutationMethod(node, value);
          } else if (shouldIgnoreValue(name, value)) {
            this.deleteValueForProperty(node, name);
          } else if (DOMProperty.mustUseAttribute[name]) {
            node.setAttribute(DOMProperty.getAttributeName[name], '' + value);
          } else {
            var propName = DOMProperty.getPropertyName[name];
            if (!DOMProperty.hasSideEffects[name] || ('' + node[propName]) !== ('' + value)) {
              node[propName] = value;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            node.removeAttribute(name);
          } else {
            node.setAttribute(name, '' + value);
          }
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
      },
      deleteValueForProperty: function(node, name) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          var mutationMethod = DOMProperty.getMutationMethod[name];
          if (mutationMethod) {
            mutationMethod(node, undefined);
          } else if (DOMProperty.mustUseAttribute[name]) {
            node.removeAttribute(DOMProperty.getAttributeName[name]);
          } else {
            var propName = DOMProperty.getPropertyName[name];
            var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
            if (!DOMProperty.hasSideEffects[name] || ('' + node[propName]) !== defaultValue) {
              node[propName] = defaultValue;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          node.removeAttribute(name);
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
      }
    };
    module.exports = DOMPropertyOperations;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactComponentBrowserEnvironment", ["./ReactDOMIDOperations", "./ReactMarkupChecksum", "./ReactMount", "./ReactPerf", "./ReactReconcileTransaction", "./getReactRootElementInContainer", "./invariant", "./setInnerHTML", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactDOMIDOperations = require("./ReactDOMIDOperations");
    var ReactMarkupChecksum = require("./ReactMarkupChecksum");
    var ReactMount = require("./ReactMount");
    var ReactPerf = require("./ReactPerf");
    var ReactReconcileTransaction = require("./ReactReconcileTransaction");
    var getReactRootElementInContainer = require("./getReactRootElementInContainer");
    var invariant = require("./invariant");
    var setInnerHTML = require("./setInnerHTML");
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var ReactComponentBrowserEnvironment = {
      ReactReconcileTransaction: ReactReconcileTransaction,
      BackendIDOperations: ReactDOMIDOperations,
      unmountIDFromEnvironment: function(rootNodeID) {
        ReactMount.purgeID(rootNodeID);
      },
      mountImageIntoNode: ReactPerf.measure('ReactComponentBrowserEnvironment', 'mountImageIntoNode', function(markup, container, shouldReuseMarkup) {
        ("production" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), 'mountComponentIntoNode(...): Target container is not valid.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)));
        if (shouldReuseMarkup) {
          if (ReactMarkupChecksum.canReuseMarkup(markup, getReactRootElementInContainer(container))) {
            return;
          } else {
            ("production" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side.') : invariant(container.nodeType !== DOC_NODE_TYPE));
            if ("production" !== process.env.NODE_ENV) {
              console.warn('React attempted to use reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server.');
            }
          }
        }
        ("production" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See renderComponentToString() for server rendering.') : invariant(container.nodeType !== DOC_NODE_TYPE));
        setInnerHTML(container, markup);
      })
    };
    module.exports = ReactComponentBrowserEnvironment;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/barchart/index", ["./BarChart"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.BarChart = require("./BarChart");
  global.define = __define;
  return module.exports;
});



System.register("npm:deep-extend@0.2.11/index", ["buffer"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var deepExtend = module.exports = function() {
      if (arguments.length < 1 || typeof arguments[0] !== 'object') {
        return false;
      }
      if (arguments.length < 2)
        return arguments[0];
      var target = arguments[0];
      var args = Array.prototype.slice.call(arguments, 1);
      var key,
          val,
          src,
          clone,
          tmpBuf;
      args.forEach(function(obj) {
        if (typeof obj !== 'object')
          return;
        for (key in obj) {
          if (!(key in obj))
            continue;
          src = target[key];
          val = obj[key];
          if (val === target)
            continue;
          if (typeof val !== 'object' || val === null) {
            target[key] = val;
            continue;
          } else if (val instanceof Buffer) {
            tmpBuf = new Buffer(val.length);
            val.copy(tmpBuf);
            target[key] = tmpBuf;
            continue;
          } else if (val instanceof Date) {
            target[key] = new Date(val.getTime());
            continue;
          }
          if (typeof src !== 'object' || src === null) {
            clone = (Array.isArray(val)) ? [] : {};
            target[key] = deepExtend(clone, val);
            continue;
          }
          if (Array.isArray(val)) {
            clone = (Array.isArray(src)) ? src : [];
          } else {
            clone = (!Array.isArray(src)) ? src : {};
          }
          target[key] = deepExtend(clone, val);
        }
      });
      return target;
    };
  })(require("buffer").Buffer);
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultInjection", ["./BeforeInputEventPlugin", "./ChangeEventPlugin", "./ClientReactRootIndex", "./CompositionEventPlugin", "./DefaultEventPluginOrder", "./EnterLeaveEventPlugin", "./ExecutionEnvironment", "./HTMLDOMPropertyConfig", "./MobileSafariClickEventPlugin", "./ReactBrowserComponentMixin", "./ReactComponentBrowserEnvironment", "./ReactDefaultBatchingStrategy", "./ReactDOMComponent", "./ReactDOMButton", "./ReactDOMForm", "./ReactDOMImg", "./ReactDOMInput", "./ReactDOMOption", "./ReactDOMSelect", "./ReactDOMTextarea", "./ReactEventListener", "./ReactInjection", "./ReactInstanceHandles", "./ReactMount", "./SelectEventPlugin", "./ServerReactRootIndex", "./SimpleEventPlugin", "./SVGDOMPropertyConfig", "./createFullPageComponent", "./ReactDefaultPerf", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var BeforeInputEventPlugin = require("./BeforeInputEventPlugin");
    var ChangeEventPlugin = require("./ChangeEventPlugin");
    var ClientReactRootIndex = require("./ClientReactRootIndex");
    var CompositionEventPlugin = require("./CompositionEventPlugin");
    var DefaultEventPluginOrder = require("./DefaultEventPluginOrder");
    var EnterLeaveEventPlugin = require("./EnterLeaveEventPlugin");
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var HTMLDOMPropertyConfig = require("./HTMLDOMPropertyConfig");
    var MobileSafariClickEventPlugin = require("./MobileSafariClickEventPlugin");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactComponentBrowserEnvironment = require("./ReactComponentBrowserEnvironment");
    var ReactDefaultBatchingStrategy = require("./ReactDefaultBatchingStrategy");
    var ReactDOMComponent = require("./ReactDOMComponent");
    var ReactDOMButton = require("./ReactDOMButton");
    var ReactDOMForm = require("./ReactDOMForm");
    var ReactDOMImg = require("./ReactDOMImg");
    var ReactDOMInput = require("./ReactDOMInput");
    var ReactDOMOption = require("./ReactDOMOption");
    var ReactDOMSelect = require("./ReactDOMSelect");
    var ReactDOMTextarea = require("./ReactDOMTextarea");
    var ReactEventListener = require("./ReactEventListener");
    var ReactInjection = require("./ReactInjection");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var ReactMount = require("./ReactMount");
    var SelectEventPlugin = require("./SelectEventPlugin");
    var ServerReactRootIndex = require("./ServerReactRootIndex");
    var SimpleEventPlugin = require("./SimpleEventPlugin");
    var SVGDOMPropertyConfig = require("./SVGDOMPropertyConfig");
    var createFullPageComponent = require("./createFullPageComponent");
    function inject() {
      ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
      ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
      ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
      ReactInjection.EventPluginHub.injectMount(ReactMount);
      ReactInjection.EventPluginHub.injectEventPluginsByName({
        SimpleEventPlugin: SimpleEventPlugin,
        EnterLeaveEventPlugin: EnterLeaveEventPlugin,
        ChangeEventPlugin: ChangeEventPlugin,
        CompositionEventPlugin: CompositionEventPlugin,
        MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,
        SelectEventPlugin: SelectEventPlugin,
        BeforeInputEventPlugin: BeforeInputEventPlugin
      });
      ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
      ReactInjection.NativeComponent.injectComponentClasses({
        'button': ReactDOMButton,
        'form': ReactDOMForm,
        'img': ReactDOMImg,
        'input': ReactDOMInput,
        'option': ReactDOMOption,
        'select': ReactDOMSelect,
        'textarea': ReactDOMTextarea,
        'html': createFullPageComponent('html'),
        'head': createFullPageComponent('head'),
        'body': createFullPageComponent('body')
      });
      ReactInjection.CompositeComponent.injectMixin(ReactBrowserComponentMixin);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
      ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
      ReactInjection.Updates.injectReconcileTransaction(ReactComponentBrowserEnvironment.ReactReconcileTransaction);
      ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
      ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
      ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
      if ("production" !== process.env.NODE_ENV) {
        var url = (ExecutionEnvironment.canUseDOM && window.location.href) || '';
        if ((/[?&]react_perf\b/).test(url)) {
          var ReactDefaultPerf = require("./ReactDefaultPerf");
          ReactDefaultPerf.start();
        }
      }
    }
    module.exports = {inject: inject};
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1/index", ["./barchart/index", "./linechart/index", "./piechart/index", "./areachart/index", "./treemap/index", "./scatterchart/index", "./candlestick/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.BarChart = require("./barchart/index").BarChart;
  exports.LineChart = require("./linechart/index").LineChart;
  exports.PieChart = require("./piechart/index").PieChart;
  exports.AreaChart = require("./areachart/index").AreaChart;
  exports.Treemap = require("./treemap/index").Treemap;
  exports.ScatterChart = require("./scatterchart/index").ScatterChart;
  exports.CandlestickChart = require("./candlestick/index").CandlestickChart;
  global.define = __define;
  return module.exports;
});



System.register("npm:deep-extend@0.2.11", ["npm:deep-extend@0.2.11/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:deep-extend@0.2.11/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/React", ["./DOMPropertyOperations", "./EventPluginUtils", "./ReactChildren", "./ReactComponent", "./ReactCompositeComponent", "./ReactContext", "./ReactCurrentOwner", "./ReactElement", "./ReactElementValidator", "./ReactDOM", "./ReactDOMComponent", "./ReactDefaultInjection", "./ReactInstanceHandles", "./ReactLegacyElement", "./ReactMount", "./ReactMultiChild", "./ReactPerf", "./ReactPropTypes", "./ReactServerRendering", "./ReactTextComponent", "./Object.assign", "./deprecated", "./onlyChild", "./ExecutionEnvironment", "process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var DOMPropertyOperations = require("./DOMPropertyOperations");
    var EventPluginUtils = require("./EventPluginUtils");
    var ReactChildren = require("./ReactChildren");
    var ReactComponent = require("./ReactComponent");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactContext = require("./ReactContext");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var ReactElement = require("./ReactElement");
    var ReactElementValidator = require("./ReactElementValidator");
    var ReactDOM = require("./ReactDOM");
    var ReactDOMComponent = require("./ReactDOMComponent");
    var ReactDefaultInjection = require("./ReactDefaultInjection");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var ReactLegacyElement = require("./ReactLegacyElement");
    var ReactMount = require("./ReactMount");
    var ReactMultiChild = require("./ReactMultiChild");
    var ReactPerf = require("./ReactPerf");
    var ReactPropTypes = require("./ReactPropTypes");
    var ReactServerRendering = require("./ReactServerRendering");
    var ReactTextComponent = require("./ReactTextComponent");
    var assign = require("./Object.assign");
    var deprecated = require("./deprecated");
    var onlyChild = require("./onlyChild");
    ReactDefaultInjection.inject();
    var createElement = ReactElement.createElement;
    var createFactory = ReactElement.createFactory;
    if ("production" !== process.env.NODE_ENV) {
      createElement = ReactElementValidator.createElement;
      createFactory = ReactElementValidator.createFactory;
    }
    createElement = ReactLegacyElement.wrapCreateElement(createElement);
    createFactory = ReactLegacyElement.wrapCreateFactory(createFactory);
    var render = ReactPerf.measure('React', 'render', ReactMount.render);
    var React = {
      Children: {
        map: ReactChildren.map,
        forEach: ReactChildren.forEach,
        count: ReactChildren.count,
        only: onlyChild
      },
      DOM: ReactDOM,
      PropTypes: ReactPropTypes,
      initializeTouchEvents: function(shouldUseTouch) {
        EventPluginUtils.useTouchEvents = shouldUseTouch;
      },
      createClass: ReactCompositeComponent.createClass,
      createElement: createElement,
      createFactory: createFactory,
      constructAndRenderComponent: ReactMount.constructAndRenderComponent,
      constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
      render: render,
      renderToString: ReactServerRendering.renderToString,
      renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
      unmountComponentAtNode: ReactMount.unmountComponentAtNode,
      isValidClass: ReactLegacyElement.isValidClass,
      isValidElement: ReactElement.isValidElement,
      withContext: ReactContext.withContext,
      __spread: assign,
      renderComponent: deprecated('React', 'renderComponent', 'render', this, render),
      renderComponentToString: deprecated('React', 'renderComponentToString', 'renderToString', this, ReactServerRendering.renderToString),
      renderComponentToStaticMarkup: deprecated('React', 'renderComponentToStaticMarkup', 'renderToStaticMarkup', this, ReactServerRendering.renderToStaticMarkup),
      isValidComponent: deprecated('React', 'isValidComponent', 'isValidElement', this, ReactElement.isValidElement)
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
        Component: ReactComponent,
        CurrentOwner: ReactCurrentOwner,
        DOMComponent: ReactDOMComponent,
        DOMPropertyOperations: DOMPropertyOperations,
        InstanceHandles: ReactInstanceHandles,
        Mount: ReactMount,
        MultiChild: ReactMultiChild,
        TextComponent: ReactTextComponent
      });
    }
    if ("production" !== process.env.NODE_ENV) {
      var ExecutionEnvironment = require("./ExecutionEnvironment");
      if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
        if (navigator.userAgent.indexOf('Chrome') > -1) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
            console.debug('Download the React DevTools for a better development experience: ' + 'http://fb.me/react-devtools');
          }
        }
        var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim, Object.create, Object.freeze];
        for (var i = 0; i < expectedFeatures.length; i++) {
          if (!expectedFeatures[i]) {
            console.error('One or more ES5 shim/shams expected by React are not available: ' + 'http://fb.me/react-warning-polyfills');
            break;
          }
        }
      }
    }
    React.version = '0.12.2';
    module.exports = React;
  })(require("process"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react-d3@0.3.1", ["npm:react-d3@0.3.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:react-d3@0.3.1/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:rcss@0.1.5/cascade", ["deep-extend"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var deepExtend = require('deep-extend');
  function cascade() {
    return deepExtend.bind(null, {}).apply(null, arguments);
  }
  module.exports = cascade;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/react", ["./lib/React"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("./lib/React");
  global.define = __define;
  return module.exports;
});



System.register("npm:rcss@0.1.5/index", ["./cascade", "./registerClass", "./styleRuleConverter"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var cascade = require("./cascade");
  var registerClass = require("./registerClass");
  var styleRuleConverter = require("./styleRuleConverter");
  var global = Function("return this")();
  global.__RCSS_0_registry = global.__RCSS_0_registry || {};
  function descriptorsToString(styleDescriptor) {
    return styleRuleConverter.rulesToString(styleDescriptor.className, styleDescriptor.style);
  }
  var RCSS = {
    cascade: cascade,
    registerClass: registerClass,
    injectAll: function() {
      var tag = document.createElement('style');
      tag.innerHTML = RCSS.getStylesString();
      document.getElementsByTagName('head')[0].appendChild(tag);
    },
    getStylesString: function() {
      var registry = global.__RCSS_0_registry;
      var str = '';
      for (var key in registry) {
        if (!registry.hasOwnProperty(key)) {
          continue;
        }
        str += descriptorsToString(registry[key]);
      }
      global.__RCSS_0_registry = {};
      return str;
    }
  };
  module.exports = RCSS;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2", ["npm:react@0.12.2/react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:react@0.12.2/react");
  global.define = __define;
  return module.exports;
});



System.register("npm:rcss@0.1.5", ["npm:rcss@0.1.5/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:rcss@0.1.5/index");
  global.define = __define;
  return module.exports;
});



System.register("lib/components/info-tip.jsx!github:floatdrop/plugin-jsx@0.1.1", ["react", "rcss", "lodash"], function($__export) {
  "use strict";
  var __moduleName = "lib/components/info-tip.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      RCSS,
      _,
      colors,
      infoTip,
      infoTipI,
      infoTipContainer,
      triangleBeforeAfter,
      infoTipTriangle,
      basicBorder,
      boxShadow,
      verticalShadow,
      infoTipContentContainer,
      R_infoTip,
      R_infoTipI,
      R_infoTipTriangle,
      R_verticalShadow,
      R_infoTipContainer,
      R_infoTipContentContainer,
      InfoTip;
  return {
    setters: [function(m) {
      React = m.default;
    }, function(m) {
      RCSS = m.default;
    }, function(m) {
      _ = m.default;
    }],
    execute: function() {
      colors = {
        grayLight: '#aaa',
        basicBorderColor: '#ccc',
        white: '#fff'
      };
      infoTip = {
        display: 'inline-block',
        marginLeft: '0px',
        position: 'relative',
        border: '0px dotted black',
        height: '25px',
        width: '25px'
      };
      infoTipI = {cursor: 'pointer'};
      infoTipContainer = {
        position: 'absolute',
        top: '30px',
        left: '0px',
        transform: 'translateX(-50%)',
        WebkitTransform: 'translateX(-50%)',
        zIndex: '1000',
        fontSize: '10pt'
      };
      triangleBeforeAfter = {
        borderLeft: '9px solid transparent',
        borderRight: '9px solid transparent',
        content: ' ',
        height: '0',
        position: 'absolute',
        top: '0',
        width: '0'
      };
      infoTipTriangle = {
        position: 'absolute',
        height: '0',
        width: '10px',
        left: '50%',
        top: '0',
        zIndex: '1',
        ':before': _.extend({}, triangleBeforeAfter, {
          borderBottom: '9px solid #bbb',
          top: '-9px'
        }),
        ':after': _.extend({}, triangleBeforeAfter, {
          borderBottom: ("9px solid " + colors.white),
          top: '-8px'
        })
      };
      basicBorder = {border: ("1px solid " + colors.basicBorderColor)};
      boxShadow = (function(str) {
        return {boxShadow: str};
      });
      verticalShadow = RCSS.cascade(basicBorder, boxShadow(("0 1px 3px " + colors.basicBorderColor)), {borderBottom: ("1px solid " + colors.grayLight)});
      infoTipContentContainer = RCSS.cascade(verticalShadow, {
        background: colors.white,
        padding: '5px 10px',
        width: '240px'
      });
      R_infoTip = RCSS.registerClass(infoTip);
      R_infoTipI = RCSS.registerClass(infoTipI);
      R_infoTipTriangle = RCSS.registerClass(infoTipTriangle);
      R_verticalShadow = RCSS.registerClass(verticalShadow);
      R_infoTipContainer = RCSS.registerClass(infoTipContainer);
      R_infoTipContentContainer = RCSS.registerClass(infoTipContentContainer);
      RCSS.injectAll();
      InfoTip = React.createClass({
        displayName: "InfoTip",
        getInitialState: function() {
          return {
            hover: false,
            secondTouch: false
          };
        },
        getDefaultProps: function() {
          return {iconSize: "fa-lg"};
        },
        render: function() {
          var fa_classes = "fa fa-info-circle " + this.props.iconSize;
          return (React.createElement("div", {
            className: R_infoTip.className,
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave
          }, React.createElement("div", {className: "dummy"}), React.createElement("div", {
            className: "img-container",
            onTouchStart: this.handleTouchStart
          }, React.createElement("span", null, React.createElement("i", {className: fa_classes}))), React.createElement("div", {
            className: R_infoTipContainer.className,
            style: {
              WebkitTouchCallout: "default",
              display: this.state.hover ? 'block' : 'none'
            }
          }, React.createElement("div", {className: R_infoTipTriangle.className}), React.createElement("div", {
            className: R_infoTipContentContainer.className,
            style: {width: this.props.width}
          }, this.props.children))));
        },
        handleTouchStart: function() {
          this.setState({hover: true});
        },
        handleMouseEnter: function() {
          this.setState({hover: true});
        },
        handleMouseLeave: function() {
          this.setState({hover: false});
        }
      });
      $__export("InfoTip", InfoTip);
    }
  };
});



System.register("lib/components/bundle-widget.jsx!github:floatdrop/plugin-jsx@0.1.1", ["react", "immstruct", "omniscient", "immutable", "./tangle-text.jsx!", "lodash", "react-d3", "./deps/payoff-linechart.js!jsx", "./info-tip.jsx!", "./react-checkbox-group.jsx!", "./grouped-stacked-barchart.jsx!"], function($__export) {
  "use strict";
  var __moduleName = "lib/components/bundle-widget.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      immstruct,
      component,
      Immutable,
      TangleText,
      _,
      rd3,
      PayoffLineChart,
      InfoTip,
      CheckboxGroup,
      ChartContainer,
      GroupStackedBarChart,
      structure,
      inputMixin,
      StateView,
      BundleWidget;
  function vectorSum(vec_a, vec_b) {
    return vec_a.map((function(a, i) {
      return a + vec_b[i];
    }));
  }
  return {
    setters: [function(m) {
      React = m.default;
    }, function(m) {
      immstruct = m.default;
    }, function(m) {
      component = m.default;
    }, function(m) {
      Immutable = m.default;
    }, function(m) {
      TangleText = m.default;
    }, function(m) {
      _ = m.default;
    }, function(m) {
      rd3 = m.default;
    }, function(m) {
      PayoffLineChart = m.default;
    }, function(m) {
      InfoTip = m.InfoTip;
    }, function(m) {
      CheckboxGroup = m.default;
    }, function(m) {
      ChartContainer = m.ChartContainer;
    }],
    execute: function() {
      GroupStackedBarChart = ChartContainer;
      structure = immstruct({market: {
          longLeverage: 2,
          shortLeverage: 0,
          optionStrikePrice: 7,
          premiumPrice: 1.5,
          showBundles: ['buy_put', 'write_put']
        }});
      inputMixin = {
        onInputLongLeverage: function(val) {
          this.props.cursor.update('longLeverage', (function(old_val) {
            return val.target.value;
          }));
        },
        onInputShortLeverage: function(val) {
          this.props.cursor.update('shortLeverage', (function(old_val) {
            return val.target.value;
          }));
        },
        onStrikePriceChange: function(val) {
          this.props.cursor.update('optionStrikePrice', (function(old_val) {
            return val.target.value;
          }));
        },
        onPremiumChange: function(val) {
          this.props.cursor.update('premiumPrice', (function(old_val) {
            return val.target.value;
          }));
        },
        handleBundlesChange: function() {
          var selectedBundles = this.refs.bundlesGroup.getCheckedValues();
          this.props.cursor.update('showBundles', (function(oldVec) {
            return Immutable.fromJS(selectedBundles);
          }));
        }
      };
      StateView = component(inputMixin, function(cursor) {
        var curs = cursor.cursor;
        var option_premium = curs.get('premiumPrice');
        var show_bundles = curs.get('showBundles').deref().toArray();
        var discrete_log_returns = _.range(7, -8, -1).map((function(i) {
          return Math.exp(Math.log(1.1) * i);
        }));
        var stable_dollars_amount = 1000;
        var stable_test = discrete_log_returns.map((function(e) {
          return e * stable_dollars_amount;
        }));
        var test_labels = stable_test.map((function(q, i) {
          return ("q" + i);
        }));
        var usd_labels = discrete_log_returns.map((function(e) {
          return "$" + (e * 10).toFixed(2);
        })).reverse();
        var short_leverage = curs.get('shortLeverage');
        var initial_price = 10;
        var log_returns = discrete_log_returns;
        var outcome_prices = log_returns.map((function(log_return) {
          return log_return * initial_price;
        }));
        var short_percent_change = log_returns.map((function(log_return) {
          return (log_return - 1) * short_leverage;
        }));
        var short_dollar_payouts = short_percent_change.map((function(pc) {
          return (1 + pc) * initial_price;
        }));
        var short_coin_payouts = short_dollar_payouts.map((function(usd_payout, i) {
          return usd_payout / outcome_prices[i];
        }));
        var short_coin_payouts_truncated = short_coin_payouts.map((function(coin_payout) {
          return coin_payout > 2 ? 2 : coin_payout;
        }));
        short_coin_payouts_truncated = short_coin_payouts_truncated.map((function(coin_payout) {
          return coin_payout < 0 ? 0 : coin_payout;
        }));
        var short_bet_amount = 100;
        var short_test = log_returns.map((function(e) {
          return e * short_bet_amount;
        }));
        var short_bundle = short_coin_payouts_truncated.map((function(coin_payout) {
          return coin_payout * short_bet_amount;
        }));
        var short_bundle_usd_payout = short_bundle.map((function(coin_payout, i) {
          return coin_payout * outcome_prices[i];
        }));
        var short_max_payout_coins = _.max(short_bundle);
        var long_leverage = curs.get('longLeverage');
        var long_percent_change = log_returns.map((function(log_return) {
          return (log_return - 1) * long_leverage;
        }));
        var long_dollar_payouts = long_percent_change.map((function(pc) {
          return (1 + pc) * initial_price;
        }));
        var long_coin_payouts = long_dollar_payouts.map((function(usd_payout, i) {
          return usd_payout / outcome_prices[i];
        }));
        var long_coin_payouts_truncated = long_coin_payouts.map((function(coin_payout) {
          return coin_payout > 2 ? 2 : coin_payout;
        }));
        long_coin_payouts_truncated = long_coin_payouts_truncated.map((function(coin_payout) {
          return coin_payout < 0 ? 0 : coin_payout;
        }));
        var long_bet_amount = 100;
        var long_bundle = long_coin_payouts_truncated.map((function(coin_payout) {
          return coin_payout * long_bet_amount;
        }));
        var long_bundle_usd_payout = long_bundle.map((function(coin_payout, i) {
          return coin_payout * outcome_prices[i];
        }));
        var initial_investment = long_bet_amount * initial_price;
        var long_max_payout_coins = _.max(long_bundle);
        var limit_order_short = {inv_vector: short_bundle.reverse()};
        var limit_order_long = {inv_vector: long_bundle.reverse()};
        var option_strike_price = curs.get('optionStrikePrice');
        var strike_price_slider_val = curs.get('optionStrikePrice');
        var usd_prices = discrete_log_returns.map((function(e) {
          return parseFloat((e * 10).toFixed(2));
        })).reverse();
        var short_payoff_series = short_bundle_usd_payout.reverse().map((function(usd_pay, i) {
          return {
            x: usd_prices[i],
            y: usd_pay - initial_investment
          };
        }));
        var long_payoff_series = long_bundle_usd_payout.reverse().map((function(usd_pay, i) {
          return {
            x: usd_prices[i],
            y: usd_pay - initial_investment
          };
        }));
        var payoffData = [{
          name: 'short payoff in USD',
          values: short_payoff_series
        }, {
          name: 'long payoff in USD',
          values: long_payoff_series
        }];
        var outcome_strike_prices = outcome_prices.slice().reverse();
        var usd_strike_price = outcome_strike_prices[option_strike_price];
        var option_bet_amount = 100;
        var outcome_prices_usd = outcome_prices.slice().reverse();
        var strike_price_usd = outcome_prices_usd[option_strike_price];
        var strike_price_index = strike_price_slider_val;
        var lower_strike_price = d3.min(outcome_prices_usd);
        var upper_strike_price = d3.max(outcome_prices_usd);
        var strike_price = outcome_prices_usd[strike_price_index];
        var put_payoff_max = ((strike_price - lower_strike_price) / lower_strike_price) * option_bet_amount;
        var call_payoff_max = ((upper_strike_price - strike_price) / upper_strike_price) * option_bet_amount;
        var option_unit_ratio = put_payoff_max / call_payoff_max;
        var buy_call_amount = option_bet_amount * option_unit_ratio;
        var buy_call_usd_returns = outcome_prices.map((function(qi, i) {
          if (i > strike_price_index) {
            var price_diff = outcome_prices_usd[i] - outcome_prices_usd[strike_price_index];
            return Math.abs(price_diff);
          } else {
            return 0;
          }
        }));
        var buy_call_usd_payoffs = buy_call_usd_returns.map((function(usd_return) {
          return usd_return * buy_call_amount;
        }));
        var buy_call_coin_payoffs = buy_call_usd_payoffs.map((function(usd_payoff, i) {
          return usd_payoff / outcome_prices_usd[i];
        }));
        var call_max_payoff = _.max(buy_call_coin_payoffs);
        var write_call_coin_payoffs = buy_call_coin_payoffs.map((function(call) {
          return call_max_payoff - call;
        }));
        var buy_put_amount = option_bet_amount;
        var buy_put_usd_returns = outcome_prices.map((function(qi, i) {
          if (i < strike_price_index) {
            var price_diff = outcome_prices_usd[i] - outcome_prices_usd[strike_price_index];
            return Math.abs(price_diff);
          } else {
            return 0;
          }
        }));
        var buy_put_usd_payoffs = buy_put_usd_returns.map((function(usd_return) {
          return usd_return * buy_put_amount;
        }));
        var buy_put_coin_payoffs = buy_put_usd_payoffs.map((function(usd_payoff, i) {
          return usd_payoff / outcome_prices_usd[i];
        }));
        var put_max_payoff = _.max(buy_put_coin_payoffs);
        var write_put_coin_payoffs = buy_put_coin_payoffs.map((function(put) {
          return put_max_payoff - put;
        }));
        var straddle_bundle = vectorSum(buy_call_coin_payoffs, buy_put_coin_payoffs);
        var butterfly_bundle = write_call_coin_payoffs.map((function(wc, i) {
          if (i < strike_price_index) {
            return write_put_coin_payoffs[i];
          }
          if (i > strike_price_index) {
            return write_call_coin_payoffs[i];
          }
          if (i == strike_price_index) {
            return write_call_coin_payoffs[i];
          }
        }));
        var current_price = initial_price;
        var put_option_premium_price = option_premium;
        var put_option_premium_coins = put_option_premium_price * option_bet_amount / current_price;
        var buy_put_bundle_cost_coins = put_option_premium_coins;
        var write_put_bundle_cost_coins = put_max_payoff - put_option_premium_coins;
        var call_option_premium_price = option_premium;
        var call_option_premium_coins = call_option_premium_price * option_bet_amount / current_price;
        var buy_call_bundle_cost_coins = call_option_premium_coins;
        var write_call_bundle_cost_coins = call_max_payoff - call_option_premium_coins;
        var straddle_bundle_cost_coins = buy_put_bundle_cost_coins + buy_call_bundle_cost_coins;
        var straddle_bundle_max_payoff = _.max([call_max_payoff, put_max_payoff]);
        var butterfly_bundle_cost_coins = straddle_bundle_max_payoff - straddle_bundle_cost_coins;
        var butterfly_bundle_max_payoff = _.max(butterfly_bundle);
        function riskToWinText(bundle_type) {
          var riskText;
          var winText;
          var styleClass;
          if (bundle_type === 'write_put') {
            styleClass = "write";
            riskText = ("risks: " + (put_max_payoff - buy_put_bundle_cost_coins).toFixed(2) + " BTC");
            winText = ("to win " + buy_put_bundle_cost_coins.toFixed(2) + " BTC");
          }
          if (bundle_type === 'buy_put') {
            styleClass = "buy";
            riskText = ("risks: " + buy_put_bundle_cost_coins.toFixed(2) + " BTC");
            winText = ("to win: " + (put_max_payoff - buy_put_bundle_cost_coins).toFixed(2) + " BTC");
          }
          if (bundle_type === 'write_call') {
            styleClass = "write";
            riskText = ("risks: " + (call_max_payoff - buy_call_bundle_cost_coins).toFixed(2) + " BTC");
            winText = ("to win " + buy_call_bundle_cost_coins.toFixed(2) + " BTC");
          }
          if (bundle_type === 'buy_call') {
            styleClass = "buy";
            riskText = ("risks: " + buy_call_bundle_cost_coins.toFixed(2) + " BTC");
            winText = ("to win: " + (call_max_payoff - buy_call_bundle_cost_coins).toFixed(2) + " BTC");
          }
          if (bundle_type === 'straddle') {
            styleClass = "buy";
            riskText = ("risks: " + straddle_bundle_cost_coins.toFixed(2) + " BTC");
            winText = ("to win: " + (straddle_bundle_max_payoff - straddle_bundle_cost_coins).toFixed(2) + " BTC");
          }
          if (bundle_type === 'butterfly') {
            styleClass = "write";
            riskText = ("risks: " + (straddle_bundle_max_payoff - straddle_bundle_cost_coins).toFixed(2) + " BTC");
            winText = ("to win " + straddle_bundle_cost_coins.toFixed(2) + " BTC");
          }
          if (bundle_type === 'short') {
            styleClass = "buy";
            riskText = ("risks: " + short_bet_amount.toFixed(2) + " BTC");
            winText = ("to win: " + (short_max_payout_coins - short_bet_amount).toFixed(2) + " BTC");
          }
          if (bundle_type === 'long') {
            styleClass = "write";
            riskText = ("risks: " + long_bet_amount.toFixed(2) + " BTC");
            winText = ("to win: " + (long_max_payout_coins - long_bet_amount).toFixed(2) + " BTC");
          }
          return {
            'risk': riskText,
            'win': winText
          };
        }
        var OptionLabels = {
          'buy_call': "Buy a Call",
          'write_call': "Write a Call",
          'buy_put': "Buy a Put",
          'write_put': "Write a Put",
          'straddle': "Straddle",
          'butterfly': "Butterfly",
          'short': "Short Bundle",
          'long': "Long Bundle"
        };
        var BUNDLE_COLOR_DEFS = {
          'short': "#882255",
          'long': "#117733",
          'buy_call': "#999933",
          'write_call': "#DDCC77",
          'buy_put': "#CC6677",
          'write_put': "#88CCEE",
          'straddle': "#332288",
          'butterfly': "#44AA99"
        };
        var OPTION_TOOLTIPS = {
          'straddle': (React.createElement("div", {style: {
              display: 'inline-block',
              marginTop: "-10px"
            }}, React.createElement(InfoTip, {iconSize: ""}, React.createElement("span", null, "A ", React.createElement("a", {href: "http://en.wikipedia.org/wiki/Straddle"}, "straddle"), " is a bet ", React.createElement("i", null, "on"), " volatility. The bettor wins if the price changes, whether up or down; max payoff at either end of the range ($5.13 or $19.49).")))),
          'butterfly': (React.createElement("div", {style: {
              display: 'inline-block',
              marginTop: "-10px"
            }}, React.createElement(InfoTip, {iconSize: ""}, React.createElement("span", null, "A ", React.createElement("a", {href: "https://en.wikipedia.org/wiki/Butterfly_(options)"}, "butterfly"), " is a bet ", React.createElement("i", null, "against"), " volatility. The bettor wins if the price goes sideways; max payoff if BTC price is at $10.00 when the option expires."))))
        };
        function bundleCheckbox(bundle_type) {
          var risk_to_win = {
            'risk': '',
            'win': ''
          };
          if (_.contains(show_bundles, bundle_type)) {
            risk_to_win = riskToWinText(bundle_type);
          }
          var bundle_class = bundle_type.replace("_", "-");
          var bundle_color = BUNDLE_COLOR_DEFS[bundle_type];
          return (React.createElement("div", null, React.createElement("div", {
            className: "flex-row-start-center",
            style: {
              marginTop: "-5px",
              marginLeft: "10px"
            }
          }, React.createElement("div", null, React.createElement("label", {className: "option-group " + bundle_class}, React.createElement("input", {
            type: "checkbox",
            className: "option-group",
            name: "bundle",
            value: bundle_type
          }), React.createElement("div", {className: "option-checkbox " + bundle_class}))), React.createElement("div", {style: {display: 'inline-block'}}, OptionLabels[bundle_type]), _.has(OPTION_TOOLTIPS, bundle_type) ? OPTION_TOOLTIPS[bundle_type] : ''), React.createElement("div", {
            id: "riskToWin",
            className: ""
          }, React.createElement("span", null, risk_to_win.risk), React.createElement("br", null), React.createElement("span", null, risk_to_win.win))));
        }
        var limit_order_buy_call = {
          inv_vector: buy_call_coin_payoffs,
          type: 'buy_call'
        };
        var limit_order_write_call = {
          inv_vector: write_call_coin_payoffs,
          type: 'write_call'
        };
        var limit_order_buy_put = {
          usd_labels: usd_labels,
          inv_vector: buy_put_coin_payoffs,
          type: 'buy_put'
        };
        var limit_order_write_put = {
          inv_vector: write_put_coin_payoffs,
          type: 'write_put'
        };
        var butterfly_portfolio = {
          inv_vector: butterfly_bundle,
          type: 'butterfly'
        };
        var straddle_portfolio = {
          inv_vector: straddle_bundle,
          type: 'straddle'
        };
        var bundleTypeCollection = {
          'short': limit_order_short,
          'long': limit_order_long,
          'buy_put': limit_order_buy_put,
          'write_put': limit_order_write_put,
          'buy_call': limit_order_buy_call,
          'write_call': limit_order_write_call,
          'straddle': straddle_portfolio,
          'butterfly': butterfly_portfolio
        };
        var limit_order_bundles = show_bundles.map((function(bundle_type) {
          return bundleTypeCollection[bundle_type];
        }));
        var buy_call_payoff_series = buy_call_coin_payoffs.map((function(coin_payoff, i) {
          return {
            x: usd_prices[i],
            y: coin_payoff - buy_call_bundle_cost_coins
          };
        }));
        var write_call_payoff_series = write_call_coin_payoffs.map((function(coin_payoff, i) {
          return {
            x: usd_prices[i],
            y: coin_payoff - write_call_bundle_cost_coins
          };
        }));
        var buy_put_payoff_series = buy_put_coin_payoffs.map((function(coin_payoff, i) {
          return {
            x: usd_prices[i],
            y: coin_payoff - buy_put_bundle_cost_coins
          };
        }));
        var write_put_payoff_series = write_put_coin_payoffs.map((function(coin_payoff, i) {
          return {
            x: usd_prices[i],
            y: coin_payoff - write_put_bundle_cost_coins
          };
        }));
        var straddle_payoff_series = straddle_bundle.map((function(coin_payoff, i) {
          return {
            x: usd_prices[i],
            y: coin_payoff - straddle_bundle_cost_coins
          };
        }));
        var butterfly_payoff_series = butterfly_bundle.map((function(coin_payoff, i) {
          return {
            x: usd_prices[i],
            y: coin_payoff - butterfly_bundle_cost_coins
          };
        }));
        var payoffSeriesTypes = {
          'buy_call': buy_call_payoff_series,
          'write_call': write_call_payoff_series,
          'buy_put': buy_put_payoff_series,
          'write_put': write_put_payoff_series,
          'straddle': straddle_payoff_series,
          'butterfly': butterfly_payoff_series
        };
        var optionPayoffDiagramData = show_bundles.filter((function(bt) {
          return !(bt == "short" || bt == "long");
        })).map((function(bundle_type) {
          return {
            name: bundle_type,
            values: payoffSeriesTypes[bundle_type],
            color: BUNDLE_COLOR_DEFS[bundle_type]
          };
        }));
        var bundle_colors = show_bundles.map((function(bundle_type) {
          return BUNDLE_COLOR_DEFS[bundle_type];
        }));
        return (React.createElement("div", null, React.createElement("div", {className: "flex-row-space"}, React.createElement("div", {style: {
            border: "0px dotted gray",
            overflow: "visible",
            width: "470px"
          }}, React.createElement("div", {style: {
            border: "0px solid black",
            width: "470px"
          }}, React.createElement("div", {style: {
            'textAlign': 'center',
            paddingBottom: "10px"
          }}, React.createElement("b", null, "Visualizing the Payoffs of Binary Option Portfolios")), React.createElement(GroupStackedBarChart, {
          dataBidBundles: limit_order_bundles,
          outcomePrices: outcome_prices.reverse(),
          outcomeLabels: usd_labels,
          colors: bundle_colors,
          width: 400,
          height: 400
        }), React.createElement("div", {style: {marginTop: "15px"}}, "Number of outcomes: ", outcome_prices.length, React.createElement(InfoTip, {
          width: "300px",
          iconSize: ""
        }, React.createElement("span", null, "The discrete set of prices [$5.13, $5.64, ..., $17.72, $19.49] is the ", React.createElement("b", null, "outcome space"), ". Each outcome or state represents an item or atomic security (i.e. a binary option) that is traded in the combinatorial market. On the expiration date, one outcome will be realized, and the binary options for that outcome will be worth 1 unit of the numeraire (BTC); the binary options for all other outcomes will be worth 0 units of the numeraire."))), React.createElement("div", {style: {marginTop: "15px"}}, "Market numeraire: BTC", React.createElement(InfoTip, {
          width: "300px",
          iconSize: ""
        }, React.createElement("span", null, "The ", React.createElement("b", null, "numeraire"), " is the currency used in the market. More specifically, the numeraire specifies a unit amount of some currency, and all binary options in the market will payoff either one unit of the numeraire, or zero. Since this example is an on-chain market where the only currency available is BTC, we must use BTC as the numeraire."))))), React.createElement("div", {
          className: "flex-column-start",
          style: {
            width: "380px",
            border: "red solid 0px"
          }
        }, React.createElement("div", null, React.createElement(CheckboxGroup, {
          name: "bundles",
          value: show_bundles,
          ref: "bundlesGroup",
          onChange: this.handleBundlesChange
        }, React.createElement("div", null, React.createElement("div", null, React.createElement("b", null, "CFD BETS"), React.createElement(InfoTip, {iconSize: ""}, React.createElement("span", null, "We use bundles of binary options to replicate the payoffs of ", React.createElement("a", {href: "https://en.wikipedia.org/wiki/Contract_for_difference"}, "Contract for Difference"), " (CFD) bets at a desired leverage or \"gearing ratio\"."))), React.createElement("div", {style: {
            'border': "1px black dotted",
            borderRadius: "5px",
            "padding": "5px",
            marginBottom: "15px",
            paddingLeft: "10px",
            paddingRight: "10px"
          }}, React.createElement("div", {className: "flex-row-space"}, React.createElement("div", {className: "flex-column-start"}, React.createElement("div", null, "Short Leverage: ", short_leverage, "x"), React.createElement("div", {style: {marginBottom: "5px"}}, React.createElement("input", {
          id: "shortLeverage",
          key: "shortLeverage",
          name: "leverage",
          type: "range",
          min: "-5",
          max: "0",
          value: short_leverage,
          onChange: this.onInputShortLeverage
        })), bundleCheckbox("short")), React.createElement("div", null, React.createElement("br", null), React.createElement("br", null), React.createElement("i", {className: "fa fa-arrows-h"})), React.createElement("div", {className: "flex-column-start"}, React.createElement("div", null, "Long Leverage: ", long_leverage, "x"), React.createElement("div", {style: {marginBottom: "5px"}}, React.createElement("input", {
          id: "longLeverage",
          key: "longLeverage",
          name: "leverage",
          type: "range",
          min: "1",
          max: "7",
          value: long_leverage,
          onChange: this.onInputLongLeverage
        })), bundleCheckbox("long")))), React.createElement("div", {style: {'textAlign': 'center'}}, React.createElement("b", null, "OPTION BETS"), React.createElement(InfoTip, {iconSize: ""}, React.createElement("span", null, "We use bundles of binary options to construct synthetic positions that replicate the payoffs of conventional options."))), React.createElement("div", {style: {
            'border': "black dotted 1px",
            borderRadius: "5px",
            "padding": "5px"
          }}, React.createElement("div", {className: "flex-row-space"}, React.createElement("div", {style: {
            textAlign: 'center',
            marginTop: '0',
            marginLeft: "5px",
            marginBottom: '10px',
            'display': 'inline-block'
          }}, "Strike price: $", usd_strike_price.toFixed(2), React.createElement("br", null), React.createElement("input", {
          id: "strikePrice",
          key: "strikePrice",
          name: "strikePrice",
          type: "range",
          min: "0",
          max: discrete_log_returns.length,
          value: strike_price_slider_val,
          onChange: this.onStrikePriceChange
        })), React.createElement("div", {style: {
            textAlign: 'center',
            marginTop: '0',
            marginRight: "5px",
            marginBottom: '10px',
            'display': 'inline-block'
          }}, "Premium", React.createElement("div", {style: {
            display: 'inline-block',
            marginTop: "-10px",
            marginLeft: "-5px"
          }}, React.createElement(InfoTip, {iconSize: ""}, React.createElement("span", null, "The ", React.createElement("a", {href: "http://www.investopedia.com/terms/o/option-premium.asp"}, "premium"), " price is quoted in USD but paid in BTC (we assume the current BTC/USD price is $10.00). Since options are quoted in ", React.createElement("a", {href: "http://www.investopedia.com/terms/c/contractunit.asp"}, "contract units"), " of 100 shares, a premium price of $1.50 means that the option buyer pays ($1.50/$10.00 = 0.15 BTC * 100) = 15 BTC to the option writer."))), ": $", parseFloat(option_premium).toFixed(2), React.createElement("br", null), React.createElement("input", {
          id: "premiumPrice",
          key: "premiumPrice",
          name: "premiumPrice",
          type: "range",
          min: "0",
          max: "5",
          step: "0.1",
          value: option_premium,
          onChange: this.onPremiumChange
        }))), React.createElement("div", {className: "optionFlexTable"}, React.createElement("div", {className: "optionHeader"}), React.createElement("div", {className: "optionColTable"}, React.createElement("div", {className: "optionColumn left"}, bundleCheckbox("buy_call"), bundleCheckbox("buy_put"), bundleCheckbox("straddle")), React.createElement("div", {
          className: "optionColumn center",
          style: {
            "alignItems": "center",
            fontSize: "18px",
            borderBottom: "1px solid black"
          }
        }, React.createElement("div", null, React.createElement("i", {className: "fa fa-arrows-h"})), React.createElement("div", null, React.createElement("i", {className: "fa fa-arrows-h"})), React.createElement("div", null, React.createElement("i", {className: "fa fa-arrows-h"}))), React.createElement("div", {className: "optionColumn right"}, bundleCheckbox("write_call"), bundleCheckbox("write_put"), bundleCheckbox("butterfly"))), " "), " ")))), React.createElement("div", {style: {
            width: "380px",
            height: "220px",
            border: "0px solid green",
            marginTop: "20px"
          }}, React.createElement("div", {style: {height: "20px"}}, React.createElement("b", null, "Option Payoff Diagram"), React.createElement(InfoTip, {iconSize: ""}, React.createElement("span", null, React.createElement("a", {href: "http://www.google.com/images?q=option+payoff+diagram"}, "Payoff diagrams"), " are used to plot the Profit & Loss (PnL) curves of option strategies. Here we plot the PnL curves for the selected synthetic positions."))), React.createElement("div", {
          className: "flex-row-start-center",
          style: {
            marginTop: "-20px",
            marginLeft: "-25px"
          }
        }, React.createElement("div", {style: {
            'transform': 'rotate(-90deg)',
            'WebkitTransform': 'rotate(-90deg)',
            border: "0px solid green",
            marginRight: "-30px"
          }}, "PnL (BTC)"), React.createElement("div", {style: {border: "0px dotted red"}}, React.createElement(PayoffLineChart, {
          legend: false,
          data: optionPayoffDiagramData,
          width: 350,
          height: 200
        }))))))));
      }).jsx;
      BundleWidget = (function() {
        var BundleWidget = function BundleWidget() {};
        return ($traceurRuntime.createClass)(BundleWidget, {init: function(el) {
            render(el);
            structure.on('swap', render);
            function render() {
              React.render(React.createElement(StateView, {cursor: structure.cursor('market')}), el);
            }
          }}, {});
      }());
      $__export('default', new BundleWidget());
    }
  };
});



System.register("lib/main.jsx!github:floatdrop/plugin-jsx@0.1.1", ["react", "./components/bundle-widget.jsx!", "./components/lp-bundle-matching.jsx!", "./components/msr-depth-curve.jsx!"], function($__export) {
  "use strict";
  var __moduleName = "lib/main.jsx!github:floatdrop/plugin-jsx@0.1.1";
  var React,
      BundleWidget,
      LPBundleWidget,
      BidAskDepthWidget;
  return {
    setters: [function(m) {
      React = m.default;
    }, function(m) {
      BundleWidget = m.default;
    }, function(m) {
      LPBundleWidget = m.default;
    }, function(m) {
      BidAskDepthWidget = m.default;
    }],
    execute: function() {
      BundleWidget.init(document.querySelector('#bundleWidget'));
      LPBundleWidget.init(document.querySelector('#LPWidget'));
      BidAskDepthWidget.init(document.querySelector('#MSRDepthWidget'));
      $__export('default', {});
    }
  };
});



//# sourceMappingURL=build.js.map